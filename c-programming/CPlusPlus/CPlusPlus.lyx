#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrartcl
\begin_preamble
\usepackage{Sweavel}
\usepackage{graphicx}
\usepackage{color}

\usepackage[samesize]{cancel}



\usepackage{ifthen}

\makeatletter

\renewenvironment{figure}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{figure}

 }{%

   \@float{figure}[#1]%

 }%

 \centering

}{%

 \end@float

}

\renewenvironment{table}[1][]{%

 \ifthenelse{\equal{#1}{}}{%

   \@float{table}

 }{%

   \@float{table}[#1]%

 }%

 \centering

%  \setlength{\@tempdima}{\abovecaptionskip}%

%  \setlength{\abovecaptionskip}{\belowcaptionskip}%

% \setlength{\belowcaptionskip}{\@tempdima}%

}{%

 \end@float

}


%\usepackage{listings}
% Make ordinary listings look as if they come from Sweave
\lstset{tabsize=2, breaklines=true,style=Rstyle}

% In document Latex options:
\fvset{listparameters={\setlength{\topsep}{0em}}}
\def\Sweavesize{\normalsize} 
\def\Rcolor{\color{black}} 
\def\Rbackground{\color[gray]{0.95}}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
C++ Notes
\end_layout

\begin_layout Author
Paul Johnson <pauljohn@ku.edu>
\end_layout

\begin_layout Date
2013
\end_layout

\begin_layout Section
Superficially: Not so different from C.
\end_layout

\begin_layout Enumerate
C and C++ both have header files, implementation files
\end_layout

\begin_deeper
\begin_layout Standard
C: suffixes .h and .c
\end_layout

\begin_layout Standard
C++: usually either (.h and .cpp), or (.hh and .cc).
 
\end_layout

\begin_layout Standard
See: example-1-hello.cc
\end_layout

\end_deeper
\begin_layout Enumerate
Compiler: g++ replaces gcc
\end_layout

\begin_deeper
\begin_layout Standard
C:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ gcc -Wall myFile.c -o myProgram
\end_layout

\begin_layout Plain Layout

$ ./myProgram
\end_layout

\end_inset


\end_layout

\begin_layout Standard
C++:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ g++ -Wall myFile.cc -o myProgram
\end_layout

\begin_layout Plain Layout

$ ./my Program
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
main() function.
 Required.
 
\end_layout

\begin_deeper
\begin_layout Standard
Get in the habit of writing out the main function's arguments.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

main(int argc, char * argv[])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
See: example-2-arguments.cc
\end_layout

\end_deeper
\begin_layout Enumerate
Functions
\end_layout

\begin_deeper
\begin_layout Enumerate
format: same
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

return-type function-name (type name, type name){
\end_layout

\begin_layout Plain Layout

  //calculations here;
\end_layout

\begin_layout Plain Layout

return something-matching-the-promised-return-type;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
pass by value, or pass by reference.
 Same.
\end_layout

\begin_layout Enumerate
My Guru Said 
\begin_inset Quotes eld
\end_inset

constify anything that will bear it.
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

const
\begin_inset Quotes erd
\end_inset

 modifier exists in C and in C++.
 Used to protect arguments from modification
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void myGreatFunction(const int *x, const double *y, double * z);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The const modifier will protect x and y from change, but z can be revised
 in the function.
 This is how functions in the GSL or BLAS generally work.
\end_layout

\end_deeper
\begin_layout Enumerate
prototypes: interface declarations, usually in separate *.h files.
 Function names;
\end_layout

\begin_layout Enumerate
Difference: C++ allows 
\begin_inset Quotes eld
\end_inset

overloaded
\begin_inset Quotes erd
\end_inset

 functions.
 Use the SAME NAME for a function over and over again, and vary the argument
 types.
\end_layout

\end_deeper
\begin_layout Enumerate
C variable types present in C++ as well
\end_layout

\begin_deeper
\begin_layout Standard
All of the types from C are available: int, float, double, char.
\end_layout

\begin_layout Standard
C++ and its Standard Library offer easy access to a larger set of variable
 types
\end_layout

\end_deeper
\begin_layout Enumerate
Math: same! * / % += *= ++i i++ 
\end_layout

\begin_layout Enumerate
Control: if, else, for, while, do, ?:, and so forth
\end_layout

\begin_layout Enumerate
Scope concepts same/similar.
\end_layout

\begin_deeper
\begin_layout Standard
Squiggly braces demarcate the area where local variables can live.
 
\end_layout

\begin_layout Standard
As in C, a variable declared inside the braces, like i, only lives inside
 the braces
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int x;
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int i = 7;
\end_layout

\begin_layout Plain Layout

    cout << "i times x is" << x * i << endl;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

//Note x still exists after that, but i was local to the scope.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Pointers.
 Like C, C++ allows pointers.
 Syntax is same.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type * x;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 can be 
\begin_inset Quotes eld
\end_inset

integer
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

double
\begin_inset Quotes erd
\end_inset

, etc.
 This creates a location in memory we call x, and the value at that point
 is *x.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

&x
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Asks x what its memory location is.
 C++ uses the 
\begin_inset Quotes eld
\end_inset

&
\begin_inset Quotes erd
\end_inset

 operator much more often than we did in Objective-C.
 I'm trying to find out if that is simply a 
\begin_inset Quotes eld
\end_inset

novice
\begin_inset Quotes erd
\end_inset

 thing textbooks tead.
 
\end_layout

\begin_layout Standard
Use pointers, as in C
\end_layout

\begin_layout Standard
Use pointers also to refer to more elaborate data structures (including
 C++ classes, discussed below)
\end_layout

\end_deeper
\begin_layout Enumerate
Fixed size arrays created as in C
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int x[7];
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Recall this is 
\begin_inset Quotes eld
\end_inset

local
\begin_inset Quotes erd
\end_inset

 to a scope, it ceases to exist when C++ exists from scope.
 
\end_layout

\begin_layout Standard
To pass vector to another function, or to grab a 
\begin_inset Quotes eld
\end_inset

really large
\begin_inset Quotes erd
\end_inset

 amount of storage, need to dynamically allocate memory from the 
\begin_inset Quotes eld
\end_inset

heap
\begin_inset Quotes erd
\end_inset

 of RAM.
 
\end_layout

\begin_layout Standard
Allocation of pointers different in C++, we don't use 
\begin_inset Quotes eld
\end_inset

malloc
\begin_inset Quotes erd
\end_inset

, instead, use new.
\end_layout

\end_deeper
\begin_layout Section
Initially Noticed Differences from C
\end_layout

\begin_layout Enumerate
namespaces and include statements.
 The Superficial difference is the syntax.
\end_layout

\begin_deeper
\begin_layout Standard
C: #include <stdlib.h>
\end_layout

\begin_layout Standard
C++: #include <iostream>
\end_layout

\begin_layout Standard
Note: no 
\begin_inset Quotes eld
\end_inset

.h
\begin_inset Quotes erd
\end_inset

 in C++ when asking for header files from the 
\begin_inset Quotes eld
\end_inset

built in libraries
\begin_inset Quotes erd
\end_inset

 from the system.
\end_layout

\begin_layout Standard
Difference with header files in your code, though:
\end_layout

\begin_layout Standard
C: #include 
\begin_inset Quotes eld
\end_inset

header-in-my-code-folder.h
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Quotation marks signal 
\begin_inset Quotes eld
\end_inset

don't go look in the system for this header, look in my current folder
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
C++: #include <header-in-my-code-folder.h>
\end_layout

\begin_layout Standard
In C++, you'd only see the 
\begin_inset Quotes eld
\end_inset

.h
\begin_inset Quotes erd
\end_inset

 where it tells the compiler to look in your code for a header file.
\end_layout

\begin_layout Standard
Every installation of the g++ compiler will include the C++ Standard Library,
 which has many header files.
 It is is larger than the C standard library.
\end_layout

\begin_layout Standard
Many C libraries adapted for use within C++, such as stdlib.h is now accessed
 as:
\end_layout

\begin_layout Standard
C: #include <cstdlib>
\end_layout

\begin_layout Description
More
\begin_inset space ~
\end_inset

Substantial
\begin_inset space ~
\end_inset

Difference: simply including a header file does not make its functions 
\begin_inset Quotes eld
\end_inset

ready to use
\begin_inset Quotes erd
\end_inset

.
 Functions are inside namespaces.
 That is discussed below.
\end_layout

\end_deeper
\begin_layout Enumerate
Discourages printf, instead uses <iostream> functions
\end_layout

\begin_deeper
\begin_layout Standard
cout
\end_layout

\begin_layout Standard
endl
\end_layout

\begin_layout Standard
with << between pieces.
 Somewhat reminiscent of Perl string printing (IMHO).
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cout << "Some message to user" << x << y << endl;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Arguably, this is more convenient than printf.
 
\end_layout

\begin_layout Standard
To the novice user, it is the most prominent difference between C++ and
 C, and I think that's unfortunate because its not really important at all
 in the larger scheme of things.
 I wish I could just ignore that, and use printf or Rprintf() instead.
 I honestly see no benefit in having a new way to do the old thing.
 
\end_layout

\begin_layout Description
CAUTION cout and endl are in the namespace 
\begin_inset Quotes eld
\end_inset

std
\begin_inset Quotes erd
\end_inset

 and we can't use them unless we use that namespace (next topic)
\end_layout

\end_deeper
\begin_layout Enumerate
Functions and variables can be organized within 
\begin_inset Quotes eld
\end_inset

namespaces
\begin_inset Quotes erd
\end_inset

.
 The using keyword tells the compiler to look for otherwise unfound functions
 in a namespace.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
Quick R user note.
 In R, namespaces are now required for all packages and we can access functions
 using 
\begin_inset Quotes eld
\end_inset

::
\begin_inset Quotes erd
\end_inset

 notation.
\end_layout

\begin_layout Plain Layout
This is becoming more usual to R users, as more-and-more help pages in R
 use 
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

package::function()
\end_layout

\end_inset

That notation is more specific, it does not load a whole package when a
 function is required.
 Instead, we have often been taught to use
\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

library(package)
\end_layout

\begin_layout Plain Layout

function()
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's consider the function 
\begin_inset Quotes eld
\end_inset

cout
\begin_inset Quotes erd
\end_inset

 which writes to the screen.
 If you are 
\begin_inset Quotes eld
\end_inset

bare bones
\begin_inset Quotes erd
\end_inset

 namespace-respecting serious C++ programmer, your code explicitly refers
 to the namespace when cout is used.
 Like this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::cout << "some words print on the screen" << std::endl;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the olden days, say before 2005, it would be usual to simply import the
 WHOLE NAMESPACE like so, thus making all of its functions immediately available.
 Here, we tell it to look in a namespace 
\begin_inset Quotes eld
\end_inset

std
\begin_inset Quotes erd
\end_inset

, and if it finds it, it uses it.
 I use 
\begin_inset Quotes eld
\end_inset

endl
\begin_inset Quotes erd
\end_inset

 here because it gives new lines at the end.
 Otherwise, we have to insert 
\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset

 at the end.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//from http://www.cplusplus.com/doc/tutorial/namespaces
\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

int main () {
\end_layout

\begin_layout Plain Layout

  cout << "some message to the reader" << endl;
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
The previous makes ALL of the functions in the std namespace available:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using namespace std;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Eubank & Kupresanin say this is 
\begin_inset Quotes eld
\end_inset

overkill
\begin_inset Quotes erd
\end_inset

 because it gives access to the whole standard template library.
 In various C++ Web forums, I find authors going further, arguing it is
 generally 
\begin_inset Quotes eld
\end_inset

bad form
\begin_inset Quotes erd
\end_inset

 to do this with any namespaces, because it gives the author poor control
 over access to function names.
 Suppose there are several 
\begin_inset Quotes eld
\end_inset

using
\begin_inset Quotes erd
\end_inset

 statements and there are functions with the same name in each? All hell
 breaks loose.
 See 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-
a-bad-practice-in-c
\end_layout

\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Enumerate
A program can have several namespaces floating about, even within a user's
 code namespaces can be spawned, as shown here
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

namespace first
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int var = 5;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

namespace second
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  double var = 3.1416;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main () {
\end_layout

\begin_layout Plain Layout

  cout << first::var << endl;
\end_layout

\begin_layout Plain Layout

  cout << second::var << endl;
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
There is an in-between phase, where the 
\begin_inset Quotes eld
\end_inset

using
\begin_inset Quotes erd
\end_inset

 statement can bring in just one function from a namespace, not the whole
 thing.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

using namespace std::cout;
\end_layout

\begin_layout Plain Layout

using namespace std::endl;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

namespace first
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int x = 5;
\end_layout

\begin_layout Plain Layout

  int y = 10;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

namespace second
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  double x = 3.1416;
\end_layout

\begin_layout Plain Layout

  double y = 2.7183;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main () {
\end_layout

\begin_layout Plain Layout

  using namespace first;
\end_layout

\begin_layout Plain Layout

  cout << x << endl;
\end_layout

\begin_layout Plain Layout

  cout << y << endl;
\end_layout

\begin_layout Plain Layout

  cout << second::x << endl;
\end_layout

\begin_layout Plain Layout

  cout << second::y << endl;
\end_layout

\begin_layout Plain Layout

  return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
cout, endl, cin are in the namespace 
\begin_inset Quotes eld
\end_inset

std
\begin_inset Quotes erd
\end_inset

.
 The C++ standard library puts those functions in std.
\end_layout

\begin_layout Enumerate
Generally, we are advised to follow one of 2 coding standards.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
Don't import the namespace at all, but explicitly refer to the functions
 by their full names, like this:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::cout or std::endl
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example usage
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

std::cout << "some silly message" << std::endl;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That seems verbose to me, but it seems to be what the experts prefer for
 clarity.
\end_layout

\end_deeper
\begin_layout Enumerate
Use a more focused using statement
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

using std::cout; 
\end_layout

\begin_layout Plain Layout

using std::endl;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
tells compiler where to look for functions cout and endl.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Strings!: More convenient usage of character strings
\end_layout

\begin_deeper
\begin_layout Standard
#include <string>
\end_layout

\begin_layout Standard
Code allows new variable type
\end_layout

\begin_layout Standard
sting s = 
\begin_inset Quotes eld
\end_inset

whatever you want in parens
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
And s can be printed with cout.
\end_layout

\end_deeper
\begin_layout Section
Memory Management
\end_layout

\begin_layout Subsection
C++ allows pointers, manual allocation and freeing of memory
\end_layout

\begin_layout Subsection
But they don't want us to think of explicitly allocating arrays in the C
 style, anymore.
\end_layout

\begin_layout Standard
Instead, we should use a pre-designed Vector class that will handle that
 for us.
 The language is gravitating to a point where the allocation of memory is
 concealed and automatic.
\end_layout

\begin_layout Subsection
new and delete: replacements for malloc and and delete.
\end_layout

\begin_layout Standard
If you ever do need to explicitly allocate memory, here's how it can be
 done.
 new is an operators.
\end_layout

\begin_layout Enumerate
Use new to allocate memory for pointer variables.
 Don't use 
\begin_inset Quotes eld
\end_inset

malloc
\begin_inset Quotes erd
\end_inset

 to allocate dynamic memory.
\end_layout

\begin_deeper
\begin_layout Standard
Allocate a pointer to a single variable:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double *myX = new double;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For a single value, new works as well
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int *x = new int;
\end_layout

\begin_layout Plain Layout

//same as
\end_layout

\begin_layout Plain Layout

int *x;
\end_layout

\begin_layout Plain Layout

x = new int;
\end_layout

\begin_layout Plain Layout

//remember to delete x when you don't need it anymore!
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
When finished, remove it from memory.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

delete x;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Allocate storage for an array of n floating point numbers.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double *x = new double[n];
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The user can treat that like a pointer in C.
 x[0] grabs the first element.
 
\end_layout

\begin_layout Standard
When finished, remove it from memory.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

delete[] x;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Summary: No malloc, the allocation of arrays uses new instead.
\end_layout

\end_deeper
\begin_layout Enumerate
A caution I should have emphasized in C, but will make a big point about
 it now in C++!
\end_layout

\begin_deeper
\begin_layout Standard
Recall this example from the pointer discussion
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int *x;
\end_layout

\begin_layout Plain Layout

int i = 32;
\end_layout

\begin_layout Plain Layout

x = &i; //x equals the address of i
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Please note that this essentially lets *x 
\begin_inset Quotes eld
\end_inset

steal
\begin_inset Quotes erd
\end_inset

 the memory location created by allocating i.
 HOWEVER, when the process leaves that scope, i will cease to exist, and
 I'm not confident that x will point to anything reasonable.
 Thus, for our purposes, the most commonly illustrated usage of pointers
 is almost always wrong, or at least useless, since we DO need to pass informati
on between scopes.
\end_layout

\begin_layout Standard
Instead, we need to allocate memory for the pointer *x.
 
\end_layout

\begin_layout Standard
This declares a pointer, but 
\emph on
does not allocate permanent storage
\emph default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int *x;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It just means that, when storage is eventually created, we can refer to
 (the first position of it) by x.
 Arrays will automatically claim the memory for us.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

char * aMessage = "hello";
\end_layout

\begin_layout Plain Layout

int *a = new int(285); //285 dynamically allocated array
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Recall in C, a two dimensional array (a matrix) is handled in either of
 2 ways
\end_layout

\begin_deeper
\begin_layout Enumerate
Create a 1 dimensional array, and then get good at 
\begin_inset Quotes eld
\end_inset

stride
\begin_inset Quotes erd
\end_inset

 calculations to find the value that would be in row i, column j if it were
 a matrix.
 This is how FAST calculations are done in C programs.
\end_layout

\begin_deeper
\begin_layout Standard
C++ can do that, of course.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Create a 'star star' pointer, and use malloc to first allocate the initial
 positions of the columns, then add a for loop to allocate the storage for
 each column.
\end_layout

\begin_deeper
\begin_layout Standard
Recall in C we used this idiom to create a matrix 
\begin_inset Quotes eld
\end_inset

myDynamArray
\begin_inset Quotes erd
\end_inset

, which will have 10 rows and 5 columns.
 This was done with malloc:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//C 2 dimensional array
\end_layout

\begin_layout Plain Layout

int nRows = 10; int nCols = 5
\end_layout

\begin_layout Plain Layout

int i = 0, j = 0;
\end_layout

\begin_layout Plain Layout

double ** myDynamArray;
\end_layout

\begin_layout Plain Layout

myDynamArray = malloc(nRows * sizeof(double *));
\end_layout

\begin_layout Plain Layout

if (!myDynamArray) {printf("Memory alloc failed"); exit(0);}
\end_layout

\begin_layout Plain Layout

for (i = 0; i < nCols; i++)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

        myDynamArray[i] = malloc(nCols * sizeof(double));
\end_layout

\begin_layout Plain Layout

		if(!myDynamArray[i]) exit(0);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The C++ variant is a bit simpler looking.
 The new operator knows how much space to claim.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int i; nRows = 10; int nCols = 5;
\end_layout

\begin_layout Plain Layout

double **myDynamArray;
\end_layout

\begin_layout Plain Layout

myDynamArray = new int* [nRows];
\end_layout

\begin_layout Plain Layout

for (i = 0; i < nRows; i++)
\end_layout

\begin_layout Plain Layout

    { 
\end_layout

\begin_layout Plain Layout

        myDynamArray[i] = new double[nCols];
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
I hasten to remind you, however, that C++ users would not usually manually
 allocate memory in this way, they would instead find a pre-built class
 in some library and use that.
 
\end_layout

\end_deeper
\begin_layout Section
Standard Library
\end_layout

\begin_layout Standard
The Standard Template Library was an early attempt to provide a standard,
 large set of functions and data structures.
 Poor, incomplete, implementations of the STL caused me a lot of frustration
 when I started programming, I decided it was better to use C and then get
 best-of-breed addon libraries to fill the gaps that the STL had offered.
\end_layout

\begin_layout Standard
The current C++ Standard Library is a large set of things, similar to the
 STL.
 Until very recently, I had believed they were the same thing.
 The C++ Standard Library was made part of the ISO C++ standard, the STL
 is not.
 
\end_layout

\begin_layout Standard
See:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/C++_Standard_Library
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Highlights: Collections, 
\begin_inset Quotes eld
\end_inset

doubly-linked lists
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

set
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

map
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

vector
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
C's Standard Library 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://en.wikipedia.org/wiki/C_Standard_Library
\end_layout

\end_inset

 is also included.
 
\begin_inset Quotes eld
\end_inset

Each header from the C Standard Library is included in the C++ Standard
 Library under a different name, generated by removing the .h, and adding
 a 'c' at the start; for example, 'time.h' becomes 'ctime'.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Note: C's Standard Library is a large list of header files, only one of
 which is 
\begin_inset Quotes eld
\end_inset

stdlib.h
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Wish I had a couple of working examples of vector and map to insert here.
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section
Big new C++ feature: Classes
\end_layout

\begin_layout Enumerate
Think informally for a moment.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
We want to create separate 
\begin_inset Quotes eld
\end_inset

things
\begin_inset Quotes erd
\end_inset

 that have data and abilities.
 Call those things 
\begin_inset Quotes eld
\end_inset

optimizers
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

MCMC chains
\begin_inset Quotes erd
\end_inset

 or ...
\end_layout

\begin_deeper
\begin_layout Enumerate
Maybe an optimizer is a maximum likelihood estimation routine.
 All optimizers need to receive data, receive instructions.
 After that, they may go in separate directions searching for the answers.
\end_layout

\begin_layout Enumerate
In MCMC simulations, we often need several separate 
\begin_inset Quotes eld
\end_inset

chains
\begin_inset Quotes erd
\end_inset

.
 If we design the chain class well, then we can comfortable create several
 separate instances and let them grow their own separate chains.
\end_layout

\end_deeper
\begin_layout Enumerate
We design a common framework in a 
\begin_inset Quotes eld
\end_inset

class
\begin_inset Quotes erd
\end_inset

, and 
\end_layout

\begin_layout Enumerate
Then create instances from that class.
 We tell each separate instance what to do.
 They can 
\begin_inset Quotes eld
\end_inset

go their own ways
\begin_inset Quotes erd
\end_inset

 by adjusting their variables separately.
 
\end_layout

\begin_layout Standard
Benefits
\end_layout

\begin_layout Enumerate
We preserve our sanity by isolating calculations into separate places.
 There's less danger that we accidentally copy information from one object
 to another.
\end_layout

\begin_layout Enumerate
We economize on coding by placing some work into common, re-usable routines.
\end_layout

\begin_layout Enumerate
If we write good routines, we learn to trust them, and 
\begin_inset Quotes eld
\end_inset

abstract away
\begin_inset Quotes erd
\end_inset

 from the implementation details.
\end_layout

\begin_layout Enumerate
We more clearly conceptualize the differences among different types of things.
\end_layout

\end_deeper
\begin_layout Enumerate
In C, we can approximate object-oriented computing, but the syntax and design
 may be tedious.
 It requires a re-thinking of the way we use C, and many people then say
 
\begin_inset Quotes eld
\end_inset

why not just use C++ or Java instead?
\begin_inset Quotes erd
\end_inset

 The answer generally is, 
\begin_inset Quotes eld
\end_inset

C will outlast those other languages, so we will stick with that.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
In C, we usually think of a function as a thing with no 
\begin_inset Quotes eld
\end_inset

state
\begin_inset Quotes erd
\end_inset

.
 We put arguments in, results come out.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
We have to pass in ALL of the values that are required to make a calculation.
\end_layout

\end_deeper
\begin_layout Enumerate
Pass by reference is one way to create illusion of continuity, to 
\begin_inset Quotes eld
\end_inset

remember
\begin_inset Quotes erd
\end_inset

 by passing in a pointer variable.
 It allows a function to take note of the 
\begin_inset Quotes eld
\end_inset

current state
\begin_inset Quotes erd
\end_inset

 of the information, and then 
\begin_inset Quotes eld
\end_inset

revise variables.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
We have a pointer to some data, say a large struct containing all of our
 instance variables.
\end_layout

\begin_layout Enumerate
we pass that pointer to a function, 
\end_layout

\begin_layout Enumerate
the function dereferences the data to create new values, 
\end_layout

\begin_layout Enumerate
and the pointer variable's values themselves might be changed.
\end_layout

\begin_layout Enumerate
Example: Recall the random generator functions in L'Ecuyer's MCRG generator
 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.iro.umontreal.ca/~lecuyer/myftp/streams00/c2010
\end_layout

\end_inset

.
 That keeps the internal state of the generator in a pointer variable that
 is declared like so.
 (typedef is a C convenience for creating new variable types).
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef struct RngStream_InfoState * RngStream;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

struct RngStream_InfoState {
\end_layout

\begin_layout Plain Layout

   double Cg[6], Bg[6], Ig[6];
\end_layout

\begin_layout Plain Layout

   int Anti;
\end_layout

\begin_layout Plain Layout

   int IncPrec;
\end_layout

\begin_layout Plain Layout

   char *name;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
An instance of that type RngStream is created, and then it is passed to
 every function that does work to generate random numbers.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void RngStream_ResetStartStream (RngStream g);
\end_layout

\begin_layout Plain Layout

void RngStream_ResetNextSubstream (RngStream g);
\end_layout

\begin_layout Plain Layout

static double U01d (RngStream g);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Problem: this is a bit of a 
\begin_inset Quotes eld
\end_inset

mental stretch
\begin_inset Quotes erd
\end_inset

 and not convenient to manage lots of variables.
\end_layout

\end_deeper
\begin_layout Enumerate
BTW: Define 
\begin_inset Quotes eld
\end_inset

static
\begin_inset Quotes erd
\end_inset

.
 Static has many grossly different meanings, it can be horribly confusing:
 
\end_layout

\begin_deeper
\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

static function
\begin_inset Quotes erd
\end_inset

 is visible only inside the current file.
 The opposite of 
\begin_inset Quotes eld
\end_inset

extern
\begin_inset Quotes erd
\end_inset

, globally visible.
 
\end_layout

\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

static variable
\begin_inset Quotes erd
\end_inset

 inside a function is a value that is remembered between calls to the function.
 This can be used for continuity of calculations.
\end_layout

\begin_layout Standard
I think most everyone would agree that it is weird (mistaken) to use the
 word static for such different idea.
 And it has other uses as well when we come to classes.
\end_layout

\begin_layout Itemize
problem: that 
\begin_inset Quotes eld
\end_inset

static variables
\begin_inset Quotes erd
\end_inset

 values are not selectively remembered.
 It will be available to any caller of the function who comes along.
\end_layout

\end_deeper
\begin_layout Enumerate
Function names cannot be re-used, there is no 
\begin_inset Quotes eld
\end_inset

overloading
\begin_inset Quotes erd
\end_inset

 that allows one function name to be used with various argument types.
\end_layout

\begin_layout Enumerate
There is no obvious method to 
\begin_inset Quotes eld
\end_inset

subclass
\begin_inset Quotes erd
\end_inset

 in C.
 If we have a struct with 41 variables in it, and we then want to specialize
 it to a new kind of struct that has all of those variables plus 10 more,
 we should 
\begin_inset Quotes eld
\end_inset

copy and paste
\begin_inset Quotes erd
\end_inset

 the old code to make the new struct?
\end_layout

\end_deeper
\begin_layout Enumerate
A class
\end_layout

\begin_deeper
\begin_layout Enumerate
instance variables
\end_layout

\begin_layout Enumerate
constructor function.
 (Every class must have one, at least)
\end_layout

\begin_layout Enumerate
destructor function.
 
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

member functions
\begin_inset Quotes erd
\end_inset

 aka 
\begin_inset Quotes eld
\end_inset

methods
\begin_inset Quotes erd
\end_inset

 aka 
\begin_inset Quotes eld
\end_inset

method functions
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
See example-3-class.cc
\end_layout

\begin_layout Standard
example-4-class.cc
\end_layout

\begin_layout Standard
example-5-class.cc
\end_layout

\begin_layout Standard
example-6-class.cc
\end_layout

\end_deeper
\begin_layout Enumerate
Varying levels of information access.
\end_layout

\begin_deeper
\begin_layout Enumerate
public: can be accessed from main with 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

->
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate
private: can only be accessed from within the object's member functions.
\end_layout

\begin_layout Enumerate
protected: accessed from other objects from same class, derived classes.
\end_layout

\begin_layout Standard
Key idea: If some other type of object has a pointer to a MyClass object
 x, a public variable would allow 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x->var1; //to retrieve value of var1
\end_layout

\begin_layout Plain Layout

x->var1 = 19; //to set var1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Variables that are declared private or protected don't allow that, they
 will insist that the other object types interact with 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 in a more polite way.
\end_layout

\begin_layout Standard
MyClass should include 
\begin_inset Quotes eld
\end_inset

get
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

set
\begin_inset Quotes erd
\end_inset

 methods to allow values in and out.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void MyClass::setVar1(int x)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var1 = x;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int MyClass::getVar1()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    return var1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Clever C++ writers who like to use 
\begin_inset Quotes eld
\end_inset

overloaded functions
\begin_inset Quotes erd
\end_inset

 might use the same name for both of those, as in
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void MyClass::Var1(int x)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	var1 = x;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

int MyClass::Var1()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    return var1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
The things I called 
\begin_inset Quotes eld
\end_inset

class variables
\begin_inset Quotes erd
\end_inset

 (variables common among all instances of a class) can be created by the
 const static modifier.
 That's confusing, don't worry about it at the moment.
 You'd really have to study C++ before you 
\begin_inset Quotes eld
\end_inset

get it
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
this, this*, this->.
 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 a self-referential keyword that can be used inside methods, a pointer to
 the instance in which the C++ process is currently located.
 The most reasonable use of 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 is to pass 
\begin_inset Quotes eld
\end_inset

oneself
\begin_inset Quotes erd
\end_inset

 as a return value or a function argument.
 
\end_layout

\begin_deeper
\begin_layout Standard
In many contexts, it is quite reasonable to return 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

this *
\begin_inset Quotes erd
\end_inset

 after setting variables inside an object.
 Here's an example I revised from a forum post on (
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://publib.boulder.ibm.com/infocenter
\end_layout

\end_inset

) called 
\begin_inset Quotes eld
\end_inset

The this pointer (C++ only)
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//Suppose MyClass is defined, with instance variables: 
\end_layout

\begin_layout Plain Layout

//  int len;
\end_layout

\begin_layout Plain Layout

//  char *myName;
\end_layout

\begin_layout Plain Layout

// And member functions (aka methods) prototyped
\end_layout

\begin_layout Plain Layout

  int GetLen();
\end_layout

\begin_layout Plain Layout

  char * GetName();
\end_layout

\begin_layout Plain Layout

  MyClass& Set(char *);
\end_layout

\begin_layout Plain Layout

  MyClass& Cat(char *);
\end_layout

\begin_layout Plain Layout

  MyClass& Copy(MyClass&);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

char * MyClass::GetName
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  return myName;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

MyClass& MyClass::Set(char *pc) 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  len = strlen(pc);
\end_layout

\begin_layout Plain Layout

  myName = new char[len];
\end_layout

\begin_layout Plain Layout

  strcpy(myName, pc); //myName equal *pc
\end_layout

\begin_layout Plain Layout

  return *this;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

MyClass& MyClass::Cat(char *pc) 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  len += strlen(pc);
\end_layout

\begin_layout Plain Layout

  strcat(myName, pc); //makes myName longer by appending *pc
\end_layout

\begin_layout Plain Layout

  return *this;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

MyClass& MyClass::Copy(MyClass& x) 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Set(x.GetName()); //copy name from some other instance x
\end_layout

\begin_layout Plain Layout

  return *this;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
My guess would be that these functions would be more useful if they returned
 a pointer, rather than the 
\begin_inset Quotes eld
\end_inset

actual thing
\begin_inset Quotes erd
\end_inset

 this.
 In an agent-based simulation model, for example, it would be much more
 usual to write:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MyClass * MyClass::Copy(MyClass * x)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  Set(x->GetName()); 
\end_layout

\begin_layout Plain Layout

  return this;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Relationship between 
\begin_inset Quotes eld
\end_inset

structs
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

classes
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Enumerate
Review 
\begin_inset Quotes eld
\end_inset

struct
\begin_inset Quotes erd
\end_inset

 in C.
 Like C, a C++ struct combines different variables into one 
\begin_inset Quotes eld
\end_inset

thing
\begin_inset Quotes erd
\end_inset

.
 We access the struct data formally like so:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct whatever x;
\end_layout

\begin_layout Plain Layout

struct whatever * xptr;
\end_layout

\begin_layout Plain Layout

x.var1 = 7; //suppose var1 is a variable in the struct
\end_layout

\begin_layout Plain Layout

(*xptr).var1 = 7;  //same as -> next line
\end_layout

\begin_layout Plain Layout

xptr->var1 = 7;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
A C++ class is really just a struct--a lot of variables grouped together--along
 with 
\end_layout

\begin_deeper
\begin_layout Itemize
functions can be 
\begin_inset Quotes eld
\end_inset

members
\begin_inset Quotes erd
\end_inset

 of a struct.
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

member functions
\begin_inset Quotes erd
\end_inset

 of a struct have free access to the data in all of the variables of the
 class (which is really just a struct).
 A class is a super-powered struct in C++
\end_layout

\begin_layout Itemize
Inside the member functions, one can be explicit in asking for values of
 our own instance variables.
 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 is a keyword, a pointer to the 
\begin_inset Quotes eld
\end_inset

instance
\begin_inset Quotes erd
\end_inset

 in which I currently am positioned.
\end_layout

\begin_layout Itemize
Could access an instance variable by notation like
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

this->var1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
However, it is not necessary to do so.
 Inside a member function, the 
\begin_inset Quotes eld
\end_inset

this->
\begin_inset Quotes erd
\end_inset

 part is assumed.
 If you ask for a variable, the C++ runtime system looks in 
\begin_inset Quotes eld
\end_inset

this
\begin_inset Quotes erd
\end_inset

 for it.
\end_layout

\begin_layout Itemize
The only counter-examples I know of are complicated mistakes in which programmer
s have used the same name for instance variables and the arguments to member
 functions.
 Suppose var1 is an instance variable.
 Suppose a function also declares an argument var1.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MyClass::someFunction(int var1){
\end_layout

\begin_layout Plain Layout

   // Danger, Will Robinson.
 If you use "var1", do you expect
\end_layout

\begin_layout Plain Layout

   // the compiler to use the local automatic variable "var1" 
\end_layout

\begin_layout Plain Layout

   // or the instance variable var1?
\end_layout

\begin_layout Plain Layout

	this->var1 = 2 * var1; 
\end_layout

\begin_layout Plain Layout

   //multiply the argument by two, put the value into this->var1.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Objective-C forbids this kind of mistake at compile time, but C++ tolerates
 the ambiguity.
\end_layout

\begin_layout Itemize
Many C++ novices write 
\begin_inset Quotes eld
\end_inset

this->
\begin_inset Quotes erd
\end_inset

 compulsively in their member functions for 
\begin_inset Quotes eld
\end_inset

clarity,
\begin_inset Quotes erd
\end_inset

 but if you go ask in the Forums on StackOverflow or CPlusPlus.com, you see
 the experts uniformly say 
\begin_inset Quotes eld
\end_inset

stop doing that.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
Nevertheless, you will find plenty of 
\begin_inset Quotes eld
\end_inset

production quality
\begin_inset Quotes erd
\end_inset

 code that is littered with unnecessary 
\begin_inset Quotes eld
\end_inset

this->
\begin_inset Quotes erd
\end_inset

 usage.
 Example: Check the C++ source code for the R package RSiena.
 For example, from the Model.m constructor:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 Model::Model()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

        this->lconditional = false;
\end_layout

\begin_layout Plain Layout

        this->lneedChain = false;
\end_layout

\begin_layout Plain Layout

        this->lneedScores = false;
\end_layout

\begin_layout Plain Layout

        this->lneedDerivatives = false;
\end_layout

\begin_layout Plain Layout

        this->lparallelRun = false;
\end_layout

\begin_layout Plain Layout

        this->linsertDiagonalProbability = 0;
\end_layout

\begin_layout Plain Layout

        this->lcancelDiagonalProbability = 0;
\end_layout

\begin_layout Plain Layout

        this->lpermuteProbability = 0;
\end_layout

\begin_layout Plain Layout

        this->linsertPermuteProbability = 0;
\end_layout

\begin_layout Plain Layout

        this->ldeletePermuteProbability = 0;
\end_layout

\begin_layout Plain Layout

        this->linsertRandomMissingProbability = 0;
\end_layout

\begin_layout Plain Layout

        this->ldeleteRandomMissingProbability = 0;
\end_layout

\begin_layout Plain Layout

        this->lsimpleRates = 0;
\end_layout

\begin_layout Plain Layout

        this->lmodelType = NORMAL;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
In fact, a struct in C++ is simply a class with the member variables and
 functions 
\begin_inset Quotes eld
\end_inset

public
\begin_inset Quotes erd
\end_inset

 (Eubank and Kupresanin, p.
 60).
\end_layout

\end_deeper
\begin_layout Enumerate
Subclasses.
\end_layout

\begin_deeper
\begin_layout Standard
Here's where the power of the truly object-oriented language comes to the
 forefront.
 
\end_layout

\begin_layout Standard
If class Citizen exists, we might create classes Voter, Politician, Teacher,
 and FactoryWorker as variants of it.
\end_layout

\begin_layout Itemize
Idea: 
\begin_inset Quotes eld
\end_inset

Citizen
\begin_inset Quotes erd
\end_inset

, a collection of variables and methods.
\end_layout

\begin_layout Itemize
Other types are created from Citizen.
 Subclass 
\end_layout

\begin_deeper
\begin_layout Itemize
it 
\begin_inset Quotes eld
\end_inset

inherits
\begin_inset Quotes erd
\end_inset

 all of the variables and methods
\end_layout

\begin_layout Itemize
It can add MORE variables and methods
\end_layout

\begin_layout Itemize
It can OVERRIDE methods from C (to specialize them, for example).
\end_layout

\end_deeper
\begin_layout Standard
Benefits
\end_layout

\begin_layout Enumerate
conceptual clarity, model matches our theoretical idea of different object
 types
\end_layout

\begin_layout Enumerate
re-usable code.
 Write one really good set of methods for 
\begin_inset Quotes eld
\end_inset

Citizens
\begin_inset Quotes erd
\end_inset

, then put them to use in all the different object types.
\end_layout

\end_deeper
\end_body
\end_document
