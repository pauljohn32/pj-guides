#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{ragged2e}
\RaggedRight
\setlength{\parindent}{1 em}

\usepackage{color}
\definecolor{lightgray}{gray}{0.95}

\usepackage{textcomp}
\lstset{tabsize=2, breaklines=true, showstringspaces=F, language=C, upquote=true,backgroundcolor=\color{lightgray}}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman times
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_amsmath 1
\use_esint 0
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Author
Paul Johnson
\end_layout

\begin_layout Date
Feb 2011
\end_layout

\begin_layout Title
C Intro Notes
\end_layout

\begin_layout Section
Read some book, do some exercises
\end_layout

\begin_layout Standard
No matter how much you watch me 
\begin_inset Quotes eld
\end_inset

blather on and on,
\begin_inset Quotes erd
\end_inset

 you don't learn anything unless you do exercises, make mistakes, try again.
\end_layout

\begin_layout Section
Variables types
\end_layout

\begin_layout Standard
C is a 
\begin_inset Quotes eld
\end_inset

strongly typed
\begin_inset Quotes erd
\end_inset

 language.
 That means variables are declared by specific types.
\end_layout

\begin_layout Subsection
Integers:
\end_layout

\begin_layout Standard
The number of bits assigned for each type depends on the kind of CPU and
 the C library you are using, these are usually about right.
\end_layout

\begin_layout Standard
When integers were 16 bits, they could hold signed values in the range (-32,768
 to 32,767)
\end_layout

\begin_layout Standard
long int (64 bits)
\end_layout

\begin_layout Standard
unsigned int
\end_layout

\begin_layout Standard
unsigned long
\end_layout

\begin_layout Standard
On newer 64bit CPU, an int will default to be 64 bits.
\end_layout

\begin_layout Standard
From the GNU C Tutorial:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bits on 64 bit system
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
min
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-127
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
127
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unsigned char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
255
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-32,768
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32,768
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unsigned short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
65,535
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2,147,483,647
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,147,483,647
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32(win) or 64(linux mac)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\uparrow\downarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\uparrow\downarrow$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long long 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-9,223,372,036,854,775,807
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 9,223,372,036,854,775,807
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unsigned long long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18,446,744,073,709,551,615 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
May be difficult to write portable code because systems vary.
\end_layout

\begin_layout Standard
Check your system (
\begin_inset Quotes eld
\end_inset

/usr/include/limits.h
\begin_inset Quotes erd
\end_inset

) for integer ranges.
\end_layout

\begin_layout Subsection
Real-valued variables
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bits on 64 bit system
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
min
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
max
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 (~7 digit precision)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-3.4e-38 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.4e+38
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64 (~15 digit precision)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-4.940656458412e-324
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.79769313486231570e+308
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
same
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Tidbits:
\end_layout

\begin_layout Standard
e-38 means 
\begin_inset Formula $10^{-38}$
\end_inset

 or 
\begin_inset Formula $\frac{1}{10^{38}}$
\end_inset

; e+38 means 
\begin_inset Formula $10^{38}$
\end_inset


\end_layout

\begin_layout Standard
A 64 bit floating point number will usually use 
\end_layout

\begin_layout Itemize
11 bits for exponent
\end_layout

\begin_layout Itemize
53 bits for the coefficient (aka 
\begin_inset Quotes eld
\end_inset

significand
\begin_inset Quotes erd
\end_inset

, about 16 decimal digits)
\end_layout

\begin_layout Standard
A 32 bit floating point will allocate
\end_layout

\begin_layout Itemize
8 bits for exponent
\end_layout

\begin_layout Itemize
24 bits for significand, (about 7 decimal digits)
\end_layout

\begin_layout Standard
Single or Double precision is a matter of how many bits are used and maintained
 throughout a calculation
\end_layout

\begin_layout Standard
These are system dependent.
 AIX Unix has 128 bit long double.
\end_layout

\begin_layout Subsection
Characters
\end_layout

\begin_layout Standard
char
\end_layout

\begin_layout Standard
unsigned char
\end_layout

\begin_layout Standard
Comment: handling of 
\begin_inset Quotes eld
\end_inset

strings
\begin_inset Quotes erd
\end_inset

 in C is a pain and you don't really understand it until you practice.
\end_layout

\begin_layout Section
Scope is defined by squiggly braces
\end_layout

\begin_layout Subsection
Style
\end_layout

\begin_layout Standard
I tend to prefer the vertically parallel placement of squiggly braces, as
 in:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int myfunction (int y)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

     //the body of the function goes here
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Other people, especially publishers who want to save paper, may prefer:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int myfunction (int y){
\end_layout

\begin_layout Plain Layout

     //the body of the function goes here
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
People like me prefer if/then like this
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (x == 0)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

     //some consequence
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

 	//another consequence
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But some people, including the original designers of C, prefer this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x == 0) {
\end_layout

\begin_layout Plain Layout

     //some consequence
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

 	//another consequence
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As long as you try to be consistent, most people will not get too upset
 at you about your code.
 
\end_layout

\begin_layout Standard
I tend to write wasteful characters in order to prevent mistakes.
 For example, I don't mind writing
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x == 0) { y = 2; }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
even though the squiggly braces are not required.
 
\end_layout

\begin_layout Subsection
Scope
\end_layout

\begin_layout Standard
Scope has to do with
\end_layout

\begin_layout Itemize
where a piece of code 
\begin_inset Quotes eld
\end_inset

looks for
\begin_inset Quotes erd
\end_inset

 values.
\end_layout

\begin_layout Itemize
the impact of changes in a variable.
\end_layout

\begin_layout Standard
Ordinarily, the effects of changes are confined to the 
\begin_inset Quotes eld
\end_inset

braces
\begin_inset Quotes erd
\end_inset

 in which the variable is defined.
\end_layout

\begin_layout Standard
A variable exists only within its 
\begin_inset Quotes eld
\end_inset

scope.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{ Scope A
\end_layout

\begin_layout Plain Layout

    {   Scope B
\end_layout

\begin_layout Plain Layout

        { Scope C }
\end_layout

\begin_layout Plain Layout

        { Scope D }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Variables and functions declared in A are available to B, C, and D.
\end_layout

\begin_layout Standard
Variables declared in C are not available in D or B or A.
\end_layout

\begin_layout Subsection
Declarations allowed only in the 
\begin_inset Quotes eld
\end_inset

Top of Blocks
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Even though some compilers may not insist on this, some will.
 So keep it simple, follow the tradition.
 
\end_layout

\begin_layout Standard
All variables have to be defined at the top of blocks.
 You an do
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int x;
\end_layout

\begin_layout Plain Layout

  int y;
\end_layout

\begin_layout Plain Layout

  double z;
\end_layout

\begin_layout Plain Layout

  x = 2 * x;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But you must NOT do some calculations, and then declare another variable
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  int x;
\end_layout

\begin_layout Plain Layout

  int y;
\end_layout

\begin_layout Plain Layout

  x = 2 * x;
\end_layout

\begin_layout Plain Layout

  double z;
\end_layout

\begin_layout Plain Layout

  z = x * y;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Take the easy route, unless there is good reason go to the other way.
\end_layout

\begin_layout Standard
Declare your integers as 
\begin_inset Quotes eld
\end_inset

int.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Standard
Declare your real-valued variables as 
\begin_inset Quotes eld
\end_inset

double
\begin_inset Quotes erd
\end_inset

.
 If you run out of memory, buy more.
\end_layout

\begin_layout Subsection
Cast one variable as another.
\end_layout

\begin_layout Standard
In C, you might need to do some math.
 And it gets ugly, especially if you divide 2 integers.
 It does not give you back a floating point number, as you expect.
 It rounds off.
 So you can force division to act as if 2 integers are floats:
\end_layout

\begin_layout LyX-Code
int x=3;
\end_layout

\begin_layout LyX-Code
int y=3;
\end_layout

\begin_layout LyX-Code
double z;
\end_layout

\begin_layout LyX-Code
z = (double)x/(double)y;
\end_layout

\begin_layout Standard
When you use the 
\begin_inset Quotes eld
\end_inset

cast
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

promote
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

demote
\begin_inset Quotes erd
\end_inset

 a variable, you tell the compiler to do its best to transfer the thing
 from one type to another.
 A cast like this
\end_layout

\begin_layout LyX-Code
x = (int)z;
\end_layout

\begin_layout Standard
can, on most systems, do a 
\begin_inset Quotes eld
\end_inset

rounding down
\begin_inset Quotes erd
\end_inset

 of z to the integer value.
 Its not always predictable, and there are other functions for rounding.
\end_layout

\begin_layout Section
Printing to the screen
\end_layout

\begin_layout Subsection
fprintf is it!
\end_layout

\begin_layout Standard
I've tried to shift from using
\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

printf("hello, this is a message to the screen");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to
\end_layout

\begin_layout LyX-Code
\begin_inset listings
lstparams "extendedchars=true"
inline false
status open

\begin_layout Plain Layout

fprintf(stderr,"hello, this is a message to the screen");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I do that because 
\begin_inset Quotes eld
\end_inset

stderr
\begin_inset Quotes erd
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

standard error
\begin_inset Quotes erd
\end_inset

 stream of messages that go to the screen and this style encourages the
 program to send the message right away.
\end_layout

\begin_layout Subsection
Access variables from printf or fprintf
\end_layout

\begin_layout Standard
C uses a Fortran-like method of declaring 
\begin_inset Quotes eld
\end_inset

place holders
\begin_inset Quotes erd
\end_inset

 for material to be printed out.
\end_layout

\begin_layout Standard
This is a 'counting game
\begin_inset Quotes erd
\end_inset

.
 Match the number of 
\begin_inset Quotes eld
\end_inset

%
\begin_inset Quotes erd
\end_inset

 to the number of variables.
 
\end_layout

\begin_layout Standard
Syntax is
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,extendedchars=true,language=C,showstringspaces=false"
inline false
status open

\begin_layout Plain Layout

printf("something with %d or %f or more", oneIntegerVariable, oneFloatingVariabl
e);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
C allows lots of formats, but I mostly remember using
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
printf abbreviation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%d or %i
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
floating point (6 decimals)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
floating (restrict to 3 digits before decimal, 2 after)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
%3.2f
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset listings
inline false
status open

\begin_layout LyX-Code

int x = 7;
\end_layout

\begin_layout LyX-Code

double y = 7.7;
\end_layout

\begin_layout LyX-Code

double z = (double)2/3;
\end_layout

\begin_layout LyX-Code

fprintf(stderr,"the value of an int is %d 
\backslash
n", x);
\end_layout

\begin_layout LyX-Code

/* note %d means "an integer" follows to fill that in */
\end_layout

\begin_layout LyX-Code

fprintf(stderr,"the value of a double is %f 
\backslash
n", y);
\end_layout

\begin_layout LyX-Code

fprintf(stderr,"x=%d,y=%f, z=%f, z=%3.4, 
\backslash
n", x, y, z, z);
\end_layout

\end_inset


\end_layout

\begin_layout Section
Control structures
\end_layout

\begin_layout Subsection
Special use of = and & and |
\end_layout

\begin_layout Standard
Please beware that the & is a dangerous thing because it is used in 
\begin_inset Quotes eld
\end_inset

bitwise
\begin_inset Quotes erd
\end_inset

 computing.
 You might use it thinking it means 
\begin_inset Quotes eld
\end_inset

and
\begin_inset Quotes erd
\end_inset

.
 It is a mistake.
 In C, 
\end_layout

\begin_layout Standard

\series bold
\size larger
== means 
\begin_inset Quotes eld
\end_inset

equal to
\begin_inset Quotes erd
\end_inset

 in a conditional statement
\end_layout

\begin_layout Standard

\series bold
\size larger
&& means 
\begin_inset Quotes eld
\end_inset

AND
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard

\series bold
\size larger
|| means 
\begin_inset Quotes eld
\end_inset

OR
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
conditional statements
\end_layout

\begin_layout LyX-Code
int x, y, z;
\end_layout

\begin_layout LyX-Code
if ( x == 1 )
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   y = 2;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
else
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   y = 5;   
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
if ((x == 1) && (y == 2))
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   z = 10;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Section*
Note: Squiggly braces not required on one liners
\end_layout

\begin_layout Standard
The following are equivalent:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x == 1) { z = 5; }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
And
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x == 1) z = 5;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In other words, when there is ONLY ONE consequence, the braces are not required.
\end_layout

\begin_layout Standard
BUT, guess how many times I've made this mistake: 
\end_layout

\begin_layout Standard
Suppose we start with: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x == 1) z = 5;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We want to add an additional option, and forget to add the squiggly braces:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x == 1) z = 5;
\end_layout

\begin_layout Plain Layout

             z2 = 10;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But we really need:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x == 1) 
\end_layout

\begin_layout Plain Layout

  { 
\end_layout

\begin_layout Plain Layout

	z = 5;
\end_layout

\begin_layout Plain Layout

	z2 = 10;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\end_inset


\end_layout

\begin_layout Standard
is instead this mistake:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (x == 1) z = 5;
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
for loops
\end_layout

\begin_layout Standard
This is the predominant method of iterating through some problem.
\end_layout

\begin_layout LyX-Code
int i;
\end_layout

\begin_layout LyX-Code
for (i = 0; i<N; i++)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   fprintf(stderr, 
\begin_inset Quotes eld
\end_inset

this is step %d
\begin_inset Quotes erd
\end_inset

,i);
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection
while loops
\end_layout

\begin_layout Standard
Sometimes while loops come in handy, but for me it is rare.
\end_layout

\begin_layout Section
Struct
\end_layout

\begin_layout Standard
The term 
\begin_inset Quotes eld
\end_inset

struct
\begin_inset Quotes erd
\end_inset

 in C refers to a collection of variables of different types.
 In Pascal, this is called a 
\begin_inset Quotes eld
\end_inset

record.
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Subsection
Define a structure
\end_layout

\begin_layout Standard
Collect up several variables or arrays and group them together.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct student{
\end_layout

\begin_layout Plain Layout

   int id;
\end_layout

\begin_layout Plain Layout

   char *first_name;
\end_layout

\begin_layout Plain Layout

   char *last_name;
\end_layout

\begin_layout Plain Layout

   double age;
\end_layout

\begin_layout Plain Layout

   double gpa;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That declares a structure of variables.
 I think of that as a variable of type 
\begin_inset Quotes eld
\end_inset

struct student
\begin_inset Quotes erd
\end_inset

.
 So where I would put 
\begin_inset Quotes eld
\end_inset

int
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

double
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

double *
\begin_inset Quotes erd
\end_inset

 in a function, I now put 
\begin_inset Quotes eld
\end_inset

struct student
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

struct student *
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
A variable of type 
\begin_inset Quotes eld
\end_inset

struct student
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

struct student *
\begin_inset Quotes erd
\end_inset

 can be either the input OR the output from a function.
 
\end_layout

\begin_layout Subsection
Create one struct variable.
 
\end_layout

\begin_layout Standard
Now we have to create one student.
 Since struct student is already defined, we could simply do this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct student myStudent1;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I should mention, when the struct is defined, we can add names of structs
 to be created on the end of the syntax
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct student{
\end_layout

\begin_layout Plain Layout

   int id;
\end_layout

\begin_layout Plain Layout

   char *first_name;
\end_layout

\begin_layout Plain Layout

   char *last_name;
\end_layout

\begin_layout Plain Layout

   double age;
\end_layout

\begin_layout Plain Layout

   double gpa;
\end_layout

\begin_layout Plain Layout

} myStudent1;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A struct declared in this way is 
\begin_inset Quotes eld
\end_inset

automatically
\begin_inset Quotes erd
\end_inset

 allocated memory from the stack.
 Like all variables, it lives within a scope.
 To pass structs among function, we need to make them pointer variables,
 that have memory allocated from the heap.
\end_layout

\begin_layout Subsection
Accessing values from a struct
\end_layout

\begin_layout Subsubsection
The 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 operator.
 
\end_layout

\begin_layout Standard
A period joins together the name of the struct with the variable inside
 that is to be accessed.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

myStudent1.first_name = "Willie";
\end_layout

\begin_layout Plain Layout

myStudent1.age = 32;
\end_layout

\begin_layout Plain Layout

myStudent1.gpa = 3.1223;
\end_layout

\begin_layout Plain Layout

printf("This student's age is %d and the gpa is %f
\backslash
n", myStudent1.age, myStudent1.gpa);
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The 
\begin_inset Quotes eld
\end_inset

->
\begin_inset Quotes erd
\end_inset

 operator.
\end_layout

\begin_layout Standard
Suppose we have a pointer to a struct.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct student * myStudent2;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To 
\begin_inset Quotes eld
\end_inset

get
\begin_inset Quotes erd
\end_inset

 values for that student, we'd first have to de-reference the pointer, meaning
 
\begin_inset Quotes eld
\end_inset

go to the memory location * myStudent2.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

*myStudent2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and then to get one particular variable out of that dereferenced value,
 we have to parenthesize that and add period and a variable name:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(*myStudent2).age;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That notation is a bit cumbersome, so a special symbol was introduced to
 refer to de-referencing a struct pointer and then taking a variable from
 it.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

myStudent2->age;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is required that myStudent2 must be a pointer to a struct and age, of
 course, must be one of the variables in the struct.
 This makes our student younger.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void makeYounger(struct student* st)
\end_layout

\begin_layout Plain Layout

   {
\end_layout

\begin_layout Plain Layout

	  st->age = 0.75 * st->age;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\end_inset


\end_layout

\begin_layout Section
Arrays
\end_layout

\begin_layout Standard
An array is a homogeneous collection of variable values.
 Any of the fundamental types can be elements in an array.
 
\end_layout

\begin_layout LyX-Code
int blop[10]; /*this is an array called 
\begin_inset Quotes eld
\end_inset

blop
\begin_inset Quotes erd
\end_inset

 */
\end_layout

\begin_layout Itemize
This array is 
\begin_inset Quotes eld
\end_inset

statically
\begin_inset Quotes erd
\end_inset

 declared.
 
\end_layout

\begin_layout Itemize
It exists within the scope where it is created.
\end_layout

\begin_layout Itemize
We can read elements like so:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

blop[5]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
We can set values like so:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

blop[5]=32;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The elements in an array are indexed from 
\begin_inset Formula $0$
\end_inset

 to 
\begin_inset Formula $N-1$
\end_inset

.
 So the array is 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true"
inline false
status open

\begin_layout Plain Layout

blop={blop[0],blop[1],blop[2],blop[3],blop[4],blop[5], blop[6],blop[7],blop[8],b
lop[9]}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
You can initialize at time of declaration like so:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int blop[10]={1,2,3,4,5,6,7,8,9,10}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Otherwise necessary to individually assign all elements, like this
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int i;
\end_layout

\begin_layout Plain Layout

for (i=0, i<10; i++)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   blop[i] = i+1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Caution: It is NOT ALLOWED to simply initialize blop=0; Must loop over each
 spot.
\end_layout

\begin_layout Description
Caution: In C, counting begins with 0 and goes up to N-1.
\end_layout

\begin_layout Description
Caution: C does not do 
\begin_inset Quotes eld
\end_inset

bounds checking
\begin_inset Quotes erd
\end_inset

 automatically.
 Reference to 'blop[10]' is bad.
 Very bad.
 If your array has 10 items, and you ask for the 11th one, you get back
 nonsense.
 Your program won't necessarily crash, but it might, depending if the system
 can 
\begin_inset Quotes eld
\end_inset

make sense
\begin_inset Quotes erd
\end_inset

 of what it finds.
\end_layout

\begin_layout Section
Include, import, header files.
\end_layout

\begin_layout Section*
Terminology
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

interface
\begin_inset Quotes erd
\end_inset

 function names, how functions are accessed from 
\begin_inset Quotes eld
\end_inset

outside
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Description
interface is stuff in *.h files in C.
\end_layout

\end_deeper
\begin_layout Description
\begin_inset Quotes eld
\end_inset

implementation
\begin_inset Quotes erd
\end_inset

 The actual code that does the work.
 
\end_layout

\begin_deeper
\begin_layout Description
implementation is self contained: the only user interaction it requires
 is in the input variables.
\end_layout

\begin_layout Description
implementation should be well done, clear, and forgettable (it 'Just works')!
 
\end_layout

\begin_layout Standard
User should not need to dig into implementation code in order to use the
 function.
 
\end_layout

\end_deeper
\begin_layout Standard
You can write a big, monstrous program all in one file if you want to.
 But it gets tough to manage and confusing.
 So you declare a file in 2 parts, the 
\end_layout

\begin_layout Enumerate
header file, such as 
\begin_inset Quotes eld
\end_inset

MyFile.h
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Enumerate
implementation file, such as 
\begin_inset Quotes eld
\end_inset

MyFile.c
\begin_inset Quotes erd
\end_inset

 in c, 
\begin_inset Quotes eld
\end_inset

MyFile.cc
\begin_inset Quotes erd
\end_inset

 in C++, or 
\begin_inset Quotes eld
\end_inset

MyFile.m
\begin_inset Quotes erd
\end_inset

 in Objective C.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

include
\begin_inset Quotes erd
\end_inset

 statement at the top of a file gives that file access to commands that
 are defined in the included file.
 
\end_layout

\begin_layout Standard
Most C programs have 
\end_layout

\begin_layout LyX-Code
#include <stdlib.h>
\end_layout

\begin_layout Standard
That's where printf and other basic features are defined.
\end_layout

\begin_layout Standard
Look in /usr/include in your file system to see many *.h files.
\end_layout

\begin_layout Section
C allows 
\begin_inset Quotes eld
\end_inset

macros
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section*
CPP
\end_layout

\begin_layout Standard
CPP: the 
\begin_inset Quotes eld
\end_inset

pre-processor
\begin_inset Quotes erd
\end_inset

.
 Before a program is compiled, gcc runs it through the C pre-processor.
 One duty of the pre-processor is to inspect for certain 
\begin_inset Quotes eld
\end_inset

magic words
\begin_inset Quotes erd
\end_inset

 and then replace them with something else.
 
\end_layout

\begin_layout Standard
The C library has a number of pre-defined variables, and if you put their
 magic words in your program, the pre-processor comes along and replaces
 those words with their values.
 Check 
\begin_inset Quotes eld
\end_inset

/usr/include/limits.h
\begin_inset Quotes erd
\end_inset

, for example, where this line is found
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# define LONG_MAX 9223372036854775807L
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a result, if your code has the letters 
\begin_inset Quotes eld
\end_inset

LONG_MAX
\begin_inset Quotes erd
\end_inset

 in it, the pre-processor will replace those letters with the number from
 limits.h.
 As a result, one can do
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

x = LONG_MAX
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and CPP will figure out what is legal for your system.
 
\end_layout

\begin_layout Standard
A major benefit of this is improved code protability, because the system's
 configuration is likely to know what LONG_MAX is, but the programmer might
 not.
\end_layout

\begin_layout Section*
User Defined Macros
\end_layout

\begin_layout Standard
User customized macros.
 This ability is a convenience that is loved by some and hated vigorously
 by others.
 It was hated so vigorously by the designers of Java that they eliminated
 the user's ability to create macros at all.
\end_layout

\begin_layout Standard
The custom is that macros should be CAPITALIZED.
 This helps to prevent accidental usage of macro variables.
 Remember, macros work because C has a 
\begin_inset Quotes eld
\end_inset

preprocessor
\begin_inset Quotes erd
\end_inset

 that goes over your code and replaces symbols with the desired values.
 This is a very powerful and dangerous thing.
\end_layout

\begin_layout Standard
Example.
 Suppose you have a special value of 
\begin_inset Formula $\pi$
\end_inset

.
 Put this at the top of your code MY_PI:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# define MY_PI 3.3 /* my pie is rounded */
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In your code, you could use that value wherever you wanted.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if ( x > MY_PI)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  fprintf(stderr,x is greater than %f 
\backslash
n, MY_PI);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The pre-processor would replace the letters M_PI with 3.3.
\end_layout

\begin_layout Section*
Use Macros While Debugging Code
\end_layout

\begin_layout Standard
Some programmers develop new procedures in the middle of if statements.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if ( 0 ){
\end_layout

\begin_layout Plain Layout

   // a lot of C code that we were using before
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

   C code we are creating in our new version
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The if/else approach works, but it does waste some program time, because
 the if/else has to be computed whenever the program runs.
 
\end_layout

\begin_layout Standard
What if you could just make the first part irrelevant to the program from
 the start, as if it were deleted?
\end_layout

\begin_layout Standard
Macros are often used to mark of big sections of code that are ignored or
 included.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#define DEBUG 1
\end_layout

\begin_layout Plain Layout

/* that set the value to 1, which the system sees as true*/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then, later in the code, if you want something include for debugging, wrap
 the code in a 
\begin_inset Quotes eld
\end_inset

macro sandwich,
\begin_inset Quotes erd
\end_inset

 with 
\begin_inset Quotes eld
\end_inset

#ifdef DEBUG
\begin_inset Quotes erd
\end_inset

 at the beginning and 
\begin_inset Quotes eld
\end_inset

#endif
\begin_inset Quotes erd
\end_inset

 at the end.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#ifdef DEBUG
\end_layout

\begin_layout Plain Layout

 C code that you want to run if DEBUG is 1 
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or, if you want something to run when DEBUG is NOT true, do this
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#ifndef DEBUG
\end_layout

\begin_layout Plain Layout

x = 92;
\end_layout

\begin_layout Plain Layout

y = exp(z);
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why would anybody want to do this? 
\end_layout

\begin_layout Standard
1.
 Testing new sub-routines
\end_layout

\begin_layout Standard
2.
 Avoid unnecessary calculations.
 If you don't need some elements at all, then you make the pre-processor
 leave them out altogether.
\end_layout

\begin_layout Section
Typedef.
\end_layout

\begin_layout Subsection
Typedef: Create new variable types in your code
\end_layout

\begin_layout Standard
Suppose you find yourself creating the same kind of array variable over
 and over.
 
\end_layout

\begin_layout Standard
int x[3];
\end_layout

\begin_layout Standard
int y[3];
\end_layout

\begin_layout Standard
int z[3];
\end_layout

\begin_layout Standard
One simplification is to define a new variable type that is a 3-valued integer
 array.
\end_layout

\begin_layout Standard
typedef int myarray [3];
\end_layout

\begin_layout Standard
After that, the new variable type 
\begin_inset Quotes eld
\end_inset

myarray
\begin_inset Quotes erd
\end_inset

 is created, so a declaration like this
\end_layout

\begin_layout Standard
myarray x;
\end_layout

\begin_layout Standard
has the effect of creating a 3 valued array, and you can proceed to use
 it in the ordinary way:
\end_layout

\begin_layout Standard
x[0]=7; x[1]=2, x[2]=7;
\end_layout

\begin_layout Standard
Typedef can be used to simplify declarations of many variable types, including
 pointers and structs.
\end_layout

\begin_layout Subsection
Typedef: Almost like a macro.
\end_layout

\begin_layout Standard
Suppose you want to call all of your integers as type 
\begin_inset Quotes eld
\end_inset

CHARLIE
\begin_inset Quotes erd
\end_inset

.
 You could use a macro
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#define CHARLIE int
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then when you want to declare an int, then instead of 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int x=99;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then type this:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

CHARLIE x;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some programmers will do that because they want to leave the possibility
 for customizing a variable type.
 Suppose we might want a 
\begin_inset Quotes eld
\end_inset

short int
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

int
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

long int
\begin_inset Quotes erd
\end_inset

, but we don't know which.
 So a macro will be a convenient way to say 
\begin_inset Quotes eld
\end_inset

I'll set that later
\begin_inset Quotes erd
\end_inset

.
 Later we could come back and change one line to convert all of the 
\begin_inset Quotes eld
\end_inset

ints
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

longs
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#define CHARLIE long int
\end_layout

\end_inset


\end_layout

\begin_layout Section
functions in C
\end_layout

\begin_layout Subsection
single-valued return
\end_layout

\begin_layout Standard
In C, a function can take input arguments and give back a single value.
\end_layout

\begin_layout LyX-Code
double myFunction ( int x, double y)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   /* x y are 
\begin_inset Quotes eld
\end_inset

input variables
\begin_inset Quotes erd
\end_inset

 */
\end_layout

\begin_layout LyX-Code
   double z = (double)x * y;
\end_layout

\begin_layout LyX-Code
   return z;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Please note, inside a function you can declare more 
\begin_inset Quotes eld
\end_inset

local variables
\begin_inset Quotes erd
\end_inset

 but you must not use the same names as the inputs
\end_layout

\begin_layout Standard
If you don't want a return value from a function, you can give it the type
 
\begin_inset Quotes eld
\end_inset

void
\begin_inset Quotes erd
\end_inset

 and leave out the return;
\end_layout

\begin_layout Subsection
Yes, I mean you can't return an array
\end_layout

\begin_layout Subsection
But you can return a 
\begin_inset Quotes eld
\end_inset

pointer
\begin_inset Quotes erd
\end_inset

 to an array.
\end_layout

\begin_layout Section
What's a pointer?
\end_layout

\begin_layout Standard
This is where all hell breaks loose.
\end_layout

\begin_layout Subsection
Static versus Dynamic memory
\end_layout

\begin_layout Standard
Programs can automatically allocate memory, but only up to a point.
 If you need an array that holds 
\begin_inset Quotes eld
\end_inset

too much stuff,
\begin_inset Quotes erd
\end_inset

 then you can't count on the program to handle it.
 SO a declaration like this 
\end_layout

\begin_layout LyX-Code
int x[1000000000000000000];
\end_layout

\begin_layout Standard
will be a non-starter.
 
\end_layout

\begin_layout Standard
If an array that big is even possible, you have to use dynamically allocated
 memory.
 To do that, first declare a 
\begin_inset Quotes eld
\end_inset

pointer
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout LyX-Code
int *x;
\end_layout

\begin_layout Standard
and then you use a command like 
\begin_inset Quotes eld
\end_inset

malloc
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

alloc
\begin_inset Quotes erd
\end_inset

 to claim a block of memory from the computer.
\end_layout

\begin_layout Standard
Many programming frameworks will supply their own version of malloc.
 But, if you are in plain old C, you would use this to grab the memory:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int *x; //suppose you want 10 items in a dynamically allocated array
\end_layout

\begin_layout Plain Layout

int N = 10;
\end_layout

\begin_layout Plain Layout

x = (int *)malloc ( N * sizeof(int)); //ask for memory
\end_layout

\begin_layout Plain Layout

if ( !x ) exit(0); //check, see you got it.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
A pointer is the 
\begin_inset Quotes eld
\end_inset

first position
\begin_inset Quotes erd
\end_inset

 of a piece of memory.
\end_layout

\begin_layout LyX-Code
int *x;
\end_layout

\begin_layout LyX-Code
int i;
\end_layout

\begin_layout LyX-Code
//allocate this for N items, however you want
\end_layout

\begin_layout LyX-Code
x = (int *)malloc (N * sizeof(int)); 
\end_layout

\begin_layout LyX-Code
if ( !x ) exit(0);
\end_layout

\begin_layout LyX-Code
x[0] = 3; puts the value of 3 into the first position.
\end_layout

\begin_layout LyX-Code
for (i = 0; i< N; i++)
\end_layout

\begin_layout LyX-Code
{
\end_layout

\begin_layout LyX-Code
   x[i] = i*2;
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
Values in an array can be accessed 
\begin_inset Quotes eld
\end_inset

as if
\begin_inset Quotes erd
\end_inset

 they were values in a pointer.
 
\end_layout

\begin_layout Subsubsection*
Terminology Alert
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

reference a pointer
\begin_inset Quotes erd
\end_inset

 put a value into memory 
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

dereference a pointer
\begin_inset Quotes erd
\end_inset

 get a value out of memory from a pointer
\end_layout

\begin_layout Subsection
There is other stuff worth knowing about pointers
\end_layout

\begin_layout Standard
People can live with pointers, and use pointers, and then later start to
 understand pointers.
\end_layout

\begin_layout Standard
Many programming libraries (like Swarm for agent-based simulation) will
 supply idioms for working with pointers so it almost seems as if they are
 nothing special.
 
\end_layout

\begin_layout Standard
But in plain C, there are a few very important things to know.
 
\end_layout

\begin_layout Subsection*
Functions: access by value protects the input data
\end_layout

\begin_layout Standard
Consider
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int myFunction (double x);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 is an input value into the function, myFunction cannot change it.
 
\end_layout

\begin_layout Standard
The only way to damage the input data is to be explicit about it:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

y = myFunction (y);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whatever you had before, you don't have it now.
\end_layout

\begin_layout Subsection*
Functions: access by reference does not protect the input data
\end_layout

\begin_layout Standard
Consider
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(void) myFunction (double * x){
\end_layout

\begin_layout Plain Layout

*x = 7.99;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What is the effect of the next command?
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double *y;
\end_layout

\begin_layout Plain Layout

myFunction(y);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The variable y now points at a section of memory that holds the value 
\begin_inset Quotes eld
\end_inset

7.99
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Subsection*
Functions: safer pass by reference
\end_layout

\begin_layout Standard
Use the const to protect the input from change, but put the output into
 a new pointer variable.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(void) myFunction (const double * x, double * y){
\end_layout

\begin_layout Plain Layout

*y = 7.99;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The value pointed to at location x is unchanged, but the output value resides
 at the location pointed to by y.
\end_layout

\begin_layout Subsection*
All Scientific & Statistical Computing Libraries Use 
\begin_inset Quotes eld
\end_inset

pass by reference
\begin_inset Quotes erd
\end_inset

 extensively.
\end_layout

\begin_layout Standard
Consider a declaration in the GNU Scientific Library (GSL).
 This is from :gsl_sf_exp.h
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 /* Provide an exp() function with GSL semantics,  
\end_layout

\begin_layout Plain Layout

  * i.e.
 with proper error checking, etc.
  * 
\end_layout

\begin_layout Plain Layout

  * exceptions: GSL_EOVRFLW, GSL_EUNDRFLW  */ 
\end_layout

\begin_layout Plain Layout

int gsl_sf_exp_e(const double x, gsl_sf_result * result);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This one takes a floating point input and it sets the result into memory
 at a pointer location 
\begin_inset Quotes eld
\end_inset

result
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Section
Containers
\end_layout

\begin_layout Standard
The idea of a container is from object-oriented programming, it is not native
 to C programming.
 But because we can use structs to make C more object-oriented, it should
 not come as a surprise that there are C methods to group together like
 kinds of objects into collections.
 I think the 2 kinds of collections that are most easily understandable
 are 
\begin_inset Quotes eld
\end_inset

linked lists
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

maps.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Linked lists and maps are not built into C, but they are available from
 many libraries.
 They can be found in programming libraries like 
\begin_inset Quotes eld
\end_inset

glib
\begin_inset Quotes erd
\end_inset

 (which is distributed with 
\begin_inset Quotes eld
\end_inset

gtk
\begin_inset Quotes erd
\end_inset

, the 
\begin_inset Quotes eld
\end_inset

Gimp tool kit
\begin_inset Quotes erd
\end_inset

).
 They are also available in GSL.
\end_layout

\begin_layout Standard
C++ provides linked lists in a family of containers in its Standard Library.
 So does Java.
 This inclusion of a wider class of containers in the base language libraries
 is one of the major reasons that some people prefer Java or C++ to C.
\end_layout

\begin_layout Subsection
Brief Sketch of Idea
\end_layout

\begin_layout Standard
Suppose you have a bunch of structs, say, one for each student.
 You might like to throw them in a container, and when something has to
 be done to all students, we would have an 
\begin_inset Quotes eld
\end_inset

iterator
\begin_inset Quotes erd
\end_inset

 thing that would take the first student, then do something, then take the
 next, and so forth.
 
\end_layout

\begin_layout Subsubsection
linked list.
 
\end_layout

\begin_layout Standard
Create a struct, that has 3 elements.
 First, of course, it has the valuable data for a student.
 Usually, this will be a pointer to a struct.
 That part is simple, it is just data.
 
\end_layout

\begin_layout Standard
The next two elements are the links, the information that connects this
 particular student's data to the other students in the collection.
 Each element in the list only 
\begin_inset Quotes eld
\end_inset

knows
\begin_inset Quotes erd
\end_inset

 about 2 other elements, the one before and the one after it.
 So the second and third elements in this struct are pointers to list members
 that are before or after this one struct.
\end_layout

\begin_layout Standard
We usually build a list by creating items and then adding them to the list.
 A list is a 
\begin_inset Quotes eld
\end_inset

grab bag
\begin_inset Quotes erd
\end_inset

, it is disorganized.
 The order in which elements are inserted is not supposed to be important
 in this case, things are just added at the end.
\end_layout

\begin_layout Standard
We usually interact with a linked list by 
\end_layout

\begin_layout Itemize
asking the list to give us the first (or last) element in the list
\end_layout

\begin_layout Itemize
doing our work on that one element's data
\end_layout

\begin_layout Itemize
asking that one element which element from the list would be next (or is
 before).
 And we continue.
\end_layout

\begin_layout Standard
An 
\begin_inset Quotes eld
\end_inset

iterator
\begin_inset Quotes erd
\end_inset

 is a tool we use to manage this navigation through the list.
 Iterators are generally able to respond to commands like 
\begin_inset Quotes eld
\end_inset

getFirst
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

getNext
\begin_inset Quotes erd
\end_inset

 and so forth.
\end_layout

\begin_layout Subsubsection
Map
\end_layout

\begin_layout Standard
The disadvantage of a linked list is that we cannot easily find a particular
 element in the collection.
 If you tell me, 
\begin_inset Quotes eld
\end_inset

I want data for student 'willie'
\begin_inset Quotes erd
\end_inset

, then I have to ask, one-by-one, each element in the linked list if its
 name is willie.
 The linked list offers no shortcut.
 If the list includes only 5 or 10 elements, then that may be sufficient.
 But if the linked list has 1000s of elements, then this will be very slow.
\end_layout

\begin_layout Standard
Suppose instead of simply throwing elements into a list, we insert named
 elements into a collection.
 So instead of just 
\begin_inset Quotes eld
\end_inset

addLast
\begin_inset Quotes erd
\end_inset

 to put something into a collection, we have a notion of adding a student
 and giveing it an external identifier, the syntax would be something like
 
\begin_inset Quotes eld
\end_inset

add(student, mapID).
\begin_inset Quotes erd
\end_inset

 The map container is doing the work of storing the objects and their unique
 identifiers, so that we can ask for particular objects when we want them.
\end_layout

\begin_layout Standard
Iterating through the elements of a Map is not usually as fast as iterating
 through a linked list.
 Putting elements into a Map is not as fast as adding them to the end of
 a linked list.
 However, retrieval of specific named elements is faster in a Map than a
 linked list.
\end_layout

\begin_layout Subsubsection
Iterator
\end_layout

\begin_layout Standard
The power in the use of collections is in the Iterator, a way we have of
 processing list elements one by one.
 I've often thought of the iterator as a tiny spotlight that floats above
 a collection and highlights elements one at a time.
\end_layout

\end_body
\end_document
