#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass beamer
\begin_preamble
\usepackage{dcolumn}
\usepackage{booktabs}

\usepackage{Sweavel}


% use 'handout' to produce handouts
%\documentclass[handout]{beamer}
\usepackage{wasysym}
\usepackage{pgfpages}
\newcommand{\vn}[1]{\mbox{{\it #1}}}\newcommand{\vb}{\vspace{\baselineskip}}\newcommand{\vh}{\vspace{.5\baselineskip}}\newcommand{\vf}{\vspace{\fill}}\newcommand{\splus}{\textsf{S-PLUS}}\newcommand{\R}{\textsf{R}}


%\setbeamercovered{transparent}
% or whatever (possibly just delete it)

% In document Latex options:
\fvset{listparameters={\setlength{\topsep}{0em}}}
\def\Sweavesize{\tiny} 
\def\Rcolor{\color{black}} 
\def\Rbackground{\color[gray]{0.95}}

\usepackage{graphicx}
\usepackage{listings}
\lstset{tabsize=2,breaklines=true,style=Rstyle,basicstyle=\ttfamily\tiny}
\usetheme{Antibes}
% or ...

%\setbeamercovered{transparent}
% or whatever (possibly just delete it)

%\mode<presentation>
%{
 % \usetheme{KU}
 % \usecolortheme{dolphin} %dark blues
%}


%%not for article, but for presentation
\mode<presentation>
%%\newcommand\makebeamertitle{\frame{\maketitle}}


%%only for presentation
\mode<presentation>
\setbeamertemplate{frametitle continuation}[from second]
\renewcommand\insertcontinuationtext{...}


\expandafter\def\expandafter\insertshorttitle\expandafter{%
 \insertshorttitle\hfill\insertframenumber\,/\,\inserttotalframenumber}
\end_preamble
\use_default_options false
\begin_modules
sweave
logicalmkup
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Format 7
InsetLayout CharStyle:Rinput
LyxType               charstyle
LabelString           Rinput
LatexType             command
LatexName             Rinput
Font
Family             Typewriter
EndFont
Preamble
\newcommand*{\Rinput}[1]{{\ttfamily #1}}
EndPreamble
End
InsetLayout CharStyle:Rfunction
LyxType               charstyle
LabelString           Rfunction
LatexType             command
LatexName             Rfunction
Font
Family             Typewriter
EndFont
Preamble
\newcommand*{\Rfunction}[1]{{\ttfamily #1}}
EndPreamble
End
InsetLayout CharStyle:Routput
LyxType               charstyle
LabelString           Routput
LatexType             command
LatexName             Routput
Font
Family             Typewriter
EndFont
Preamble
\newcommand*{\Routput}[1]{{\ttfamily #1}}
EndPreamble
End
\end_local_layout
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\branch R
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch effects
\selected 1
\filename_suffix 0
\color #ffffff
\end_branch
\branch termplot
\selected 1
\filename_suffix 0
\color #ffffff
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Branch R
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=F>>=
\end_layout

\begin_layout Plain Layout

dir.create("plots", showWarnings=F)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{prefix.string=plots/t,split=T,ae=F,height=4,width=6}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, echo=F>>=
\end_layout

\begin_layout Plain Layout

options(device = pdf)
\end_layout

\begin_layout Plain Layout

options(width=160, prompt=" ", continue="  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE) 
\end_layout

\begin_layout Plain Layout

#set.seed(12345)
\end_layout

\begin_layout Plain Layout

op <- par() 
\end_layout

\begin_layout Plain Layout

pjmar <- c(5.1, 5.1, 1.5, 2.1) 
\end_layout

\begin_layout Plain Layout

#pjmar <- par("mar")
\end_layout

\begin_layout Plain Layout

options(SweaveHooks=list(fig=function() par(mar=pjmar, ps=12)))
\end_layout

\begin_layout Plain Layout

pdf.options(onefile=F,family="Times",pointsize=12)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang canadian
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang canadian
If you wish to uncover everything in a step-wise fashion, uncomment the
 following command:
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang canadian
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
beamerdefaultoverlayspecification{<+->}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang canadian
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang canadian
Following is the macro for bold math.
 In math mode, creates a new macros 
\backslash
vb for upright bold in math mode
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\vb}[1]{\bm{\mathrm{#1}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSection[]{
\end_layout

\begin_layout Plain Layout

  
\backslash
frame<beamer>{ 
\end_layout

\begin_layout Plain Layout

    
\backslash
frametitle{Outline}   
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection,currentsubsection] 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Title
R Classes 
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Descriptive
\end_layout

\end_inset


\end_layout

\begin_layout Author
Paul E.
 Johnson
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\begin_layout Institute
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
1
\end_layout

\end_inset

Department of Political Science
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset

Center for Research Methods and Data Analysis, University of Kansas
\begin_inset Argument 1
status open

\begin_layout Plain Layout
K.U.
\end_layout

\end_inset


\end_layout

\begin_layout Date
2015
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
2011
\end_layout

\end_inset


\end_layout

\begin_layout PlainFrame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Outline
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This is a LaTeX version of the presentation R_classes-1, which was written
 with R markdown in 2015
\end_layout

\begin_layout Itemize
I concluded I hate writing with that, converted over to LaTeX.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Recipe}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Here's the basic R analysis recipe
\end_layout

\begin_deeper
\begin_layout Itemize
estimator function creates data structures (not presentable to humans) and
 
\end_layout

\begin_layout Itemize
declares that thing to be of a certain class.
\end_layout

\end_deeper
\begin_layout Itemize
programmer also provides summary() and other methods that beautify the presentat
ion and re-structure the data.
\end_layout

\begin_deeper
\begin_layout Itemize
display methods: print, plot, etc
\end_layout

\end_deeper
\begin_layout Itemize
Behind the scene, information is passed around in a relatively ugly format
\end_layout

\begin_layout Itemize
We show the users a prettied-up version.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
The R Mantra
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Same sequence plays itself out across the R source code}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Estimate a model
\end_layout

\begin_layout Enumerate
Estimate more models
\end_layout

\begin_layout Enumerate
Apply follow-up procedures and plotters
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Same sequence plays itself out across the R source code}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
User runs a model-making function, such as lm()
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<echo=T>>=
\end_layout

\begin_layout Plain Layout

dat <- data.frame(y = rnorm(100), x1 = rnorm(100), x2 = rnorm(100))
\end_layout

\begin_layout Plain Layout

m1 <- lm(y ~ x1 + x2, data = dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
R supplies follow-up procedures.We run 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

summary(m1)
\end_layout

\begin_layout Plain Layout

anova(m1)
\end_layout

\begin_layout Plain Layout

plot(m1)
\end_layout

\begin_layout Plain Layout

termplot(m1)
\end_layout

\begin_layout Plain Layout

nobs(m1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
summary() is a 
\begin_inset Quotes eld
\end_inset

generic function
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
work is actually provided by summary.lm, a 
\series bold
method
\series default
.
 
\end_layout

\begin_layout Description
method: a class-specific function that implements work promised by a generic
 function
\end_layout

\begin_layout Itemize
If there's no class-specific method, then the work is given to a 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 method, such as summary.default()
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Want examples I can explain?}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Look in rockchalk 
\end_layout

\begin_layout Itemize
meanCenter, residualCenter,standardize.
 
\end_layout

\begin_deeper
\begin_layout Itemize
all are functions that receive regressions, re-assign their classes.
\end_layout

\end_deeper
\begin_layout Itemize
pctable
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Generic Function}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Definition: a function that receives a request and sends it to another function
\end_layout

\begin_layout Standard
A generic function like 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

summary(m1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
calls a method (an R function) named summary.lm
\end_layout

\begin_layout Itemize
"Dispatching" in S3.
 R runtime looks at the class of the FIRST input argument, and then sends
 the work to the other function.
\end_layout

\begin_layout Itemize
It's possible to create separate methods, as we see below 
\end_layout

\begin_deeper
\begin_layout Itemize
A formula method 
\begin_inset Quotes eld
\end_inset

pctable.formula()
\begin_inset Quotes erd
\end_inset

, so users can run pctable(y ~ x, data = dat)
\end_layout

\begin_layout Itemize
A character method 
\begin_inset Quotes eld
\end_inset

pctable.character()
\begin_inset Quotes erd
\end_inset

, so users can run pctable("y", "x", data = dat)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{List out Methods}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
R has tools to see methods that are available
\end_layout

\begin_layout Itemize
list available print methods
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

methods(print)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
list methods that can apply to objects of class "lm"
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

methods(class = "lm")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{S3/S4}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
S4 is a more elaborate object structure, more formal.
\end_layout

\begin_layout Itemize
Many packages still written in S3.
\end_layout

\begin_layout Itemize
Different accessor symbols for lists.
 
\end_layout

\begin_layout Itemize
S3 allows abbreviation dat$x for dat[ , "x"] 
\end_layout

\begin_layout Itemize
S4 uses @ as accessor.
\end_layout

\begin_layout Itemize
Difficult to write functions that can receive either S3 or S4, check for
 type, and then do the right thing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
pctable
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Table example}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We Needed presentable cross tabulations
\end_layout

\begin_layout Itemize
R table output too sparse
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F>>=
\end_layout

\begin_layout Plain Layout

options(width = 70)
\end_layout

\begin_layout Plain Layout

dat <- data.frame(
\end_layout

\begin_layout Plain Layout

xf1 = sample(c("Alberquerque", "Denver", "Santa Fe"), 150, replace = TRUE),
\end_layout

\begin_layout Plain Layout

yf1 = sample(letters[1:5], 150, replace = TRUE),
\end_layout

\begin_layout Plain Layout

y = rnorm(150))
\end_layout

\begin_layout Plain Layout

dat$yf1[c(33, 44, 100)] <- NA
\end_layout

\begin_layout Plain Layout

dat$xf1[c(11, 90, 120, 144)] <- NA
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=T>>=
\end_layout

\begin_layout Plain Layout

table(dat$yf1, dat$xf1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{What's wrong with that?}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
no margins
\end_layout

\begin_layout Itemize
no percents
\end_layout

\begin_layout Itemize
Can add those things with follow-up functions (prop.table, addmargins), but
 that's tedious.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Clunky to use, too}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Compared to other R functions, there is no beauty in the table function.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

table(dat$yf1, dat$xf1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I wanted something that looked more like a regression model
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

myTable(yf1 ~ xf1, data = dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Table-maker more like regression and plot}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I wanted to replace this style
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

table(dat$yf1, dat$xf1, dnn = list("My Great Row Var", "My Column Var"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
with this:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

myTable(yf1 ~ xf1, data = dat, rvlab = "My Great Row Var", cvlab = "My Column
 Var")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{tabl was the first try}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=T>>=
\end_layout

\begin_layout Plain Layout

## A new table making function
\end_layout

\begin_layout Plain Layout

##' Creates a cross tabulation with counts and column percents
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' ..
 content for 
\backslash
details{} ..
\end_layout

\begin_layout Plain Layout

##' @param x row variable name
\end_layout

\begin_layout Plain Layout

##' @param y col variable name
\end_layout

\begin_layout Plain Layout

##' @param data dataframe
\end_layout

\begin_layout Plain Layout

##' @param xlab Optional: row variable label
\end_layout

\begin_layout Plain Layout

##' @param ylab Optional: col variable label
\end_layout

\begin_layout Plain Layout

##' @param exclude Default NULL, all values displayed (incl missing)
\end_layout

\begin_layout Plain Layout

##' @param rounded Default FALSE, rounds to 10's for privacy purposes
\end_layout

\begin_layout Plain Layout

##' @return list of tables
\end_layout

\begin_layout Plain Layout

##' @author pauljohn@@ku.edu
\end_layout

\begin_layout Plain Layout

tabl <- function(x, y, data = parent.frame(), xlab = NULL, ylab = NULL, exclude
 = NULL, rounded = FALSE){
\end_layout

\begin_layout Plain Layout

    xlabel <- if (!missing(x)) deparse(substitute(x))
\end_layout

\begin_layout Plain Layout

    ylabel <- if (!missing(y)) deparse(substitute(y))
\end_layout

\begin_layout Plain Layout

    xlab <- if (is.null(xlab)) xlabel else xlab
\end_layout

\begin_layout Plain Layout

    ylab <- if (is.null(ylab)) ylabel else ylab
\end_layout

\begin_layout Plain Layout

    t1 <- table(data[ ,xlabel], data[ , ylabel], dnn = c(xlab, ylab), exclude
 = exclude)
\end_layout

\begin_layout Plain Layout

    rownames(t1)[is.na(rownames(t1))] <- "NA" ## symbol to letters
\end_layout

\begin_layout Plain Layout

    colnames(t1)[is.na(colnames(t1))] <- "NA"
\end_layout

\begin_layout Plain Layout

    if (rounded) t1 <- round(t1, -1)
\end_layout

\begin_layout Plain Layout

    t2 <- addmargins(t1, c(1,2))
\end_layout

\begin_layout Plain Layout

    t1p <- round(100*prop.table(t1, 2), 1)
\end_layout

\begin_layout Plain Layout

    t3 <- t2
\end_layout

\begin_layout Plain Layout

    for(j in rownames(t1p)){
\end_layout

\begin_layout Plain Layout

        for(k in colnames(t1p)){
\end_layout

\begin_layout Plain Layout

            t3[j, k] <- paste0(t2[j, k], "(", t1p[j, k], "%)")
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

print(t3)
\end_layout

\begin_layout Plain Layout

invisible(list(t2, t1p, t3, call = match.call() ))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tabl2>>=
\end_layout

\begin_layout Plain Layout

tabl(yf1, xf1, data = dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Step in a good direction
\end_layout

\begin_deeper
\begin_layout Itemize
data frame argument!
\end_layout

\begin_layout Itemize
Some argument magic here.
 Allows users to name symbols as input variables.
 Did not require quoted variable names "xf1".
 That gets sacrificed in the final version.
\end_layout

\end_deeper
\begin_layout Itemize
Defaults to show missing values
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{pctable() in the rockchalk package 1.8.90+}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use a formula interface
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

require(rockchalk)
\end_layout

\begin_layout Plain Layout

t1 <- pctable(yf1 ~ xf1, dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
creates a data structure in t1 that can be used to spit out various summaries
\end_layout

\begin_layout Itemize
Or even use it the old way
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

pctable(dat$yf1, dat$xf1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
It turns out it is not allowed/practical to have this interface, 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

pctable(yf1, xf1, dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
However, I found a way to implement this
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

pctable("yf1", "xf1", dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which is almost as good.
\end_layout

\begin_layout Standard
- Found ways to export to LaTeX and Word compatible formats, so students
 can make tables that don't offend the reader
\end_layout

\begin_layout Standard
- Keep options open to include counts and percents in same table
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{ pctable is pronounced "presentable"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(rockchalk)
\end_layout

\begin_layout Plain Layout

pctable(yf1 ~ xf1, data = dat, rvlab = "A Thing I Predict", cvlab = "A Mighty
 Predictor!")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{In my opinion, nobody should ever want row percents, but if you
 do, I will still be your friend:}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

pctable(yf1 ~ xf1, data = dat, rowpct = TRUE, colpct = FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Make a high quality table}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=FALSE>>=
\end_layout

\begin_layout Plain Layout

require(tables)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<pctable10, echo=F, include=T>>=
\end_layout

\begin_layout Plain Layout

t1 <- pctable(yf1 ~ xf1, data = dat, exclude = NULL)
\end_layout

\begin_layout Plain Layout

tsum <- summary(t1)
\end_layout

\begin_layout Plain Layout

tsumt <- as.tabular(tsum)
\end_layout

\begin_layout Plain Layout

## Escape percent signs for LaTeX
\end_layout

\begin_layout Plain Layout

tsumt <- apply(tsumt, 1:2, function(x) {gsub("%", "
\backslash

\backslash

\backslash

\backslash
%", x) })
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Latex output}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%latex.default(tsumt, file = "")%
\end_layout

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{llllll}
\end_layout

\begin_layout Plain Layout


\backslash
hline
\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
multicolumn{1}{c}{}&
\backslash
multicolumn{1}{c}{}&
\backslash
multicolumn{1}{c}{}&
\backslash
multicolumn{1}{c}{}&
\backslash
multicolumn{1}{c}{}&
\backslash
multicolumn{1}{c}{}
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

&xf1&&&&
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

yf1&Alberquerque&Denver&Santa Fe&NA&Sum
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

a&8(19
\backslash
%)&12(22.6
\backslash
%)&13(25.5
\backslash
%)&0(0
\backslash
%)&33
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

b&9(21.4
\backslash
%)&7(13.2
\backslash
%)&11(21.6
\backslash
%)&3(75
\backslash
%)&30
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

c&8(19
\backslash
%)&11(20.8
\backslash
%)&7(13.7
\backslash
%)&1(25
\backslash
%)&27
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

d&11(26.2
\backslash
%)&17(32.1
\backslash
%)&9(17.6
\backslash
%)&0(0
\backslash
%)&37
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

e&5(11.9
\backslash
%)&5(9.4
\backslash
%)&10(19.6
\backslash
%)&0(0
\backslash
%)&20
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

NA&1(2.4
\backslash
%)&1(1.9
\backslash
%)&1(2
\backslash
%)&0(0
\backslash
%)&3
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

Sum&42&53&51&4&150
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{What's required to make this work? pctable}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
From rockchalk source code, this is it!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

pctable <- function(rv, ...) {
\end_layout

\begin_layout Plain Layout

    UseMethod("pctable") 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

NULL 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pctable.default <- 
\end_layout

\begin_layout Plain Layout

function(rv, cv,rvlab = NULL, cvlab = NULL, colpct = TRUE, 
\end_layout

\begin_layout Plain Layout

rowpct = FALSE, rounded = FALSE, ...)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    rvlabel <- if (!missing(rv)) deparse(substitute(rv))
\end_layout

\begin_layout Plain Layout

    cvlabel <- if (!missing(cv)) deparse(substitute(cv))
\end_layout

\begin_layout Plain Layout

    rvlab <- if (is.null(rvlab)) rvlabel else rvlab
\end_layout

\begin_layout Plain Layout

    cvlab <- if (is.null(cvlab)) cvlabel else cvlab
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    dots <- list(...)
\end_layout

\begin_layout Plain Layout

    dotnames <- names(dots)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    tableargs <- list(rv, cv, dnn = c(rvlab, cvlab))
\end_layout

\begin_layout Plain Layout

    newargs <- modifyList(tableargs, dots, keep.null = TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    t1 <- do.call("table", newargs)
\end_layout

\begin_layout Plain Layout

    rownames(t1)[is.na(rownames(t1))] <- "NA" ## symbol to letters
\end_layout

\begin_layout Plain Layout

    colnames(t1)[is.na(colnames(t1))] <- "NA"
\end_layout

\begin_layout Plain Layout

    if (rounded) t1 <- round(t1, -1)
\end_layout

\begin_layout Plain Layout

    t2 <- addmargins(t1, c(1,2))
\end_layout

\begin_layout Plain Layout

    t1colpct <- round(100*prop.table(t1, 2), 1)
\end_layout

\begin_layout Plain Layout

    t1rowpct <- round(100*prop.table(t1, 1), 1)
\end_layout

\begin_layout Plain Layout

    t1colpct <- apply(t1colpct, c(1,2), function(x) gsub("NaN", "", x))
\end_layout

\begin_layout Plain Layout

    t1rowpct <- apply(t1rowpct, c(1,2), function(x) gsub("NaN", "", x))
\end_layout

\begin_layout Plain Layout

    res <- list("count" = t2, "colpct" = t1colpct, "rowpct" = t1rowpct,
\end_layout

\begin_layout Plain Layout

                call = match.call())
\end_layout

\begin_layout Plain Layout

    class(res) <- "pctable"
\end_layout

\begin_layout Plain Layout

    print.pctable(res, colpct = colpct, rowpct = rowpct)
\end_layout

\begin_layout Plain Layout

    invisible(res)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

NULL
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##' Creates a cross tabulation with counts and column percents
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' The formula method is the recommended method for users.
 Run
\end_layout

\begin_layout Plain Layout

##' 
\backslash
code{pctable(myrow ~ mycol, data = dat)}.
 In an earlier version,
\end_layout

\begin_layout Plain Layout

##' I gave different advice, so please adjust your usage.
\end_layout

\begin_layout Plain Layout

##' 
\end_layout

\begin_layout Plain Layout

##' @param formula A two sided formula.
  
\end_layout

\begin_layout Plain Layout

##' @param data A data frame.
\end_layout

\begin_layout Plain Layout

##' @examples
\end_layout

\begin_layout Plain Layout

##'   [omitted]
\end_layout

\begin_layout Plain Layout

##' @rdname pctable
\end_layout

\begin_layout Plain Layout

##' @method pctable formula
\end_layout

\begin_layout Plain Layout

##' @export
\end_layout

\begin_layout Plain Layout

pctable.formula <- 
\end_layout

\begin_layout Plain Layout

function(formula, data = NULL,  rvlab = NULL, cvlab = NULL, colpct = TRUE,
 rowpct = FALSE, rounded = FALSE, ...)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (missing(formula) || (length(formula) != 3L))
\end_layout

\begin_layout Plain Layout

        stop("pctable requires a two sided formula")
\end_layout

\begin_layout Plain Layout

    dots <- list(...)
\end_layout

\begin_layout Plain Layout

    dotnames <- names(dots)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    mt <- terms(formula, data = data)
\end_layout

\begin_layout Plain Layout

    if (attr(mt, "response") == 0L) stop("response variable is required")
\end_layout

\begin_layout Plain Layout

    mf <- match.call(expand.dots = TRUE)
\end_layout

\begin_layout Plain Layout

    mfnames <- c("formula", "data", "subset", "xlev", "na.action", "drop.unused.lev
els")
\end_layout

\begin_layout Plain Layout

    keepers <- match(mfnames, names(mf), 0L)
\end_layout

\begin_layout Plain Layout

    mf <- mf[c(1L, keepers)]
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

    if (!"na.action" %in% dotnames) mf$na.action <- na.pass
\end_layout

\begin_layout Plain Layout

    mf[[1L]] <- quote(stats::model.frame)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ## remove used arguments from dots, otherwise errors happen
\end_layout

\begin_layout Plain Layout

    ## when unexpected arguments pass through.
 Don't know why
\end_layout

\begin_layout Plain Layout

    for (i in c("subset", "xlev", "na.action", "drop.unused.levels")) dots[[i]]
 <- NULL
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

    mf <- eval(mf, parent.frame())
\end_layout

\begin_layout Plain Layout

    mfnames <- names(mf)
\end_layout

\begin_layout Plain Layout

    response <- attr(attr(mf, "terms"), "response")
\end_layout

\begin_layout Plain Layout

    ## response is column 1
\end_layout

\begin_layout Plain Layout

    rvname <- mfnames[response]
\end_layout

\begin_layout Plain Layout

    cvname <- mfnames[-response][1] ##just take 2?
\end_layout

\begin_layout Plain Layout

    rvlab <- if (missing(rvlab)) rvname else rvlab
\end_layout

\begin_layout Plain Layout

    cvlab <- if (missing(cvlab)) cvname else cvlab
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    arglist <- list(rv = mf[[rvname]], cv = mf[[cvname]],
\end_layout

\begin_layout Plain Layout

                    rvlab = rvlab, cvlab = cvlab,
\end_layout

\begin_layout Plain Layout

                    colpct = colpct, rowpct = rowpct,
\end_layout

\begin_layout Plain Layout

                    rounded = rounded)
\end_layout

\begin_layout Plain Layout

    arglist <- modifyList(arglist, dots, keep.null = TRUE)
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    res <- do.call(pctable.default, arglist)
\end_layout

\begin_layout Plain Layout

    invisible(res)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

NULL
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##' Method for variable names as character strings 
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' The character method exists only for variety.
  It accepts
\end_layout

\begin_layout Plain Layout

##' character strings rather than a formula to define the columns that
\end_layout

\begin_layout Plain Layout

##' should be plotted.
  The method used most often for most users should
\end_layout

\begin_layout Plain Layout

##' be the formula method.
\end_layout

\begin_layout Plain Layout

##' 
\end_layout

\begin_layout Plain Layout

##' When using character arguments, the row variable rv rowvar must be
\end_layout

\begin_layout Plain Layout

##' a quoted string if the user intends the method pctable.character
\end_layout

\begin_layout Plain Layout

##' to be dispatched.
 The column variable cv may be a string or just a
\end_layout

\begin_layout Plain Layout

##' variable name (which this method will coerce to a string).
\end_layout

\begin_layout Plain Layout

##' @examples omitted
\end_layout

\begin_layout Plain Layout

##' @rdname pctable
\end_layout

\begin_layout Plain Layout

##' @method pctable character
\end_layout

\begin_layout Plain Layout

##' @export
\end_layout

\begin_layout Plain Layout

pctable.character <- 
\end_layout

\begin_layout Plain Layout

function(rv, cv, data = NULL, rvlab = NULL,
\end_layout

\begin_layout Plain Layout

    cvlab = NULL, colpct = TRUE, rowpct = FALSE,
\end_layout

\begin_layout Plain Layout

    rounded = FALSE, ...)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (missing(data) || !is.data.frame(data)) stop("pctable requires a data
 frame")
\end_layout

\begin_layout Plain Layout

    cv <- as.character(substitute(cv))[1L]
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    rvlab <- if (missing(rvlab)) rv else rvlab
\end_layout

\begin_layout Plain Layout

    cvlab <- if (missing(cvlab)) cv else cvlab
\end_layout

\begin_layout Plain Layout

    res <- pctable.formula(formula(paste(rv, " ~ ", cv)), data = data,
\end_layout

\begin_layout Plain Layout

                           rvlab = rvlab, cvlab = cvlab, colpct = colpct,
\end_layout

\begin_layout Plain Layout

                           rowpct = rowpct, rounded = rounded, ...)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

    invisible(res)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

NULL
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##' Extract presentation from a pctable object
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' Creates a column and/or row percent display of a pctable
\end_layout

\begin_layout Plain Layout

##' result
\end_layout

\begin_layout Plain Layout

##' @param object A pctable object 
\end_layout

\begin_layout Plain Layout

##' @param colpct Default TRUE: should column percents be included
\end_layout

\begin_layout Plain Layout

##' @param rowpct Default FALSE: should row percents be included
\end_layout

\begin_layout Plain Layout

##' @param ...
 Other arguments, currently unused
\end_layout

\begin_layout Plain Layout

##' @return An object of class summary.pctable
\end_layout

\begin_layout Plain Layout

##' @author Paul Johnson <pauljohn@@ku.edu>
\end_layout

\begin_layout Plain Layout

##' @method summary pctable
\end_layout

\begin_layout Plain Layout

##' @export
\end_layout

\begin_layout Plain Layout

summary.pctable <- 
\end_layout

\begin_layout Plain Layout

function(object, ..., colpct = TRUE, rowpct = FALSE)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    colpct <- if (missing(colpct)) object$call[["colpct"]] else colpct 
\end_layout

\begin_layout Plain Layout

    rowpct <- if (missing(rowpct)) object$call[["rowpct"]] else rowpct
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    count <- object[["count"]]
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    t3 <- count
\end_layout

\begin_layout Plain Layout

    attr(t3, which = "colpct") <- colpct
\end_layout

\begin_layout Plain Layout

    attr(t3, which = "rowpct") <- rowpct
\end_layout

\begin_layout Plain Layout

    class(t3) <- c("summary.pctable", "table")
\end_layout

\begin_layout Plain Layout

    if (colpct && !rowpct) {
\end_layout

\begin_layout Plain Layout

        cpct <- object[["colpct"]]
\end_layout

\begin_layout Plain Layout

        for(j in rownames(cpct)){
\end_layout

\begin_layout Plain Layout

            for(k in colnames(cpct)){
\end_layout

\begin_layout Plain Layout

                t3[j, k] <- paste0(count[j, k], "(", cpct[j, k], "%)")
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        return(t3)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    ## rowpct == TRUE else would have returned
\end_layout

\begin_layout Plain Layout

    rpct <- object[["rowpct"]]
\end_layout

\begin_layout Plain Layout

    for(j in rownames(rpct)){
\end_layout

\begin_layout Plain Layout

        for(k in colnames(rpct)){
\end_layout

\begin_layout Plain Layout

            t3[j, k] <- paste0(count[j, k], "(", rpct[j, k], "%)")
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if (!colpct) {
\end_layout

\begin_layout Plain Layout

        return(t3)
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        cpct <- object[["colpct"]]
\end_layout

\begin_layout Plain Layout

        t4 <- array("", dim = c(1, 1) + c(2,1)*dim(object$colpct))
\end_layout

\begin_layout Plain Layout

        t4[seq(1, NROW(t4), 2), ] <- t3
\end_layout

\begin_layout Plain Layout

        rownames(t4)[seq(1, NROW(t4), 2)] <- rownames(t3)
\end_layout

\begin_layout Plain Layout

        rownames(t4)[is.na(rownames(t4))] <- "" 
\end_layout

\begin_layout Plain Layout

        colnames(t4) <- colnames(t3)
\end_layout

\begin_layout Plain Layout

        for(j in rownames(object[["colpct"]])) {
\end_layout

\begin_layout Plain Layout

            for(k in colnames(object[["colpct"]])){
\end_layout

\begin_layout Plain Layout

                t4[1 + which(rownames(t4) == j) ,k] <- paste0(object[["colpct"]]
[j, k], "%")
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        t4 <- as.table(t4)
\end_layout

\begin_layout Plain Layout

        names(dimnames(t4)) <- names(dimnames(count))
\end_layout

\begin_layout Plain Layout

        attr(t4, which = "colpct") <- colpct
\end_layout

\begin_layout Plain Layout

        attr(t4, which = "rowpct") <- rowpct
\end_layout

\begin_layout Plain Layout

        class(t4) <- c("summary.pctable", "table")
\end_layout

\begin_layout Plain Layout

        return(t4)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##' print method for summary.pctable objects 
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' prints pctab objects.
 Needed only to deal properly with quotes
\end_layout

\begin_layout Plain Layout

##' 
\end_layout

\begin_layout Plain Layout

##' @param x a summary.pctable object
\end_layout

\begin_layout Plain Layout

##' @param ...
 Other arguments to print method
\end_layout

\begin_layout Plain Layout

##' @return Nothing is returned
\end_layout

\begin_layout Plain Layout

##' @author Paul Johnson <pauljohn@@ku.edu>
\end_layout

\begin_layout Plain Layout

##' @method print summary.pctable
\end_layout

\begin_layout Plain Layout

##' @export
\end_layout

\begin_layout Plain Layout

print.summary.pctable <- function(x, ...){
\end_layout

\begin_layout Plain Layout

    colpct <- attr(x, "colpct")
\end_layout

\begin_layout Plain Layout

    rowpct <- attr(x, "rowpct")
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if (colpct && !rowpct) {
\end_layout

\begin_layout Plain Layout

        cat("Count (column %)
\backslash
n")
\end_layout

\begin_layout Plain Layout

    } else if (!colpct && rowpct) {
\end_layout

\begin_layout Plain Layout

        cat("Count (row %)
\backslash
n")
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        cat("Count (row %)
\backslash
n")
\end_layout

\begin_layout Plain Layout

        cat("column %
\backslash
n")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    NextMethod(generic = "print", object = x, quote = FALSE, ...)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##' Display pctable objects
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' This is not very fancy.
 Note that the saved pctable object
\end_layout

\begin_layout Plain Layout

##' has the information inside it that is required to write both
\end_layout

\begin_layout Plain Layout

##' column and row percentages.
 The arguments colpct and rowpct
\end_layout

\begin_layout Plain Layout

##' are used to ask for the two types.
\end_layout

\begin_layout Plain Layout

##' 
\end_layout

\begin_layout Plain Layout

##' @param x A pctable object
\end_layout

\begin_layout Plain Layout

##' @param colpct Default TRUE: include column percentages?
\end_layout

\begin_layout Plain Layout

##' @param rowpct Default FALSE: include row percentages?
\end_layout

\begin_layout Plain Layout

##' @param ...
 Other arguments passed through to print method
\end_layout

\begin_layout Plain Layout

##' @return A table object for the final printed table.
\end_layout

\begin_layout Plain Layout

##' @author Paul Johnson <pauljohn@@ku.edu>
\end_layout

\begin_layout Plain Layout

##' @method print pctable
\end_layout

\begin_layout Plain Layout

##' @export
\end_layout

\begin_layout Plain Layout

print.pctable <- function(x, colpct = TRUE, rowpct = FALSE, ...)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    colpct <- if (missing(colpct)) x$call[["colpct"]] else colpct 
\end_layout

\begin_layout Plain Layout

    rowpct <- if (missing(rowpct)) x$call[["rowpct"]] else rowpct
\end_layout

\begin_layout Plain Layout

    tab <- summary(x, colpct = colpct, rowpct = rowpct)
\end_layout

\begin_layout Plain Layout

    print(tab, ...)
\end_layout

\begin_layout Plain Layout

    invisible(tab)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

NULL
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Why does this work? R class}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
pctable is designed with the R secret recipe in mind.
\end_layout

\begin_layout Itemize
pctable()
\end_layout

\begin_deeper
\begin_layout Itemize
creates a set of data structures
\end_layout

\end_deeper
\begin_layout Itemize
summary.pctable can create a summary view, which picks through the structures
 to make the desired information.
\end_layout

\begin_layout Itemize
print.summary.pctable displays the summary to the user
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Attributes}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Object is created with an attribute named "class"
\end_layout

\begin_layout Itemize
R runtime system depends on the class attribute.
 
\end_layout

\begin_deeper
\begin_layout Standard
See all attributes
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

attributes(t1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
- Or just the one attribute we want to know
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

class(t1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{R Functions set Attributes as class strings}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Check any of the major model fitting functions in the R source code.
 
\end_layout

\begin_layout Itemize
Toward the end, as in the lm() function, one will find: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

class(z) <- c(if (is.matrix(y)) "mlm", "lm")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Meaning: If the model is multivariate, the class vector will be c("mlm",
 "lm"), otherwise just "lm".
 
\end_layout

\begin_layout Itemize
More specialized classes are appended 
\emph on
on the front
\emph default
 of the list.
\end_layout

\begin_deeper
\begin_layout Itemize
Something classed as c("mlm", "lm") can have specialized functions for "mlm"
 objects where needed, but can use functions intended for "lm" objects when
 suitable.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Ways To Break It
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{The S3 system is very informal}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
- Can set class attribute to anything you want
\end_layout

\begin_layout Standard
- Unlike more structured languages like C++ or Java, there is no
\end_layout

\begin_layout Standard
type-checking to make sure this makes sense.
\end_layout

\begin_layout Standard
- No need to "register" the class with the runtime system in any more elaborate
 way.
\end_layout

\begin_layout Standard
- For existing R generic functions like summary, plot, print, table, and
 so forth, one need only create functions named summary.mynewclass, print.mynewcla
ss, table.mynewclass, etc.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Create some mischief, version 1.}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
- Lie to the R runtime (make a false claim.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Schunk}
\end_layout

\begin_layout Plain Layout


\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

m1 <- c(1, 2, 3)
\end_layout

\begin_layout Plain Layout

class(m1) <- "lm"
\end_layout

\begin_layout Plain Layout


\backslash
end{Sinput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{Soutput}
\end_layout

\begin_layout Plain Layout

summary(m1)
\end_layout

\begin_layout Plain Layout


\backslash
end{Soutput}
\end_layout

\begin_layout Plain Layout


\backslash
begin{Soutput}
\end_layout

\begin_layout Plain Layout

Error: $ operator is invalid for atomic vectors
\end_layout

\begin_layout Plain Layout


\backslash
end{Soutput}
\end_layout

\begin_layout Plain Layout


\backslash
end{Schunk}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Create some mischief, version 2.}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Here's a real lm regression object
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<m1.1>>=
\end_layout

\begin_layout Plain Layout

dat <- data.frame(x = rnorm(100), y = rnorm(100))
\end_layout

\begin_layout Plain Layout

m1 <- lm(y ~ x, data = dat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Add a new class on the front.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<m1.2>>=
\end_layout

\begin_layout Plain Layout

class(m1) <- c("pjgreatest", class(m1))
\end_layout

\begin_layout Plain Layout

class(m1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The "pjgreatest" class has no methods, so anything we run will "still work"
 because R looks at the class list.
 It finds no method "summary.pjgreatest", but it finds the Next Method "summary.lm
".
 See?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

summary(m1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Now lets provide a new summary method
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

summary.pjgreatest <- function(object, ...){
\end_layout

\begin_layout Plain Layout

    newres <- NextMethod(generic = "summary", object = object, ...)
\end_layout

\begin_layout Plain Layout

    newres$Rsquare <- runif(1, min = 0.90, max = 0.999)
\end_layout

\begin_layout Plain Layout

    class(newres) <- c("summary.pjgreatest", class(newres))
\end_layout

\begin_layout Plain Layout

    newres
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Create some mischief, version 2.}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
-The strong (strong!) recommendation from R Core is to write summary methods
 that return data structures, and then we write a print method to display
 that structure.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

print.summary.pjgreatest <- function(x, ...){
\end_layout

\begin_layout Plain Layout

cat("You are now in the twilight zone.
 
\backslash
n")
\end_layout

\begin_layout Plain Layout

cat("All regressions fitted here are nearly perfect.
 
\backslash
n")
\end_layout

\begin_layout Plain Layout

cat(paste("The Rsquare is", x$Rsquare, "
\backslash
n
\backslash
n"))
\end_layout

\begin_layout Plain Layout

cat(paste("That's a great Rsquare, just like you deserve! 
\backslash
n
\backslash
n"))
\end_layout

\begin_layout Plain Layout

cat("But if you want to believe those R guys, the R square is only", x$r.square,
 "
\backslash
n
\backslash
n")
\end_layout

\begin_layout Plain Layout

cat("See?
\backslash
n")
\end_layout

\begin_layout Plain Layout

NextMethod(generic = "print", object = x, ...)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

summary(m1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Misc: dots
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Generic functions almost always are simple with a minimal declaration
}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
- "..." is a legal word.
 Meaning "user can add named arguments and if they don't match the ones
 we expect, we'll toss all of them into "...".
 Comments about processing "..." included in new Rchaeology.
\end_layout

\begin_layout Standard
- The generic print
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

print <- function(x, ...) UseMethod("print")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
- This preserves flexibility, puts weight of work onto methods, which 
\end_layout

\begin_layout Standard
- can have more named arguments.
\end_layout

\begin_layout Standard
- must have arguments x and ...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{...
 is a three letter word}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
- Literally, three periods is a word!
\end_layout

\begin_layout Standard
- There's not much manual info on "...".
 Study of the R source code.
 See how they do it, then do it like they do.
\end_layout

\begin_layout Standard
- Explanation inserted into new Rchaeology vignette.
\end_layout

\begin_layout Standard
- Inside a function, we almost always either grab and inspect the dots
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

dots <- list(...)
\end_layout

\begin_layout Plain Layout

dotnames <- names(dots)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Often, the dots have argument that are intended for a particular purpose.
 We often have to separate the arguments, by name (dotnames).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Stages regression example
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Building an S3 class around an Mplus Automation result
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
A project becomes chaotic if we let researchers rename all of the functions
 to suit their tastes.
 
\end_layout

\begin_layout Itemize
Likely more helpful to users if we can reshape functions in to the familiary
 R sequence 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

m1 <- fitter(y ~ x1 + x2, data = dat)
\end_layout

\begin_layout Plain Layout

summary(m1)
\end_layout

\begin_layout Plain Layout

coef(m1) ## method displays brief 
\end_layout

\begin_layout Plain Layout

coef(summary(m1)) 
\end_layout

\begin_layout Plain Layout

anova(m1)
\end_layout

\begin_layout Plain Layout

plot(m1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Separator

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{We began with an interace with idiosyncratic names}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<re10, eval=F>>=
\end_layout

\begin_layout Plain Layout

runEverything <- function(dFrame = NULL, formString = NULL, missValue =
 -999, patternV = patternVector, mScript = mplusSkel, mplusFile = "mplus.csv",
 isMissing = FALSE, numPerLine = 5, isWeighted = FALSE, mplusDir = "../../NLTS2-data
/Mplus/", subPop = FALSE) {
\end_layout

\begin_layout Plain Layout

    ## snip
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

summarizeObj <- function(List = NULL, r.VGAM = FALSE, dFrame = NULL){
\end_layout

\begin_layout Plain Layout

    ## snip
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Here's what we end up with}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<re20, eval=F>>=
\end_layout

\begin_layout Plain Layout

stages <- function(formula = NULL, data = NULL, missValue = -999, skel =
 mplusSkel, mplusFile = "mplus.csv", isMissing = FALSE, numPerLine = 5, isWeighte
d = FALSE, mplusDir = "../../NLTS2-data/Mplus/", subPop = FALSE)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    require(MplusAutomation)
\end_layout

\begin_layout Plain Layout

    if (!file.exists(mplusDir)) dir.create(mplusDir, showWarnings = FALSE,
 recursive = TRUE)
\end_layout

\begin_layout Plain Layout

    if (!plyr::is.formula(formula)) formula <- as.formula(formula)
\end_layout

\begin_layout Plain Layout

    ## Create the matrix and recoding for Mplus
\end_layout

\begin_layout Plain Layout

    mMat <- makeMplusMat(formula, data, missValue)
\end_layout

\begin_layout Plain Layout

    ## Make the number of stages
\end_layout

\begin_layout Plain Layout

    nstages <- length( unique( mMat[mMat[, 1] != -999, 1] ) )
\end_layout

\begin_layout Plain Layout

    ## Check if nstages is 2, 3, or 4
\end_layout

\begin_layout Plain Layout

    if(nstages < 2 || nstages > 4){
\end_layout

\begin_layout Plain Layout

        stop('The number of stages must be 2, 3, or 4')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ## Add in code about 2 stages aka logistic regression
\end_layout

\begin_layout Plain Layout

    if(nstages > 2){
\end_layout

\begin_layout Plain Layout

        mMat <- recodeMplus(mMat, nstages, missValue)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ## Makes the replacement vector along with the mplus Key 
\end_layout

\begin_layout Plain Layout

    ## for conversion later returns list
\end_layout

\begin_layout Plain Layout

    rList <- makeReplacementVector(mplusFile = mplusFile,
\end_layout

\begin_layout Plain Layout

                data = mMat, skel = skel, isMissing = isMissing, numPerLine
 = numPerLine,
\end_layout

\begin_layout Plain Layout

                isWeighted = isWeighted, nstages = nstages, 
\end_layout

\begin_layout Plain Layout

                missValue = as.character(missValue),
\end_layout

\begin_layout Plain Layout

                subPop = subPop)
\end_layout

\begin_layout Plain Layout

    mplusKey <- rList[[2]]
\end_layout

\begin_layout Plain Layout

    outList <- runMplus(data = mMat, replaceV = rList[[1]], skel, mplusDir,
 mplusFile)
\end_layout

\begin_layout Plain Layout

    ## more direct way to rename all values in param column, misses Thresholds,
 however
\end_layout

\begin_layout Plain Layout

    pjkey <- mplusKey[ , "predictors"]
\end_layout

\begin_layout Plain Layout

    names(pjkey) <- mplusKey[ , "mplus"]
\end_layout

\begin_layout Plain Layout

    ## Now beautify names of variables and columns in parameter objects
\end_layout

\begin_layout Plain Layout

    newheaders <- c(pval = "Pr(>|z|)", est = "Estimate", se = "Std Error",
 est_se = "z value")
\end_layout

\begin_layout Plain Layout

    for(aname in names(outList$parameters)){
\end_layout

\begin_layout Plain Layout

        param <- outList[["parameters"]][[aname]][["param"]]
\end_layout

\begin_layout Plain Layout

        outList[["parameters"]][[aname]][["param"]] <- 
\end_layout

\begin_layout Plain Layout

            ifelse( param %in% names(pjkey), pjkey[param], param)
\end_layout

\begin_layout Plain Layout

        ## PJ.
 need to catch thresholds named V$x.
 make second pass
\end_layout

\begin_layout Plain Layout

        param <- sapply(strsplit(param, "
\backslash

\backslash
$"), function(xxx) xxx[1])
\end_layout

\begin_layout Plain Layout

        outList[["parameters"]][[aname]][["param"]] <- 
\end_layout

\begin_layout Plain Layout

            ifelse( param %in% names(pjkey), pjkey[param], param)
\end_layout

\begin_layout Plain Layout

        paramHeader <- outList[["parameters"]][[aname]][["paramHeader"]]
\end_layout

\begin_layout Plain Layout

        phlist <- strsplit(paramHeader, "
\backslash

\backslash
.")
\end_layout

\begin_layout Plain Layout

        for(i in seq_along(phlist)){ 
\end_layout

\begin_layout Plain Layout

            phlist[[i]][1] <- ifelse(phlist[[i]][1] %in% names(pjkey),
\end_layout

\begin_layout Plain Layout

            pjkey[phlist[[i]][1]],
\end_layout

\begin_layout Plain Layout

            phlist[[i]][1])
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        outList[["parameters"]][[aname]][["paramHeader"]] <- 
\end_layout

\begin_layout Plain Layout

            lapply(phlist, function(xx) paste0(xx, collapse = "."))
\end_layout

\begin_layout Plain Layout

        oldcols <- colnames(outList[["parameters"]][[aname]])
\end_layout

\begin_layout Plain Layout

        colnames(outList[["parameters"]][[aname]]) <- ifelse(oldcols %in%
 names(newheaders), newheaders[oldcols], oldcols)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    res <- list(output = outList, mplusKey = mplusKey, formula = formula,
\end_layout

\begin_layout Plain Layout

                mplusFile = paste0(mplusDir, "mplus.out"))
\end_layout

\begin_layout Plain Layout

    class(res) <- "stages"
\end_layout

\begin_layout Plain Layout

    invisible(res)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

summary.stages <- function(object = NULL, type = "unstandardized", trimrows
 = TRUE, ...)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    ## Check for type as character
\end_layout

\begin_layout Plain Layout

    if(is.character(type)){
\end_layout

\begin_layout Plain Layout

        type <- match.arg(tolower(type), 
\end_layout

\begin_layout Plain Layout

            c('unstandardized', 'std.standardized',
\end_layout

\begin_layout Plain Layout

              'stdy.standardized', 'stdyx.standardized'))
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        stop(paste("type must equal unstandardized,",
\end_layout

\begin_layout Plain Layout

        "stdyx.standardized, stdy.standardized,", 
\end_layout

\begin_layout Plain Layout

        "or std.standardized."))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    formula <- object$formula 
\end_layout

\begin_layout Plain Layout

    coefs <- object[["output"]][["parameters"]][[type]]
\end_layout

\begin_layout Plain Layout

    noise <- grep("Means$|Variances$|.*WITH$", coefs$paramHeader)
\end_layout

\begin_layout Plain Layout

    paramHeader <- coefs$paramHeader
\end_layout

\begin_layout Plain Layout

    if (trimrows & length(noise) > 0){
\end_layout

\begin_layout Plain Layout

        coefs <- coefs[-noise, ] 
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ## only if trimrows can we tighten up predictor names
\end_layout

\begin_layout Plain Layout

    if (trimrows){
\end_layout

\begin_layout Plain Layout

        paramHeader <- substr(coefs$paramHeader, 1, 2)
\end_layout

\begin_layout Plain Layout

        paramHeader <- gsub("C", "", paramHeader)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ## Make rownames
\end_layout

\begin_layout Plain Layout

    rownames(coefs) <- paste0(coefs$param, ";", paramHeader)
\end_layout

\begin_layout Plain Layout

    ## JH 2/4/2015
\end_layout

\begin_layout Plain Layout

    ## create Th;1, ...., Th;n
\end_layout

\begin_layout Plain Layout

    charVec <- paste0('^', rownames(object$mplusKey)[grep('^C
\backslash

\backslash
d{1,}_', rownames(object$mplusKey))], ';.+')
\end_layout

\begin_layout Plain Layout

    newThVec <- paste0('Threshold;', 1:length(charVec))
\end_layout

\begin_layout Plain Layout

    ## Final rownames
\end_layout

\begin_layout Plain Layout

    rownames(coefs) <- multiGsub(charVec, newThVec, rownames(coefs))
\end_layout

\begin_layout Plain Layout

    coefs$param <- NULL
\end_layout

\begin_layout Plain Layout

    coefs$paramHeader <- NULL
\end_layout

\begin_layout Plain Layout

    coefs <- as.matrix(coefs)
\end_layout

\begin_layout Plain Layout

    res <- list(coefficients = coefs, N = object[[1]]$summaries$Observations,
\end_layout

\begin_layout Plain Layout

                 LL = object[[1]]$summaries$LL ,
\end_layout

\begin_layout Plain Layout

                 AIC = object[[1]]$summaries$AIC,
\end_layout

\begin_layout Plain Layout

                 BIC = object[[1]]$summaries$BIC,
\end_layout

\begin_layout Plain Layout

                 aBIC = object[[1]]$summaries$aBIC,
\end_layout

\begin_layout Plain Layout

                 AICC = object[[1]]$summaries$AICC, formula = formula)
\end_layout

\begin_layout Plain Layout

    class(res) <- "summary.stages"
\end_layout

\begin_layout Plain Layout

    attr(res, "trimrows") <- trimrows
\end_layout

\begin_layout Plain Layout

    attr(res, "type") <- type
\end_layout

\begin_layout Plain Layout

    res
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

print.summary.stages <- function(x, digits = max(3L, getOption("digits") -
 3L),
\end_layout

\begin_layout Plain Layout

                         signif.stars = getOption("show.signif.stars"), ....)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    coefs <- x$coefficients
\end_layout

\begin_layout Plain Layout

    cat(paste("This is", attr(x, "type") , 
\end_layout

\begin_layout Plain Layout

        "output from Mplus, reformatted similar to VGAM", "
\backslash
n"))
\end_layout

\begin_layout Plain Layout

    if (attr(x, "trimrows")) cat(paste("Note: Omitting output rows for WITH,",
\end_layout

\begin_layout Plain Layout

        "Variances, Means", "
\backslash
n"))
\end_layout

\begin_layout Plain Layout

    printCoefmat(coefs, digits = digits, signif.stars = signif.stars,
\end_layout

\begin_layout Plain Layout

                 na.print = "NA") 
\end_layout

\begin_layout Plain Layout

    cat(paste("N:" , formatC(x$N, digits = digits), "
\backslash
n"))
\end_layout

\begin_layout Plain Layout

    cat(paste("LL:" , formatC(x$LL, digits = digits), "
\backslash
n"))
\end_layout

\begin_layout Plain Layout

    cat(paste("AIC:" , formatC(x$AIC, digits = digits), "
\backslash
n"))
\end_layout

\begin_layout Plain Layout

    cat(paste("BIC:" , formatC(x$BIC, digits = digits), "
\backslash
n"))
\end_layout

\begin_layout Plain Layout

    cat(paste("aBIC:" , formatC(x$aBIC, digits = digits), "
\backslash
n"))
\end_layout

\begin_layout Plain Layout

    cat(paste("AICC:" , formatC(x$AICC, digits = digits), "
\backslash
n"))
\end_layout

\begin_layout Plain Layout

    invisible(coefs)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

nobs.stages <- function(object, ...){
\end_layout

\begin_layout Plain Layout

    object[[1]]$summaries$Observations
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

logLik.stages <- function(object, ...){
\end_layout

\begin_layout Plain Layout

    myll <- object[[1]]$summaries$LL
\end_layout

\begin_layout Plain Layout

    attr(myll, "df") <- object[[1]]$summaries$Parameters
\end_layout

\begin_layout Plain Layout

    myll
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

coef.summary.stages <- function(object, ...){ 
\end_layout

\begin_layout Plain Layout

    ggg <- object$coefficients
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

coef.stages <- function(object, ...){
\end_layout

\begin_layout Plain Layout

    objsum <- summary(object)$coefficients
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Key Elements}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
- Review the output from lm and glm, and output from summary.lm and summary.glm
\end_layout

\begin_layout Plain Layout
- New class stages should use IDENTICAL names for output elements where
 possible
\end_layout

\begin_layout Plain Layout
- Note that R summary methods for regressions have a standard format
\end_layout

\begin_layout Plain Layout
for tables, and the table is accessed by coef(summary(m1))
\end_layout

\begin_layout Plain Layout
- Methods using common R names need to be provided:
\end_layout

\begin_layout Plain Layout
- nobs
\end_layout

\begin_layout Plain Layout
- coef
\end_layout

\begin_layout Plain Layout
- coef.summary
\end_layout

\begin_layout Plain Layout
- logLik
\end_layout

\begin_layout Plain Layout
- Needs anova method
\end_layout

\begin_layout Plain Layout
- This "almost" (99.7%) is compatible with outreg regression table generator
\end_layout

\begin_layout Plain Layout
- Need next: Roxygen markup to document functions
\end_layout

\begin_layout Plain Layout
## Advice about designing interfaces
\end_layout

\begin_layout Plain Layout
- new Rchaeology vignette
\end_layout

\begin_layout Plain Layout
- tidbits
\end_layout

\begin_layout Plain Layout
1.
 Protect your function's calculations from the user's workspace.
\end_layout

\begin_layout Plain Layout
2.
 Check argument values.
\end_layout

\begin_layout Plain Layout
3.
 Design the function so that it runs with a minimum number of arguments.
\end_layout

\begin_layout Plain Layout
## Now I emphasize 3, the minimum number of arguments
\end_layout

\begin_layout Plain Layout
- In the development process, we are often unsure which arguments should
 be passed around.
\end_layout

\begin_layout Plain Layout
- Often we end up with 3 or 4 related things, "a1", "b1", "c1", "d1" and
 function declarations have all four of those things passed along.
 
\end_layout

\begin_layout Plain Layout
- If those 4 things really are linked, they are always companions, we should
 more formally link them together.
 Can
\end_layout

\begin_layout Plain Layout
- Put all 4 things into a list, or
\end_layout

\begin_layout Plain Layout
- Create a1 and then add b1 c1 d1 as attributes:
\end_layout

\begin_layout Plain Layout
```
\end_layout

\begin_layout Plain Layout
attr(a1, "b") <- b1
\end_layout

\begin_layout Plain Layout
attr(a1, "c") <- c1
\end_layout

\begin_layout Plain Layout
attr(a1, "d") <- d1
\end_layout

\begin_layout Plain Layout
```
\end_layout

\begin_layout Plain Layout
This eliminates the need to write myFunction(a, b, c, d) to receive 4 arguments,
 we instead write
\end_layout

\begin_layout Plain Layout
```
\end_layout

\begin_layout Plain Layout
myFunction <- function (a){
\end_layout

\begin_layout Plain Layout
b <- attr(a, "b")
\end_layout

\begin_layout Plain Layout
c <- attr(a, "c")
\end_layout

\begin_layout Plain Layout
d <- attr(d, "d")
\end_layout

\begin_layout Plain Layout
[blah blah blah]
\end_layout

\begin_layout Plain Layout
}
\end_layout

\begin_layout Plain Layout
```
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
