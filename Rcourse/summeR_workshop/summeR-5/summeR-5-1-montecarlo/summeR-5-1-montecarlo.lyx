#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usepackage{dcolumn}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{graphicx}
\renewcommand{\doiprefix}{doi:\kern-1pt}
\setlength{\bibsep}{10pt}

% use 'handout' to produce handouts
%\documentclass[handout]{beamer}
\usepackage{wasysym}
\usepackage{pgfpages}
%for bold upright roman in math for matrix algebra
\newcommand{\vn}[1]{\mbox{{\it #1}}}\newcommand{\vb}{\vspace{\baselineskip}}\newcommand{\vh}{\vspace{.5\baselineskip}}\newcommand{\vf}{\vspace{\fill}}\newcommand{\splus}{\textsf{S-PLUS}}\newcommand{\R}{\textsf{R}}

%%\input{theme/guidePreambleSweavel.tex} 
%%% From beamer slide:
\usepackage{Sweave}
%% 
%% This controls display of code chunks
\usepackage{ae,fancyvrb,relsize,listings}

\providecommand{\Sweavesize}{\normalsize}
\providecommand{\Rsize}{}
\renewcommand{\Rsize}{\normalsize}
\providecommand{\Routsize}{\scriptsize}

\providecommand{\Rcolor}{\color[rgb]{0.1, 0.1, 0.1}}
\providecommand{\Routcolor}{\color[rgb]{0.2, 0.2, 0.2}}
\providecommand{\Rcommentcolor}{\color[rgb]{0.101, 0.43, 0.432}}

\providecommand{\Rbackground}{\color[gray]{0.91}}
\providecommand{\Routbackground}{\color[gray]{0.935}}
% Can specify \color[gray]{1} for white background or just \color{white}

\lstdefinestyle{Rinput}{
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  basicstyle=\Rsize\Rcolor\ttfamily,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%,
  commentstyle=\Rcommentcolor\ttfamily,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1{==}{{=\,=}}2{--}{{-\,-}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
  backgroundcolor=\Rbackground,%
  numbers=left,%
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}%

% Other options of interest:
% frame=single,framerule=0.1pt,framesep=1pt,rulecolor=\color{blue},
% numbers=left,numberstyle=\tiny,stepnumber=1,numbersep=7pt,
% keywordstyle={\bf\Rcolor}

\lstdefinestyle{Routput}{fancyvrb=false,
  literate={~}{{$\sim$}}1{R^2}{{$R^{2}$}}2{^}{{$^{\scriptstyle\wedge}$}}1{R-squared}{{$R^{2}$}}2,%
  basicstyle=\Routcolor\Routsize\ttfamily,%
  backgroundcolor=\Routbackground,
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1 {==}{{=\,=}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},
  numbers=left,
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}

\renewenvironment{Schunk}{}{}
\renewenvironment{Sinput}{}{}
\let\Sinput\relax
\let\Scode\relax
\let\Soutput\relax
\lstnewenvironment{Sinput}{\lstset{style=Rinput}}{}
\lstnewenvironment{Scode}{\lstset{style=Rinput}}{}
\lstnewenvironment{Soutput}{\lstset{style=Routput}}{}
%%end paste in from guidePreambleSweavel.tex


\lstset{tabsize=2, breaklines=true, style=Rinput, breakatwhitespace=true}

\fvset{listparameters={\setlength{\topsep}{0em}}}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.90}
\usepackage{realboxes}
\providecommand*{\code}[1]{\texttt{#1}}
\renewcommand{\code}[1]{%
\Colorbox{light-gray}{#1}%
}%
%% end of paste

\usepackage[natbibapa]{apacite}

\definecolor{darkblue}{HTML}{1e2277}

%would be in beamerthemekucrmda%
\mode<presentation>
\definecolor{kublue}{RGB}{0,81,186}
\usefonttheme{professionalfonts}
\useoutertheme{infolines}
\useinnertheme{rounded}
%disable rounded for alert and example boxes%
\setbeamertemplate{blocks}[default]
\usecolortheme{whale}
\usecolortheme{orchid}
\setbeamercolor{structure}{bg=kublue,fg=kublue!90!black}
%\setbeamercolor{structure}{fg=kublue}
\setbeamercolor{frametitle}{bg=kublue}
\setbeamercolor{section in toc}{fg=kublue!40!black}

\setbeamertemplate{frametitle continuation}[from second]
\renewcommand\insertcontinuationtext{...}
\beamertemplatenavigationsymbolsempty
%end of beamerthemekucrmda%

%If you want bigger margins, try this:
\setbeamersize{text margin left=05mm,text margin right=10mm} 
\hypersetup{colorlinks,allcolors=.,urlcolor=darkblue}
%Following seems to have no effect now
%\usepackage{handoutWithNotes}
%\pgfpagesuselayout{3 on 1 with notes}[letterpaper, border shrink=5mm]

\titlegraphic{\includegraphics[width=6cm]{theme/logo}}
\logo{\includegraphics[width=5mm]{theme/logomini}}
\end_preamble
\options aspectratio=1609
\use_default_options false
\begin_modules
logicalmkup
sweave
natbibapa
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style \use_bibtopic false
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\branch R
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch semboot
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\branch cfalvm
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%following is LyX shortcut 
\backslash
vb for bold upright math for matrices
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\vb}[1]{\bm{\mathrm{#1}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch R
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% tmpout directory must exist first
\end_layout

\begin_layout Plain Layout

<<tmpout, echo=FALSE, include=FALSE, results=hide>>=
\end_layout

\begin_layout Plain Layout

tdir <- "tmpout"
\end_layout

\begin_layout Plain Layout

if(!dir.exists(tdir)) dir.create(tdir, showWarnings=FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{prefix.string=tmpout/t,split=T,ae=F,height=4.5,width=7}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, include=F, results=hide>>=
\end_layout

\begin_layout Plain Layout

opts.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=100, prompt = " ", continue = "  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE)
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

par.orig <- par(no.readonly = TRUE) 
\end_layout

\begin_layout Plain Layout

pjmar <- c(4.1, 4.1, 1.5, 2.1)
\end_layout

\begin_layout Plain Layout

options(SweaveHooks=list(fig=function() par(mar=pjmar, ps=12, xpd=F)))
\end_layout

\begin_layout Plain Layout

pdf.options(onefile=F,family="Times",pointsize=12)
\end_layout

\begin_layout Plain Layout

if(!file.exists("theme")) file.symlink("../../../../template/theme", "theme")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Title
Monte Carlo Simulation 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
MC
\end_layout

\end_inset


\end_layout

\begin_layout Author
Paul Johnson, Ben Kite, Terrence Jorgensen
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
CRMDA
\end_layout

\end_inset


\end_layout

\begin_layout Institute
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
1
\end_layout

\end_inset

Center for Research Methods and Data Analysis 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
CRMDA
\end_layout

\end_inset


\end_layout

\begin_layout Date
2018
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following causes the table of contents to be shown at the beginning
 of every subsection.
 Delete this, if you do not want it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSection[]{
\end_layout

\begin_layout Plain Layout

  
\backslash
frame<beamer>{ 
\end_layout

\begin_layout Plain Layout

    
\backslash
frametitle{Outline}
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection] 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Outline}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Instructions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{This is a template, not instructions}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
All of this is brought to us by R 
\begin_inset CommandInset citation
LatexCommand citep
key "RCore"
literal "true"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{What is a Monte Carlo Simulation?}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Generating from a known probability model
\end_layout

\begin_layout Itemize
Comparing variations among separate samples drawn from the model
\end_layout

\begin_layout Itemize
“Monte Carlo Analysis in Academic Research” (Johnson, 2013) gives history
 and applications doi:10.1093/oxfordhb/9780199934874.013.0022 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Goals of a Monte Carlo Simulation}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Consider a statistical procedure (e.g., a t test) that receives data and returns
 a result – i.e., parameter estimates, sample statistics
\end_layout

\begin_layout Itemize
Presumably there is a “true” set of parameters (
\begin_inset Quotes eld
\end_inset

population values
\begin_inset Quotes erd
\end_inset

) that the estimate is supposed to represent
\end_layout

\begin_layout Itemize
We wonder
\end_layout

\begin_deeper
\begin_layout Itemize
Does the procedure yield unbiased (correct 
\begin_inset Quotes eld
\end_inset

on average
\begin_inset Quotes erd
\end_inset

) estimates of the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 parameters?
\end_layout

\begin_layout Itemize
Is an estimator consistent (closer to correct as the sample size grows?)
\end_layout

\begin_layout Itemize
Is the sampling distribution of the estimates normal, symmetric, etc.?
\end_layout

\end_deeper
\begin_layout Itemize
From estimates with 
\begin_inset Quotes eld
\end_inset

real data
\begin_inset Quotes erd
\end_inset

, we can't say if we are 
\begin_inset Quotes eld
\end_inset

right
\begin_inset Quotes erd
\end_inset

, because we don't know the true model of the data generator
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{The Standard "Playbook"}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Specify a data generating process (i.e., a set of parameters)
\end_layout

\begin_deeper
\begin_layout Itemize
often called a 
\begin_inset Quotes eld
\end_inset

population
\begin_inset Quotes erd
\end_inset

 in statistical vernacular
\end_layout

\end_deeper
\begin_layout Itemize
Draw random samples from it 
\end_layout

\begin_layout Itemize
Apply the procedure to each sample
\end_layout

\begin_deeper
\begin_layout Itemize
Save estimates, tests, p-values, etc.
\end_layout

\end_deeper
\begin_layout Itemize
Evaluate the procedure
\end_layout

\begin_deeper
\begin_layout Itemize
Compare stats to parameters, check distributions
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Goals of Analysis}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Check that a procedure behaves as expected
\end_layout

\begin_deeper
\begin_layout Itemize
Does the null rejection rate match the nominal Type I error rate?
\end_layout

\begin_layout Itemize
Are estimates unbiased?
\end_layout

\end_deeper
\begin_layout Itemize
See how a procedure behaves when assumptions are violated
\end_layout

\begin_deeper
\begin_layout Itemize
Inflated Type I error rates? Robust if minor? 
\end_layout

\begin_layout Itemize
Effects of missing data? 
\end_layout

\begin_layout Itemize
Effect of sample size? 
\end_layout

\end_deeper
\begin_layout Itemize
Compare 2 procedures – OLS v.
 WLS; LGCM v.
 MLM
\end_layout

\begin_layout Itemize
Power analysis
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Replication is a Priority}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We must be able to regenerate results exactly without saving each data set
\end_layout

\begin_layout Itemize
Pseudorandom number generator (PRNG)
\end_layout

\begin_deeper
\begin_layout Itemize
Algorithm that generates seemingly random streams of integers
\end_layout

\begin_layout Itemize
The “random” numbers you get depend on a random “state” characterized by
 a “seed”
\end_layout

\begin_deeper
\begin_layout Itemize
Initial starting condition can be controlled by specifying an single integer,
 which is commonly referred to as the 
\begin_inset Quotes eld
\end_inset

seed
\begin_inset Quotes erd
\end_inset

 (but, technically, it is not)
\end_layout

\begin_layout Itemize
Setting the initial seed makes it possible to replicate draws from random
 number generators
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Interactive Session
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Let's Generate Random Numbers in R!}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Let's open our R syntax and get started.
 Here is an outline of today's topics/tasks:
\end_layout

\begin_layout Itemize
Generate some simple (pseudo) random numbers
\end_layout

\begin_layout Itemize
Generate random samples of data using population parameters
\end_layout

\begin_layout Itemize
Design a small-scale Monte Carlo study
\end_layout

\begin_deeper
\begin_layout Itemize
How are Type I errors affected by between-group differences in N and SD?
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Distributions in R
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{R terminology}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For most distributions, R offers functions with names like 
\series bold
r
\series default
norm, 
\series bold
d
\series default
norm, 
\series bold
p
\series default
norm and 
\series bold
q
\series default
norm
\end_layout

\begin_layout Itemize

\series bold
r
\series default
 returns a pseudorandom sample from that distribution 
\end_layout

\begin_layout Itemize

\series bold
d
\series default
 returns the probability density (or probability mass for discrete distributions
)
\end_layout

\begin_layout Itemize

\series bold
p
\series default
 returns the cumulative probability distribution (CDF)
\end_layout

\begin_layout Itemize

\series bold
q
\series default
 returns the quantile associated with a certain cumulative probability
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Help pages for some built-in distributions}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

?rnorm
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},tabsize=2"
inline false
status open

\begin_layout Plain Layout

Normal                  package:stats                  R Documentation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The Normal Distribution
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Description:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     Density, distribution function, quantile function and random
\end_layout

\begin_layout Plain Layout

     generation for the normal distribution with mean equal to 'mean'
\end_layout

\begin_layout Plain Layout

     and standard deviation equal to 'sd'.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Usage:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     dnorm(x, mean = 0, sd = 1, log = FALSE)
\end_layout

\begin_layout Plain Layout

     pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)
\end_layout

\begin_layout Plain Layout

     qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)
\end_layout

\begin_layout Plain Layout

     rnorm(n, mean = 0, sd = 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Arguments:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    x, q: vector of quantiles.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       p: vector of probabilities.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       n: number of observations.
 If 'length(n) > 1', the length is
\end_layout

\begin_layout Plain Layout

          taken to be the number required.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    mean: vector of means.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      sd: vector of standard deviations.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

log, log.p: logical; if TRUE, probabilities p are given as log(p).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lower.tail: logical; if TRUE (default), probabilities are P[X <= x]
\end_layout

\begin_layout Plain Layout

          otherwise, P[X > x].
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Details:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     If 'mean' or 'sd' are not specified they assume the default values
\end_layout

\begin_layout Plain Layout

     of '0' and '1', respectively.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     The normal distribution has density
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            f(x) = 1/(sqrt(2 pi) sigma) e^-((x - mu)^2/(2 sigma^2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     where mu is the mean of the distribution and sigma the standard
\end_layout

\begin_layout Plain Layout

     deviation.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Value:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     'dnorm' gives the density, 'pnorm' gives the distribution
\end_layout

\begin_layout Plain Layout

     function, 'qnorm' gives the quantile function, and 'rnorm'
\end_layout

\begin_layout Plain Layout

     generates random deviates.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     The length of the result is determined by 'n' for 'rnorm', and is
\end_layout

\begin_layout Plain Layout

     the maximum of the lengths of the numerical arguments for the
\end_layout

\begin_layout Plain Layout

     other functions.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     The numerical arguments other than 'n' are recycled to the length
\end_layout

\begin_layout Plain Layout

     of the result.
  Only the first elements of the logical arguments
\end_layout

\begin_layout Plain Layout

     are used.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     For 'sd = 0' this gives the limit as 'sd' decreases to 0, a point
\end_layout

\begin_layout Plain Layout

     mass at 'mu'.
  'sd < 0' is an error and returns 'NaN'.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Source:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     For 'pnorm', based on
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     Cody, W.
 D.
 (1993) Algorithm 715: SPECFUN - A portable FORTRAN
\end_layout

\begin_layout Plain Layout

     package of special function routines and test drivers.
  _ACM
\end_layout

\begin_layout Plain Layout

     Transactions on Mathematical Software_ *19*, 22-32.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     For 'qnorm', the code is a C translation of
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     Wichura, M.
 J.
 (1988) Algorithm AS 241: The percentage points of
\end_layout

\begin_layout Plain Layout

     the normal distribution.
  _Applied Statistics_, *37*, 477-484.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     which provides precise results up to about 16 digits.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     For 'rnorm', see RNG for how to select the algorithm and for
\end_layout

\begin_layout Plain Layout

     references to the supplied methods.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

References:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     Becker, R.
 A., Chambers, J.
 M.
 and Wilks, A.
 R.
 (1988) _The New S
\end_layout

\begin_layout Plain Layout

     Language_.
  Wadsworth & Brooks/Cole.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     Johnson, N.
 L., Kotz, S.
 and Balakrishnan, N.
 (1995) _Continuous
\end_layout

\begin_layout Plain Layout

     Univariate Distributions_, volume 1, chapter 13.
  Wiley, New York.
\end_layout

\begin_layout Plain Layout

See Also:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     Distributions for other standard distributions, including 'dlnorm'
\end_layout

\begin_layout Plain Layout

     for the _Log_normal distribution.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Examples:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     require(graphics)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     dnorm(0) == 1/sqrt(2*pi)
\end_layout

\begin_layout Plain Layout

     dnorm(1) == exp(-1/2)/sqrt(2*pi)
\end_layout

\begin_layout Plain Layout

     dnorm(1) == 1/sqrt(2*pi*exp(1))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     ## Using "log = TRUE" for an extended range :
\end_layout

\begin_layout Plain Layout

     par(mfrow = c(2,1))
\end_layout

\begin_layout Plain Layout

     plot(function(x) dnorm(x, log = TRUE), -60, 50,
\end_layout

\begin_layout Plain Layout

          main = "log { Normal density }")
\end_layout

\begin_layout Plain Layout

     curve(log(dnorm(x)), add = TRUE, col = "red", lwd = 2)
\end_layout

\begin_layout Plain Layout

     mtext("dnorm(x, log=TRUE)", adj = 0)
\end_layout

\begin_layout Plain Layout

     mtext("log(dnorm(x))", col = "red", adj = 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     plot(function(x) pnorm(x, log.p = TRUE), -50, 10,
\end_layout

\begin_layout Plain Layout

          main = "log { Normal Cumulative }")
\end_layout

\begin_layout Plain Layout

     curve(log(pnorm(x)), add = TRUE, col = "red", lwd = 2)
\end_layout

\begin_layout Plain Layout

     mtext("pnorm(x, log=TRUE)", adj = 0)
\end_layout

\begin_layout Plain Layout

     mtext("log(pnorm(x))", col = "red", adj = 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     ## if you want the so-called 'error function'
\end_layout

\begin_layout Plain Layout

     erf <- function(x) 2 * pnorm(x * sqrt(2)) - 1
\end_layout

\begin_layout Plain Layout

     ## (see Abramowitz and Stegun 29.2.29)
\end_layout

\begin_layout Plain Layout

     ## and the so-called 'complementary error function'
\end_layout

\begin_layout Plain Layout

     erfc <- function(x) 2 * pnorm(x * sqrt(2), lower = FALSE)
\end_layout

\begin_layout Plain Layout

     ## and the inverses
\end_layout

\begin_layout Plain Layout

     erfinv <- function (x) qnorm((1 + x)/2)/sqrt(2)
\end_layout

\begin_layout Plain Layout

     erfcinv <- function (x) qnorm(x/2, lower = FALSE)/sqrt(2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Each Subgroup Has an Assignment}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Choose one of these distributions (T, 
\begin_inset Formula $\chi^{2}$
\end_inset

, Poisson, Uniform, Gamma, Beta, Cauchy, Logistic, Weibull, Binomial, or
 Negative Binomial)
\end_layout

\begin_layout Itemize
Review the help page for that (see below)
\end_layout

\begin_layout Itemize
Run example() for your distribution (may be helpful, maybe not)
\end_layout

\begin_layout Itemize
Run 1 simple set of commands to set the arguments and use the 
\series bold
r
\series default
 variant.
 Create a histogram.
 Here's example demonstrating my use of the normal distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval>>=
\end_layout

\begin_layout Plain Layout

m <- 7
\end_layout

\begin_layout Plain Layout

s <- 3
\end_layout

\begin_layout Plain Layout

N <- 2000
\end_layout

\begin_layout Plain Layout

y <- rnorm(N, m = m, s = s)
\end_layout

\begin_layout Plain Layout

hist(y, breaks = 50, prob = TRUE)
\end_layout

\begin_layout Plain Layout

range(y)
\end_layout

\begin_layout Plain Layout

str(y)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Report to rest of us on following
\end_layout

\begin_deeper
\begin_layout Itemize
is output variable discrete or floating-point numeric?
\end_layout

\begin_layout Itemize
what parameters control the data generator?
\end_layout

\begin_layout Itemize
can you guess what the range of the variable might be (does it have values
 from 
\begin_inset Formula $-\infty$
\end_inset

 to 
\begin_inset Formula $\infty$
\end_inset

, or is it bounded, say, in 
\begin_inset Formula $(0,\infty]$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
T distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helptrt, eval=F>>=
\end_layout

\begin_layout Plain Layout

?rt
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $\chi^{2}$
\end_inset

 distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helprchisq, eval=F>>=
\end_layout

\begin_layout Plain Layout

?rchisq
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Poisson distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helprpois, eval=F>>=
\end_layout

\begin_layout Plain Layout

?rpois
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Uniform distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helprunif, eval=F>>=
\end_layout

\begin_layout Plain Layout

?runif
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Gamma distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helprgamma, eval=F>>=
\end_layout

\begin_layout Plain Layout

?rgamma
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Beta distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helprbeta, eval=F>>=
\end_layout

\begin_layout Plain Layout

?rbeta
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Cauchy distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helprcauchy, eval=F>>=
\end_layout

\begin_layout Plain Layout

?rcauchy
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Logistic distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helprlogis,eval=F>>=
\end_layout

\begin_layout Plain Layout

?rlogis
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Weibull distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helprweibull,eval=F>>=
\end_layout

\begin_layout Plain Layout

?rweibull
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
binomial distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helpbinom, eval=F>>=
\end_layout

\begin_layout Plain Layout

?rbinom
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Negative binomial distribution
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<helprnbinom, eval=F>>=
\end_layout

\begin_layout Plain Layout

?rnbinom
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Binomial Distribution
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Binomial distribution}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The number of 
\begin_inset Quotes eld
\end_inset

Yes
\begin_inset Quotes erd
\end_inset

 answers in a sequence of 
\begin_inset Quotes eld
\end_inset

Yes
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

No
\begin_inset Quotes erd
\end_inset

 trials with fixed probability of 
\begin_inset Quotes eld
\end_inset

Yes
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Represents coin flips 
\begin_inset Quotes eld
\end_inset

Heads
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Tails
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Conduct 10 flips with a fair coin, count number of Heads.
\end_layout

\begin_deeper
\begin_layout Standard
Do that over and over, a total of 
\begin_inset Formula $N=100$
\end_inset

 times
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom100>>=
\end_layout

\begin_layout Plain Layout

size <- 10
\end_layout

\begin_layout Plain Layout

prob <- 0.5
\end_layout

\begin_layout Plain Layout

N <- 100
\end_layout

\begin_layout Plain Layout

y <- rbinom(n = 100, size = size, prob = prob)
\end_layout

\begin_layout Plain Layout

y
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
What is the distribution of outcomes?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom200>>=
\end_layout

\begin_layout Plain Layout

table(y)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{I forgot to set the random generator's initial state}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom210>>=
\end_layout

\begin_layout Plain Layout

set.seed(234234)
\end_layout

\begin_layout Plain Layout

y1 <- rbinom(n = 100, size = size, prob = prob)
\end_layout

\begin_layout Plain Layout

head(y1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom220>>=
\end_layout

\begin_layout Plain Layout

set.seed(234234)
\end_layout

\begin_layout Plain Layout

y2 <- rbinom(n = 100, size = size, prob = prob)
\end_layout

\begin_layout Plain Layout

head(y2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Bernoulli Trials}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We have 
\begin_inset Formula $N$
\end_inset

 random samples and each one uses a collection of 
\begin_inset Formula $size$
\end_inset

 random draws.
\end_layout

\begin_layout Itemize
A Bernoulli trial is a sample of 
\begin_inset Formula $N$
\end_inset

 observations in which the size is restricted to 1.
\end_layout

\begin_layout Itemize
Bernoulli is the base distribution of logit/probit models, each observation
 is a draw from a TRUE/FALSE outcome.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Two ways to think about Bernoulli Trials}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I'll do 1000 samples, each of size 1, with prob = 0.4.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom230>>=
\end_layout

\begin_layout Plain Layout

N <- 1000
\end_layout

\begin_layout Plain Layout

size <- 1
\end_layout

\begin_layout Plain Layout

prob <- 0.4
\end_layout

\begin_layout Plain Layout

y1 <- rbinom(N, size, prob)
\end_layout

\begin_layout Plain Layout

head(y1)
\end_layout

\begin_layout Plain Layout

## The total number of 1's is
\end_layout

\begin_layout Plain Layout

sum(y1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I'll draw 1 sample, with size 1000, with prob = 0.4
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom240>>=
\end_layout

\begin_layout Plain Layout

N <- 1
\end_layout

\begin_layout Plain Layout

size <- 1000
\end_layout

\begin_layout Plain Layout

y2 <- rbinom(N, size, prob)
\end_layout

\begin_layout Plain Layout

y2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
What's the difference?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{One Application: Modeling Rare Events}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Celiac disease affects 1% of the population.
 We will draw one sample with size = 10
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom270>>=
\end_layout

\begin_layout Plain Layout

 rbinom(1, size = 10, prob = .01)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
How many would we expect in a random sample of 100 people? 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom280>>=
\end_layout

\begin_layout Plain Layout

rbinom(1, size = 100, prob = .01)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
How many are found in a random sample of 1000 people? 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom290>>=
\end_layout

\begin_layout Plain Layout

rbinom(1, size = 1000, prob = .01)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
As size gets larger, the sample size drawn should get closer and closer
 to 
\begin_inset Formula $prob\times size$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Check that with a little simulation study}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I'll create 4 sets of draws with 4 values of the size parameter
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom300>>=
\end_layout

\begin_layout Plain Layout

N <- 2000
\end_layout

\begin_layout Plain Layout

size1 <- 10
\end_layout

\begin_layout Plain Layout

size2 <- 100
\end_layout

\begin_layout Plain Layout

size3 <- 1000
\end_layout

\begin_layout Plain Layout

size4 <- 10000
\end_layout

\begin_layout Plain Layout

ohone <- 0.01 ## a joke!
\end_layout

\begin_layout Plain Layout

y1 <- rbinom(N, size1, prob = ohone)
\end_layout

\begin_layout Plain Layout

y2 <- rbinom(N, size2, prob = ohone)
\end_layout

\begin_layout Plain Layout

y3 <- rbinom(N, size3, prob = ohone)
\end_layout

\begin_layout Plain Layout

y4 <- rbinom(N, size4, prob = ohone)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Convert output to proportions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom310>>=
\end_layout

\begin_layout Plain Layout

## Convert to proportions
\end_layout

\begin_layout Plain Layout

y1p <- y1/size1
\end_layout

\begin_layout Plain Layout

head(y1p)
\end_layout

\begin_layout Plain Layout

y2p <- y2/size2
\end_layout

\begin_layout Plain Layout

head(y2p)
\end_layout

\begin_layout Plain Layout

y3p <- y3/size3
\end_layout

\begin_layout Plain Layout

head(y3p)
\end_layout

\begin_layout Plain Layout

y4p <- y4/size4
\end_layout

\begin_layout Plain Layout

head(y4p)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Make a nice plot
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom320, fig=T>>=
\end_layout

\begin_layout Plain Layout

y1p.range <- range(y1p)
\end_layout

\begin_layout Plain Layout

par(mfcol = c(2,2))
\end_layout

\begin_layout Plain Layout

hist(y1p, prob = TRUE, xlim = y1p.range, breaks=50, main = paste("Size =",
 size1))
\end_layout

\begin_layout Plain Layout

hist(y2p, prob = TRUE, xlim = y1p.range, breaks=50, main = paste("Size =",
 size2))
\end_layout

\begin_layout Plain Layout

hist(y3p, prob = TRUE, xlim = y1p.range, breaks=50, main = paste("Size =",
 size3))
\end_layout

\begin_layout Plain Layout

hist(y4p, prob = TRUE, xlim = y1p.range, breaks=50, main = paste("Size =",
 size4))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{If You Were Doing that For Real, I'd tighten it up}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rbinom340>>=
\end_layout

\begin_layout Plain Layout

N <- 2000
\end_layout

\begin_layout Plain Layout

size <- c(10, 100, 1000, 10000)
\end_layout

\begin_layout Plain Layout

ohone <- 0.01 ## a joke!
\end_layout

\begin_layout Plain Layout

for(j in seq_along(size)){
\end_layout

\begin_layout Plain Layout

	y <- rbinom(N, size[j], prob = ohone)
\end_layout

\begin_layout Plain Layout

    yname <- paste0("y", j)
\end_layout

\begin_layout Plain Layout

    assign(yname, y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
assign()
\end_layout

\end_inset

 puts the variables y1, y2, y3, y4 in the global workspace, which is rather
 careless
\end_layout

\begin_layout Itemize
I'd convert the output to a matrix in either
\end_layout

\begin_deeper
\begin_layout Itemize
wide format: 
\begin_inset Formula $y$
\end_inset

 with 
\begin_inset Formula $N$
\end_inset

 rows and #{size} columns, or
\end_layout

\begin_layout Itemize
long format: 
\begin_inset Formula $N\times\#\{size\}$
\end_inset

rows and 2 columns (1 column 
\begin_inset Formula $size$
\end_inset

 and 1 column 
\begin_inset Quotes eld
\end_inset

stacked 
\begin_inset Formula $y$
\end_inset


\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Will discuss designing output
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Normal distribution
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Normal distribution}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Most of us are familiar with at least a few special cases of the general
 linear model: regression, correlation, t tests, ANOVA.
\end_layout

\begin_layout Itemize
These assume a normally distributed outcome (at least, a normal residual
 term).
\end_layout

\begin_layout Itemize
These models assert the error term is normally distributed with a standard
 deviation of some number 
\begin_inset Formula $\sigma$
\end_inset

 and expected value 0.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm50>>=
\end_layout

\begin_layout Plain Layout

sigma <- 3
\end_layout

\begin_layout Plain Layout

mu <- 0
\end_layout

\begin_layout Plain Layout

error <- rnorm(100, m = mu, s = sigma)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm60>>=
\end_layout

\begin_layout Plain Layout

head(error)
\end_layout

\begin_layout Plain Layout

mean(error)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The normal distribution is most often written down as 
\begin_inset Formula $N(\mu,\sigma^{2})$
\end_inset

 , (in words 
\begin_inset Formula $N(mu,sigma^{2})$
\end_inset

), we are thinking of the parameters as the expected value and variance
\end_layout

\begin_layout Itemize
In Bayesian software like BUGS and JAGS, they say the second parameter is
 
\begin_inset Formula $1/\sigma^{2}$
\end_inset

.
 They call that precision, writing 
\begin_inset Formula $N(\mu,\tau)$
\end_inset

 for 
\begin_inset Formula $\tau=1/\sigma^{2}$
\end_inset


\end_layout

\begin_layout Itemize
In Bayesian software Stan, they differ again, referring to the normal by
 expected value and standard deviation, 
\begin_inset Formula $N(\mu,\sigma)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Normal distribution defaults}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The R rnorm default parameters are m=0 and s=1
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm80>>=
\end_layout

\begin_layout Plain Layout

y <- rnorm(10)
\end_layout

\begin_layout Plain Layout

head(y)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These are commonly called Z scores.
 Referred to as a 
\begin_inset Quotes eld
\end_inset

standard normal
\begin_inset Quotes erd
\end_inset

 distribution.
\end_layout

\begin_layout Itemize
In many programs, one can only draw from N(0,1) and then manually rescale
 with the desired mean and standard deviation.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $e_{i}$
\end_inset

 is a draw from N(0,1), we can manufacture 
\begin_inset Formula $N(m,s^{2})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
y_{i}=mu+sigma\cdot e_{i}
\]

\end_inset


\end_layout

\begin_layout Itemize
In R, it is usually not necessary to do that re-scaling manually because
 we can specify the expected value and standard deviation parameters.
\end_layout

\begin_layout Itemize
Example, IQ scores
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm90>>=
\end_layout

\begin_layout Plain Layout

y <- rnorm(10, m = 100, s = 15)
\end_layout

\begin_layout Plain Layout

head(y)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
A large enough sample should look 
\begin_inset Quotes eld
\end_inset

normal
\begin_inset Quotes erd
\end_inset

, somewhat like the probability density function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm100, fig=T>>=
\end_layout

\begin_layout Plain Layout

mu <- 100
\end_layout

\begin_layout Plain Layout

sigma <- 15
\end_layout

\begin_layout Plain Layout

N <- 150
\end_layout

\begin_layout Plain Layout

x <- rnorm(N, mean = mu, sd = sigma)
\end_layout

\begin_layout Plain Layout

hist(x, prob = TRUE, main = "IQ Scores", xlab = "IQ", col = "grey70", breaks
 = 30)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Do the sample statistics match the population parameters?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm110>>=
\end_layout

\begin_layout Plain Layout

## Using x again, sample of N
\end_layout

\begin_layout Plain Layout

mu
\end_layout

\begin_layout Plain Layout

mean(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm120>>=
\end_layout

\begin_layout Plain Layout

sigma
\end_layout

\begin_layout Plain Layout

sd(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Questions
\end_layout

\begin_deeper
\begin_layout Enumerate
Why don't they match exactly? 
\end_layout

\begin_layout Enumerate
What would make them match more closely?
\end_layout

\end_deeper
\begin_layout Itemize
Bigger sample!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm105, fig=T>>=
\end_layout

\begin_layout Plain Layout

x.1000 <- rnorm(1000, mean = mu, sd = sigma)
\end_layout

\begin_layout Plain Layout

hist(x.1000, prob = TRUE, main = "IQ Scores", xlab = "IQ", col = "grey70",
 breaks = 30)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{That's what Statistics is All About!}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Quantify how much we expect the sample mean to differ from the population
 parameter.
\end_layout

\begin_layout Itemize
Remember the standard error? 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
SE=\frac{SD}{sqrt(N)}
\]

\end_inset


\end_layout

\begin_layout Itemize
If the standard deviation is 15 and the sample size is 150, we expect SE
 to be the standard deviations of the estimates of the mean
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm130>>=
\end_layout

\begin_layout Plain Layout

sigma <- 15
\end_layout

\begin_layout Plain Layout

N <- 150
\end_layout

\begin_layout Plain Layout

stderr.theoretical <- sigma / sqrt(N)
\end_layout

\begin_layout Plain Layout

stderr.theoretical
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{What exactly is the SE? Let's use a Monte Carlo investigation}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
To illustrate using Monte Carlo methods, we can draw several random samples
 of N = 150 from the same data generating process (e.g., 
\begin_inset Quotes eld
\end_inset

population
\begin_inset Quotes erd
\end_inset

), saving the mean from each one.
 
\end_layout

\begin_layout Itemize
First, write a very simple function that will do this for one replication:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm140>>=
\end_layout

\begin_layout Plain Layout

getSampleMean <- function(rep, N, M, SD){ 
\end_layout

\begin_layout Plain Layout

    ## rep is an unused parameter, a place-holder
\end_layout

\begin_layout Plain Layout

    x <- rnorm(N, mean = M, sd = SD)
\end_layout

\begin_layout Plain Layout

    mean(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the function arguments can have any name we want
\end_layout

\begin_layout Itemize
now apply it once to check that it works
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<norm150>>=
\end_layout

\begin_layout Plain Layout

# Recall
\end_layout

\begin_layout Plain Layout

N
\end_layout

\begin_layout Plain Layout

mu
\end_layout

\begin_layout Plain Layout

sigma
\end_layout

\begin_layout Plain Layout

getSampleMean(1, N, mu, sigma)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
OK, now apply it 10,000 times (estimates of mu are called muhat here, 
\begin_inset Formula $\hat{\mu}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

set.seed(123)
\end_layout

\begin_layout Plain Layout

muhat <- vapply(1:10000, getSampleMean, N = 150, M = mu, SD = sigma, numeric(1))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
print the first few means to see if it looks like the output you expected
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

head(muhat)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
What is the mean of the sample means?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

muhatmean <- mean(muhat)
\end_layout

\begin_layout Plain Layout

muhatmean
\end_layout

\begin_layout Plain Layout

mu
\end_layout

\begin_layout Plain Layout

mu - muhatmean
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pretty close! Mean of means approaches true mu as N approaches infinity
\end_layout

\end_deeper
\begin_layout Itemize
What is the SD of the sample means?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

muhatsd <- sd(muhat)
\end_layout

\begin_layout Plain Layout

stderr.theoretical
\end_layout

\begin_layout Plain Layout

muhatsd - stderr.theoretical
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
pretty close! SD of means approaches SE as N approaches infinity
\end_layout

\end_deeper
\begin_layout Itemize
What's the point of this? 
\end_layout

\begin_deeper
\begin_layout Itemize
Just to test whether the formula for SE works? Maybe
\end_layout

\begin_layout Itemize
Well, we drew random NORMAL numbers, so we would expect the normal-theory
 formula for SE to work.
 
\end_layout

\begin_layout Itemize
Can now ask, 
\begin_inset Quotes eld
\end_inset

What if that assumption were violated?
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Violations of the Normality Assumption}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Suppose we were studying exam scores, with a ceiling effect at 100.
\end_layout

\begin_layout Itemize
Re-design previous function to return a vector (rep, mean, std.dev, std.err.)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

getEstimates <- function(rep, N, M, SD) {
\end_layout

\begin_layout Plain Layout

    x <- rnorm(N, mean = M, sd = SD)
\end_layout

\begin_layout Plain Layout

    x <- ifelse(x > 100, 100, x)
\end_layout

\begin_layout Plain Layout

    c(rep = rep, mean = mean(x), sd = sd(x), sterr = sd(x)/sqrt(N))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

set.seed(123)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
the estimates are returned as a matrix that has 4 rows and one column per
 replication.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

## Recall
\end_layout

\begin_layout Plain Layout

mu
\end_layout

\begin_layout Plain Layout

sigma
\end_layout

\begin_layout Plain Layout

trunc.hat <- vapply(1L:10000L, getEstimates, N = 150, M = mu, SD = sigma,
 numeric(4))
\end_layout

\begin_layout Plain Layout

trunc.hat[ , 1:3]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
With sample of 150, the standard formula for the standard error of the mean
 is 
\begin_inset Formula $SD/\sqrt{150}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

(trunc.mean <- mean(trunc.hat[2, ]))
\end_layout

\begin_layout Plain Layout

## Empirical standard error of the mean is:
\end_layout

\begin_layout Plain Layout

(trunc.mean.sd <- sd(trunc.hat[2, ]))
\end_layout

\begin_layout Plain Layout

## Mean of within sample estimates of stardard error:
\end_layout

\begin_layout Plain Layout

(trunc.se.mean <- mean(trunc.hat[4, ]))
\end_layout

\begin_layout Plain Layout

## Theory-based std.err based using parameters (ignoring trunctation)
\end_layout

\begin_layout Plain Layout

stderr.theory <- sigma/sqrt(N)
\end_layout

\begin_layout Plain Layout

stderr.theory
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The normal theory-based standard error is much higher than the observed
 standard deviation of the means.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generating Samples: Regression
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Generating random samples from population parameters}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Basic regression model
\end_layout

\begin_layout Itemize
we want to ensure that our regression model is estimating a slope properly.
\end_layout

\begin_layout Itemize
generate data from a population space where the regression slope for X predictin
g Y is known.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reg100>>=
\end_layout

\begin_layout Plain Layout

## Generate 100 cases
\end_layout

\begin_layout Plain Layout

N <- 100
\end_layout

\begin_layout Plain Layout

## X is normally distributed with a mean of 0 and a sd of 10
\end_layout

\begin_layout Plain Layout

## Y = b0 + b1*X + e
\end_layout

\begin_layout Plain Layout

b0 <- 30
\end_layout

\begin_layout Plain Layout

b1 <- 2
\end_layout

\begin_layout Plain Layout

e.sigma <- 5
\end_layout

\begin_layout Plain Layout

x.mu <- 0
\end_layout

\begin_layout Plain Layout

x.sigma <- 5
\end_layout

\begin_layout Plain Layout

## e = N(0, e.sigma^2)
\end_layout

\begin_layout Plain Layout

error <- rnorm(N, 0, e.sigma)
\end_layout

\begin_layout Plain Layout

x <- rnorm(N, x.mu, x.sigma)
\end_layout

\begin_layout Plain Layout

dtest <- data.frame(x = x,
\end_layout

\begin_layout Plain Layout

                    y = b0 + b1 * x + error,
\end_layout

\begin_layout Plain Layout

                    ynoe = b0 + b1 * x)
\end_layout

\begin_layout Plain Layout

head(dtest)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reg110>>=
\end_layout

\begin_layout Plain Layout

m1 <- lm(y ~ x, data = dtest)
\end_layout

\begin_layout Plain Layout

m1.summary <- summary(m1) ## Save summary in object for later
\end_layout

\begin_layout Plain Layout

m1.summary
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reg120>>=
\end_layout

\begin_layout Plain Layout

rockchalk::plotSlopes(m1, plotx = "x")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
When estimating regressions, understand the data structures they generate
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reg130>>=
\end_layout

\begin_layout Plain Layout

names(m1)
\end_layout

\begin_layout Plain Layout

coef(m1) ## just the betas
\end_layout

\begin_layout Plain Layout

names(m1.summary)
\end_layout

\begin_layout Plain Layout

coef(m1.summary) ## Parameter table
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
What if the variance of the error term is larger?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reg300>>=
\end_layout

\begin_layout Plain Layout

ehuge <- rnorm(NROW(dtest), 0, 50)
\end_layout

\begin_layout Plain Layout

dtest$yhuge <- b0 + b1 * dtest$x + ehuge
\end_layout

\begin_layout Plain Layout

m3 <- lm(yhuge ~ x, dtest)
\end_layout

\begin_layout Plain Layout

summary(m3)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reg310,fig=T>>=
\end_layout

\begin_layout Plain Layout

rockchalk::plotSlopes(m3, plotx = "x")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
What if we forget the error term?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reg200>>=
\end_layout

\begin_layout Plain Layout

m2 <- lm(ynoe ~ x, data = dtest)
\end_layout

\begin_layout Plain Layout

summary(m2)
\end_layout

\begin_layout Plain Layout

## Generates a warning
\end_layout

\begin_layout Plain Layout

## Warning message: In summary.lm(m2) : essentially perfect fit: summary
 may be ## unreliable
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Generating Samples: Group Mean Differences
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Group mean differences}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is evidence that birth order (social more than biological) affects
 IQ (doi:10.1126/science.1141493).
 
\end_layout

\begin_layout Itemize
We'll create data with the predictor 
\begin_inset Quotes eld
\end_inset

first
\begin_inset Quotes erd
\end_inset

 (1 = first-born, 0 = not), and
\end_layout

\begin_layout Itemize
the true mean difference between those two populations is 5 IQ points.
\end_layout

\begin_layout Itemize
Group 1 is the first-born group, for which the mean is 103, while the mean
 for Group 0, the the ones who are not first born, is 98.
 The standard deviations within the 2 groups are equal to 15.
\end_layout

\begin_layout Itemize
Mean of group 1 can either be thought of as 
\begin_inset Formula 
\[
98+5
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
so 98 is the mean for humans and 5 is a bonus for first borns.
\end_layout

\end_deeper
\begin_layout Itemize
Suppose that 40% of children are first-borns.
 (60% of children are 2nd or subsequent).
\end_layout

\begin_layout Itemize
The expected value of the IQ score for the entire population is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
.4*103+.6*98
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
First, I have un-structured code that works
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<first100>>=
\end_layout

\begin_layout Plain Layout

## Two groups, first = 0 or 1
\end_layout

\begin_layout Plain Layout

set.seed(123)
\end_layout

\begin_layout Plain Layout

firstprop <- 0.4
\end_layout

\begin_layout Plain Layout

dat <- data.frame(first = rbinom(n = 100, size = 1, prob = firstprop))
\end_layout

\begin_layout Plain Layout

## We have just assigned rows of data into groups labeled 1 and 0
\end_layout

\begin_layout Plain Layout

head(dat)
\end_layout

\begin_layout Plain Layout

## Now we sample IQ scores, taking group membership into account.
\end_layout

\begin_layout Plain Layout

## Here we use vectorized inputs to the data generator
\end_layout

\begin_layout Plain Layout

dat$IQ <- rnorm(NROW(dat), m = 98 + 5 * dat$first, sd = 15)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## round to nearest whole number, since that is how IQ scores are
\end_layout

\begin_layout Plain Layout

## reported
\end_layout

\begin_layout Plain Layout

dat$IQ <- round(dat$IQ)
\end_layout

\begin_layout Plain Layout

head(dat, 10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Test out various estimators, note results are all equivalent
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<first110>>=
\end_layout

\begin_layout Plain Layout

## Do the sample statistics match the data generator (population) parameters?
\end_layout

\begin_layout Plain Layout

## Several convenient ways to retrieve the answers
\end_layout

\begin_layout Plain Layout

m1 <- lm(IQ ~ first, data = dat)
\end_layout

\begin_layout Plain Layout

summary(m1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Or
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

t.test(IQ ~ first, data = dat)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Or
\end_layout

\begin_layout Plain Layout

aggregate(IQ ~ first, data = dat,
\end_layout

\begin_layout Plain Layout

          FUN = function(x) c(M = mean(x), SD = sd(x)))
\end_layout

\begin_layout Plain Layout

## I'm sure we could find a more tedious way to get group differences, but
 this is near the maximum
\end_layout

\begin_layout Plain Layout

diff(aggregate(IQ ~ first, data = dat, mean)$IQ)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Plan a Monte Carlo Study}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We expect sampling variability, so the observed group difference will not
 be exactly 5
\end_layout

\begin_layout Itemize
And it isn't
\end_layout

\begin_layout Itemize
Let's use Monte Carlo methods to find out how much the mean-difference varies
\end_layout

\begin_layout Itemize
I prefer to think of any MC exercise as 3 chores
\end_layout

\begin_deeper
\begin_layout Enumerate
Write a data-generator function
\end_layout

\begin_layout Enumerate
Write a function that analyzes a data set
\end_layout

\begin_layout Enumerate
Write a function that orchestrates the first 2 functions.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Here's my data generator
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Rsize{
\backslash
scriptsize}
\end_layout

\begin_layout Plain Layout

<<first120>>=
\end_layout

\begin_layout Plain Layout

##' Create one data set for the first born question
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' This uses a vectorized call to rnorm
\end_layout

\begin_layout Plain Layout

##' @param rep Integer to name repetition
\end_layout

\begin_layout Plain Layout

##' @param N Sample Size
\end_layout

\begin_layout Plain Layout

##' @param M1 Mean of first born group
\end_layout

\begin_layout Plain Layout

##' @param M0 Mean of non-first born group
\end_layout

\begin_layout Plain Layout

##' @param SD1 Standard Deviation of first born
\end_layout

\begin_layout Plain Layout

##' @param SD0 Standard Deviation of non-first born
\end_layout

\begin_layout Plain Layout

##' @return A data frame
\end_layout

\begin_layout Plain Layout

##' @author Paul Johnson
\end_layout

\begin_layout Plain Layout

## define a data-generator function for one replication
\end_layout

\begin_layout Plain Layout

getData <- function(rep, N, M1, M0, SD1, SD0) {
\end_layout

\begin_layout Plain Layout

    dat <- data.frame(first = rbinom(n = N, size = 1, prob = .4))
\end_layout

\begin_layout Plain Layout

    dat$rep <- rep
\end_layout

\begin_layout Plain Layout

    dat$IQ <- rnorm(N, m = M0 + dat$first * (M1 - M0), 
\end_layout

\begin_layout Plain Layout

                       s = SD0 + dat$first * (SD1 - SD0))
\end_layout

\begin_layout Plain Layout

    dat$IQ <- round(dat$IQ)
\end_layout

\begin_layout Plain Layout

    dat
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Here's the analysis function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<first130>>=
\end_layout

\begin_layout Plain Layout

##' Calculate difference between groups
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' This setup is lazy because it assumes the names
\end_layout

\begin_layout Plain Layout

##' of the variables are simply "first" and "IQ".
 
\end_layout

\begin_layout Plain Layout

##' I'd never do this in a real project.
\end_layout

\begin_layout Plain Layout

##' @param dframe a data frame with input data
\end_layout

\begin_layout Plain Layout

##' @return A floating point number for the difference
\end_layout

\begin_layout Plain Layout

getDiff <- function(dframe){
\end_layout

\begin_layout Plain Layout

    diff(aggregate(IQ ~ first, data = dframe, mean)$IQ)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Test that
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<first140>>=
\end_layout

\begin_layout Plain Layout

## try it on one replication first
\end_layout

\begin_layout Plain Layout

dat1 <- getData(1, N = 100, M1 = 103, M0 = 98, SD1 = 15, SD0 = 15)
\end_layout

\begin_layout Plain Layout

getDiff(dat1)
\end_layout

\begin_layout Plain Layout

##
\end_layout

\begin_layout Plain Layout

## Combine into 1 step if we don't want to save the data
\end_layout

\begin_layout Plain Layout

getDiff(getData(1, N = 100, M1 = 103, M0 = 98, SD1 = 15, SD0 = 15))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I'd run in debugger to make sure everything looks correct
\end_layout

\begin_layout Itemize
Do that lots of times
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<first150>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Make a wrapper function
\end_layout

\begin_layout Plain Layout

oneSim <- function(rep, N = 100, M1 = 103, M0 = 98, SD1 = 15, SD0 = 15){
\end_layout

\begin_layout Plain Layout

   getDiff(getData(1, N = N, M1 = M1, M0 = M0, SD1 = SD1, SD0 = SD0))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## now do it 2000 times
\end_layout

\begin_layout Plain Layout

## vapply here not different from R's replicate, but we have
\end_layout

\begin_layout Plain Layout

## more control
\end_layout

\begin_layout Plain Layout

set.seed(123)
\end_layout

\begin_layout Plain Layout

myMeanDiffs <- vapply(1:2000, oneSim, N = 100,
\end_layout

\begin_layout Plain Layout

                      M1 = 103, M0 = 98, SD1 = 15, SD0 = 15,
\end_layout

\begin_layout Plain Layout

                      numeric(1))
\end_layout

\begin_layout Plain Layout

## check results
\end_layout

\begin_layout Plain Layout

mean(myMeanDiffs)
\end_layout

\begin_layout Plain Layout

sd(myMeanDiffs)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
What did we find out?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<first200, fig=T>>=
\end_layout

\begin_layout Plain Layout

hist(myMeanDiffs, prob = TRUE, breaks = 30)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
T-test replication
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Remember the assumptions of a t-test?}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
T-test for difference of means historically assumed
\end_layout

\begin_layout Itemize
equal variances (or SD) in each group (called homoscedasticity)
\end_layout

\begin_layout Itemize
normally distributed data
\end_layout

\begin_layout Itemize
independent (uncorrelated) observations randomly sampled
\end_layout

\begin_layout Standard
Perhaps you've also heard that a t-test is "robust" to a moderate violation
 of normality
\end_layout

\begin_layout Itemize
You'll make about as many Type I errors with moderately non-normal data
 as you would with normal data.
\end_layout

\begin_layout Itemize
The t-test is also somewhat robust to heteroscedasticity (different variances),
 as long as the sample sizes are roughly equal.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Remember the assumptions of a t-test?}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Let's design a simulation to see what the effects of these factors are on
 the result of a t-test.
\end_layout

\begin_layout Itemize
Research question: Does violating these assumptions increase the probability
 of making a Type I error.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Problem: User interface for simulation}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Many years ago (when you were infants), some CRMDA GRAs decided to write
 a simulator that would receive parameters as colon-separated strings.
 
\end_layout

\begin_layout Itemize
For example, they would want to provide a parameter in a string like 
\begin_inset Quotes eld
\end_inset

40:20
\begin_inset Quotes erd
\end_inset

 and they wanted that to turn into a vector c(40, 20).
\end_layout

\begin_layout Itemize
First, we need to explore some string magic
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t100>>=
\end_layout

\begin_layout Plain Layout

x <- "40:20"
\end_layout

\begin_layout Plain Layout

strsplit(x, ":")
\end_layout

\begin_layout Plain Layout

## It is wrapped in an R list
\end_layout

\begin_layout Plain Layout

unlist(strsplit(x, ":"))
\end_layout

\begin_layout Plain Layout

## It is still characters, need numbers
\end_layout

\begin_layout Plain Layout

as.numeric(unlist(strsplit(x, ":")))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Create a function that can receive those strings for N, M and SD.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t110>>=
\end_layout

\begin_layout Plain Layout

## Define a function for one replication
\end_layout

\begin_layout Plain Layout

getTdata <- function(rep, N, M, SD) {
\end_layout

\begin_layout Plain Layout

    ## tease apart two sample sizes
\end_layout

\begin_layout Plain Layout

    Nvec <- as.numeric(unlist(strsplit(N, ":")))
\end_layout

\begin_layout Plain Layout

    ## tease apart two means
\end_layout

\begin_layout Plain Layout

    Mvec <- as.numeric(unlist(strsplit(M, ":")))
\end_layout

\begin_layout Plain Layout

    ## tease apart two SDs
\end_layout

\begin_layout Plain Layout

    SDvec <- as.numeric(unlist(strsplit(SD, ":")))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    ## assign dummy variables to each group's data set
\end_layout

\begin_layout Plain Layout

    dat <- data.frame(first = c(rep(0, times = Nvec[1]),
\end_layout

\begin_layout Plain Layout

                            rep(1, times = Nvec[2])))
\end_layout

\begin_layout Plain Layout

    ## generate random IQ scores
\end_layout

\begin_layout Plain Layout

    dat$IQ <- rnorm(sum(Nvec), m = Mvec[(dat$first + 1)], 
\end_layout

\begin_layout Plain Layout

                     sd = SDvec[(dat$first + 1)])
\end_layout

\begin_layout Plain Layout

    dat$IQ <- round(dat$IQ)
\end_layout

\begin_layout Plain Layout

    attr(dat, "rep") <- rep
\end_layout

\begin_layout Plain Layout

    attr(dat, "parms") <- c(N = N, M = M, SD = SD)
\end_layout

\begin_layout Plain Layout

    dat
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t120>>=
\end_layout

\begin_layout Plain Layout

## Test
\end_layout

\begin_layout Plain Layout

dframe1 <- getTdata(1, N = "30:30", M = "98:102", SD = "15:15")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I've used attributes to store copies of the rep number and the parms, in
 case I wanted to do record keeping
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t130>>=
\end_layout

\begin_layout Plain Layout

## Note the attributes stored with the data frame:
\end_layout

\begin_layout Plain Layout

attributes(dframe1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Individual attributes can be retrieved
\end_layout

\begin_layout Plain Layout

attr(dframe1, "rep")
\end_layout

\begin_layout Plain Layout

attr(dframe1, "parms")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The analysis function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t140>>=
\end_layout

\begin_layout Plain Layout

##' A small wrapper to calculate a t-test
\end_layout

\begin_layout Plain Layout

##' @param dframe A data frame
\end_layout

\begin_layout Plain Layout

##' @param y character string for name of dependent variable.
 Default is "IQ"
\end_layout

\begin_layout Plain Layout

##' @param x character string for name of independent variable.
 Default is "first"
\end_layout

\begin_layout Plain Layout

##' @return We return only the p-value.
 
\end_layout

\begin_layout Plain Layout

conductTtest <- function (dframe, y = "IQ", x = "first"){
\end_layout

\begin_layout Plain Layout

 	t.test(formula(paste(y, "~", x)), data = dframe, var.equal = TRUE)$p.value
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Test it once, wrapping 2 function calls together
\end_layout

\begin_layout Plain Layout

conductTtest(getTdata(1, N = "30:30", M = "98:103", SD = "15:15"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Create a one-step wrapper to put those together
\end_layout

\begin_layout Plain Layout

runOneSim <- function(nreps, N, M, SD){
\end_layout

\begin_layout Plain Layout

    df <- getTdata(1, N = "30:30", M = "98:103", SD = "15:15")
\end_layout

\begin_layout Plain Layout

    reslt <- conductTtest(df)
\end_layout

\begin_layout Plain Layout

    reslt
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t160>>=
\end_layout

\begin_layout Plain Layout

## Now apply it 10 times to see the format of the output
\end_layout

\begin_layout Plain Layout

sim10 <- sapply(1:10, runOneSim, N = "30:30", M = "98:103", SD = "15:15")
\end_layout

\begin_layout Plain Layout

sim10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Oops, I did not snatch the attributes for records.
 
\end_layout

\begin_layout Plain Layout

## Oops, I also forgot to store the rejection decision, so insert it
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

runOneSim <- function(rep, N, M, SD){
\end_layout

\begin_layout Plain Layout

    dframe <- getTdata(rep, N = N, M = M, SD = SD)
\end_layout

\begin_layout Plain Layout

    reslt <- conductTtest(dframe)
\end_layout

\begin_layout Plain Layout

    parms <- attr(dframe, "parms")
\end_layout

\begin_layout Plain Layout

    dframe2 <- data.frame(rep = attr(dframe, "rep"), 
\end_layout

\begin_layout Plain Layout

               pvalue = reslt, reject = if (reslt <= 0.05) 1 else 0,
\end_layout

\begin_layout Plain Layout

               N = parms["N"], M = parms["M"], SD = parms["SD"])
\end_layout

\begin_layout Plain Layout

	dframe2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## test that
\end_layout

\begin_layout Plain Layout

runOneSim(1, N = "30:30", M = "98:103", SD = "15:15")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t180>>=
\end_layout

\begin_layout Plain Layout

## Returns a list of one row data frames
\end_layout

\begin_layout Plain Layout

set.seed(123)
\end_layout

\begin_layout Plain Layout

nReps <- 1000
\end_layout

\begin_layout Plain Layout

result.list <- lapply(1:nReps, runOneSim, N = "30:30", M = "98:103", SD =
 "15:15")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Smash those down into one data frame with 1 row
\end_layout

\begin_layout Plain Layout

## per replication
\end_layout

\begin_layout Plain Layout

result.df <- do.call("rbind", result.list)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mean(result.df$reject)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t190, fig=T>>=
\end_layout

\begin_layout Plain Layout

plot(result.df$pvalue, result.df$reject)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Explore range of conditions}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
R has a magic function named 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
expand.grid
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
It is easier to display it than to describe it.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t200>>=
\end_layout

\begin_layout Plain Layout

expand.grid(x = c("a", "b", "c"), y = c("j", "k"), z = c(1, 2, 3))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
What did we get
\end_layout

\begin_deeper
\begin_layout Itemize
a 
\begin_inset Quotes eld
\end_inset

mix and match
\begin_inset Quotes erd
\end_inset

 of elements, one per row
\end_layout

\end_deeper
\begin_layout Itemize
Caution: It turned our character strings into factors:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t220>>=
\end_layout

\begin_layout Plain Layout

eg <- expand.grid(x = c("a", "b", "c"), y = c("j", "k"), z = c(1, 2, 3))
\end_layout

\begin_layout Plain Layout

## In document production, this causes an error.
 Should be OK interactively
\end_layout

\begin_layout Plain Layout

## str(eg)
\end_layout

\begin_layout Plain Layout

lapply(eg, class)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Prevent unwanted creation of R factors
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t240>>=
\end_layout

\begin_layout Plain Layout

eg <- expand.grid(x = c("a", "b", "c"), 
\end_layout

\begin_layout Plain Layout

                  y = c("j", "k"), 
\end_layout

\begin_layout Plain Layout

                  z = c(1, 2, 3),
\end_layout

\begin_layout Plain Layout

                  stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

## str(eg)
\end_layout

\begin_layout Plain Layout

lapply(eg, class)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
In simulations, we usually have vectors of settings.
 We will use expand.grid to 
\begin_inset Quotes eld
\end_inset

mix and match
\begin_inset Quotes erd
\end_inset

 all of them.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Explore range of conditions}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Create a conds data frame to summarize the work to be done
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t260>>=
\end_layout

\begin_layout Plain Layout

## Set a variety of factors and compare p-values
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## We need to choose levels of our predictors (sample size and SD)
\end_layout

\begin_layout Plain Layout

## - equal v.
 unequal group sample sizes
\end_layout

\begin_layout Plain Layout

## - equal v.
 unequal group variances
\end_layout

\begin_layout Plain Layout

## - mean-difference: 0, 5, or 10
\end_layout

\begin_layout Plain Layout

cond.N <- c("30:30", "40:20")
\end_layout

\begin_layout Plain Layout

cond.SD <- c("10:20", "15:15", "20:10")
\end_layout

\begin_layout Plain Layout

cond.M <- c("100:100") # for now, mean-difference = 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## A fully crossed design runs all combinations of these levels.
  This
\end_layout

\begin_layout Plain Layout

## is a 2 (N) by 3 (SD) factorial design, so it has 2 * 3 = 6
\end_layout

\begin_layout Plain Layout

## conditions
\end_layout

\begin_layout Plain Layout

conds <- expand.grid(maxReps = 3, SD = cond.SD, N = cond.N, M = cond.M,
\end_layout

\begin_layout Plain Layout

                     stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

head(conds)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I did not think of an elegant approach, so here's my strategy.
 
\end_layout

\begin_layout Itemize
Create one more function that can receive the conds matrix and pick one
 row out of it.
 Let that function run as many simulations as we need, and return a data.frame.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t280>>=
\end_layout

\begin_layout Plain Layout

##' Tell this function the condition row to use,
\end_layout

\begin_layout Plain Layout

##' and it creates a batch of simulations
\end_layout

\begin_layout Plain Layout

runOneCondition <- function(i, conds){
\end_layout

\begin_layout Plain Layout

   x <- conds[i, ]
\end_layout

\begin_layout Plain Layout

   result.list <- lapply(1:x$maxReps, runOneSim, 
\end_layout

\begin_layout Plain Layout

                 N = x$N, M = x$M, SD = x$SD)
\end_layout

\begin_layout Plain Layout

   do.call("rbind", result.list)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

allResults <- lapply(1:NROW(conds), runOneCondition, conds)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Each sample drawn from a particular population is a "case" (like
\end_layout

\begin_layout Plain Layout

## subjects).
  We can easily combine our list of results as a single
\end_layout

\begin_layout Plain Layout

## data set for analysis
\end_layout

\begin_layout Plain Layout

output <- do.call(rbind, allResults)
\end_layout

\begin_layout Plain Layout

head(output, 30)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Finally, we are ready to run several replications in each condition.
\end_layout

\begin_layout Plain Layout

conds$maxReps <- 1000
\end_layout

\begin_layout Plain Layout

conds
\end_layout

\begin_layout Plain Layout

## Our Monte Carlo study will take a few moments to run
\end_layout

\begin_layout Plain Layout

set.seed(123)
\end_layout

\begin_layout Plain Layout

bigResults <- lapply(1:NROW(conds), runOneCondition, conds)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stackedResults <- do.call(rbind, bigResults)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Now summarize the rejection rate for each condition
\end_layout

\begin_layout Plain Layout

output <- aggregate(reject ~ N + SD, data = stackedResults, FUN = mean)
\end_layout

\begin_layout Plain Layout

names(output) <- c("N", "SD", "Type.I.Rate")
\end_layout

\begin_layout Plain Layout

output
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The findings are sobering for t-testing with unequal sample sizes
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t300>>=
\end_layout

\begin_layout Plain Layout

## How does it perform when sample sizes are equal?
\end_layout

\begin_layout Plain Layout

output[output$N == "30:30",]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Unequal?
\end_layout

\begin_layout Plain Layout

output[output$N != "30:30",]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The corrected version of the t-test.
 Does it reduce the problem?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<t320>>=
\end_layout

\begin_layout Plain Layout

## Since 15 years ago, R's default t-test uses Welch's
\end_layout

\begin_layout Plain Layout

## correction for difference in variance.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## A replacement for the t-test function
\end_layout

\begin_layout Plain Layout

conductTtest <- function (dframe, y = "IQ", x = "first"){
\end_layout

\begin_layout Plain Layout

 	t.test(formula(paste(y, "~", x)), data = dframe)$p.value
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

set.seed(123)
\end_layout

\begin_layout Plain Layout

bigResults <- lapply(1:NROW(conds), runOneCondition, conds)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stackedResults <- do.call(rbind, bigResults)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Now summarize the rejection rate for each condition
\end_layout

\begin_layout Plain Layout

output <- aggregate(reject ~ N + SD, data = stackedResults, FUN = mean)
\end_layout

\begin_layout Plain Layout

names(output) <- c("N", "SD", "Type.I.Rate")
\end_layout

\begin_layout Plain Layout

output
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Yes!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Recommendations
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Advice for Monte Carlo Designers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
DO NOT: 
\end_layout

\begin_layout Itemize
Think of the Monte Carlo experiment as “One Giant Sequential Script” of
 commands
\end_layout

\begin_layout Itemize
Generate a massive block of data that needs to be saved and re-loaded every
 time you run a procedure on it 
\end_layout

\begin_layout Standard

\series bold
Rather
\series default
, create separate functions that
\end_layout

\begin_layout Enumerate
Generate and manipulate data for one 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 of the simulation
\end_layout

\begin_deeper
\begin_layout Itemize
May receive a random seed for replication purposes
\end_layout

\begin_layout Itemize
Handles all of the data-related changes (impose missingness, etc.)
\end_layout

\end_deeper
\begin_layout Enumerate
Accept & analyze 1 data set (Runs one complete replication, saves results)
\end_layout

\begin_layout Enumerate
Orchestrate repetition of the above steps
\end_layout

\begin_layout Enumerate
Harvest estimates, summarize/plot results
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Example of what to NOT Do}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
R code generated by ML-Pow-SIM
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\tiny\ttfamily},tabsize=2"
inline false
status open

\begin_layout Plain Layout

###     A programme to obtain the power of parameters in 2 level
\end_layout

\begin_layout Plain Layout

#       balanced model  with  Normal response
\end_layout

\begin_layout Plain Layout

#                    generated on 09/11/16
\end_layout

\begin_layout Plain Layout

###~~~~~~~~~~~~~~~~~    Required packages  ~~~~~~~~~~~~~~~~~~~~~###
\end_layout

\begin_layout Plain Layout

    library(MASS)
\end_layout

\begin_layout Plain Layout

    library(lme4)
\end_layout

\begin_layout Plain Layout

###~~~~~~~~~~~~~~~~~~~     Initial inputs    ~~~~~~~~~~~~~~~~~~~~###
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

set.seed(666)
\end_layout

\begin_layout Plain Layout

siglevel<-0.025
\end_layout

\begin_layout Plain Layout

z1score<-abs(qnorm(siglevel))
\end_layout

\begin_layout Plain Layout

simus<-100
\end_layout

\begin_layout Plain Layout

n1low<-5
\end_layout

\begin_layout Plain Layout

n1high<-6
\end_layout

\begin_layout Plain Layout

n1step<-1
\end_layout

\begin_layout Plain Layout

n2low<-35
\end_layout

\begin_layout Plain Layout

n2high<-40
\end_layout

\begin_layout Plain Layout

n2step<-5
\end_layout

\begin_layout Plain Layout

npred<-1
\end_layout

\begin_layout Plain Layout

randsize<-1
\end_layout

\begin_layout Plain Layout

beta<-c(0.00000,+.500000)
\end_layout

\begin_layout Plain Layout

betasize<-length(beta)
\end_layout

\begin_layout Plain Layout

effectbeta<-abs(beta)
\end_layout

\begin_layout Plain Layout

sgnbeta<-sign(beta)
\end_layout

\begin_layout Plain Layout

randcolumn<-0
\end_layout

\begin_layout Plain Layout

xprob<-c(0,0.500000)
\end_layout

\begin_layout Plain Layout

meanpred<-c(0,0.000000)
\end_layout

\begin_layout Plain Layout

sigma2u<-matrix(c(1.000000),randsize,randsize)
\end_layout

\begin_layout Plain Layout

sigmae<-sqrt(2.000000)
\end_layout

\begin_layout Plain Layout

n1range<-seq(n1low,n1high,n1step)
\end_layout

\begin_layout Plain Layout

n2range<-seq(n2low,n2high,n2step)
\end_layout

\begin_layout Plain Layout

n1size<-length(n1range)
\end_layout

\begin_layout Plain Layout

n2size<-length(n2range)
\end_layout

\begin_layout Plain Layout

totalsize<-n1size*n2size
\end_layout

\begin_layout Plain Layout

finaloutput<-matrix(0,totalsize,6*betasize)
\end_layout

\begin_layout Plain Layout

rowcount<-1
\end_layout

\begin_layout Plain Layout

##-----------------        Inputs for model fitting       -----------------##
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fixname<-c("x0","x1")
\end_layout

\begin_layout Plain Layout

fixform<-"1+x1"
\end_layout

\begin_layout Plain Layout

randform<-"(1|l2id)"
\end_layout

\begin_layout Plain Layout

expression<-paste(c(fixform,randform),collapse="+")
\end_layout

\begin_layout Plain Layout

modelformula<-formula(paste("y ~",expression))
\end_layout

\begin_layout Plain Layout

data<-vector("list",2+length(fixname))
\end_layout

\begin_layout Plain Layout

names(data)<-c("l2id","y",fixname)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#####--------- Initial input for power in two approaches ----------------#####
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   powaprox<-vector("list",betasize)
\end_layout

\begin_layout Plain Layout

    names(powaprox)<-c("b0","b1")
\end_layout

\begin_layout Plain Layout

     powsde<-powaprox
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cat("               The programme was executed at", date(),"
\backslash
n")
\end_layout

\begin_layout Plain Layout

cat("   --------------------------------------------------------------------
\backslash
n")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 for(n2 in seq(n2low,n2high,n2step)){
\end_layout

\begin_layout Plain Layout

  for(n1 in seq(n1low,n1high,n1step)){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                                             length=n1*n2
\end_layout

\begin_layout Plain Layout

                                            x<-matrix(1,length,betasize)
\end_layout

\begin_layout Plain Layout

                                           z<-matrix(1,length,randsize)
\end_layout

\begin_layout Plain Layout

                                          l2id<-rep(c(1:n2),each=n1)
\end_layout

\begin_layout Plain Layout

                                         sdepower<-matrix(0,betasize,simus)
\end_layout

\begin_layout Plain Layout

                                       powaprox[1:betasize]<-rep(0,betasize)
\end_layout

\begin_layout Plain Layout

                                      powsde<-powaprox
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cat(" Start of simulation for sample sizes of ",n1," micro and ",n2,"macro
 units
\backslash
n")
\end_layout

\begin_layout Plain Layout

  for(iter in 1:simus){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                       if(iter/10==floor(iter/10)){
\end_layout

\begin_layout Plain Layout

                                                   cat(" Iteration remain=",simu
s-iter,"
\backslash
n")
\end_layout

\begin_layout Plain Layout

                                                  }
\end_layout

\begin_layout Plain Layout

#######------------       To set up X matrix          --------------########
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

               x[,2]<-rbinom(length,1,xprob[2])
\end_layout

\begin_layout Plain Layout

#####-----------------------------------------------------------------------####
#
\end_layout

\begin_layout Plain Layout

                  e<-rnorm(length,0,sigmae)
\end_layout

\begin_layout Plain Layout

                   u<-mvrnorm(n2,rep(0,randsize),sigma2u)
\end_layout

\begin_layout Plain Layout

                    fixpart<-x%*%beta
\end_layout

\begin_layout Plain Layout

                     randpart<-rowSums(z*u[l2id,])
\end_layout

\begin_layout Plain Layout

                      y<-fixpart+randpart+e
\end_layout

\begin_layout Plain Layout

##-------------------        Inputs for model fitting       ---------------##
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  data$l2id<-as.factor(l2id)
\end_layout

\begin_layout Plain Layout

  data$y<-y
\end_layout

\begin_layout Plain Layout

    data$x0<-x[,1]
\end_layout

\begin_layout Plain Layout

    data$x1<-x[,2]
\end_layout

\begin_layout Plain Layout

###~~~~~~~~~~      Fitting the model using lmer funtion    ~~~~~~~~~~###
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(fitmodel <- lmer(modelformula,data,REML=TRUE))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

######~~~~~~~~~~   To obtain the power of parameter(s) ~~~~~~~~~~######
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

estbeta<-fixef(fitmodel)
\end_layout

\begin_layout Plain Layout

 sdebeta<-sqrt(diag(vcov(fitmodel)))
\end_layout

\begin_layout Plain Layout

  for(l in 1:betasize)
\end_layout

\begin_layout Plain Layout

  {
\end_layout

\begin_layout Plain Layout

   cibeta<-estbeta[l]-sgnbeta[l]*z1score*sdebeta[l]
\end_layout

\begin_layout Plain Layout

    if(beta[l]*cibeta>0)              powaprox[[l]]<-powaprox[[l]]+1
\end_layout

\begin_layout Plain Layout

      sdepower[l,iter]<-as.numeric(sdebeta[l])
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

##------------------------------------------------------------------------##
\end_layout

\begin_layout Plain Layout

        } ##  iteration end here
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 ###---------                  Powers and their CIs             ---------###
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                        for(l in 1:betasize){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

meanaprox<-powaprox[[l]]<-unlist(powaprox[[l]]/simus)
\end_layout

\begin_layout Plain Layout

Laprox<-meanaprox-z1score*sqrt(meanaprox*(1-meanaprox)/simus)
\end_layout

\begin_layout Plain Layout

Uaprox<-meanaprox+z1score*sqrt(meanaprox*(1-meanaprox)/simus)
\end_layout

\begin_layout Plain Layout

meansde<-mean(sdepower[l,])
\end_layout

\begin_layout Plain Layout

varsde<-var(sdepower[l,])
\end_layout

\begin_layout Plain Layout

USDE<-meansde-z1score*sqrt(varsde/simus)
\end_layout

\begin_layout Plain Layout

LSDE<-meansde+z1score*sqrt(varsde/simus)
\end_layout

\begin_layout Plain Layout

powLSDE<- pnorm(effectbeta[l]/LSDE-z1score)
\end_layout

\begin_layout Plain Layout

powUSDE<- pnorm(effectbeta[l]/USDE-z1score)
\end_layout

\begin_layout Plain Layout

powsde[[l]]<-pnorm(effectbeta[l]/meansde-z1score)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		###---------   Restrict the CIs within 0 and 1	---------##
\end_layout

\begin_layout Plain Layout

				if(Laprox<0) Laprox<-0
\end_layout

\begin_layout Plain Layout

				if(Uaprox>1) Uaprox<-1
\end_layout

\begin_layout Plain Layout

				if(powLSDE<0) powLSDE<-0
\end_layout

\begin_layout Plain Layout

				if(powUSDE>1) powUSDE<-1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

finaloutput[rowcount,(6*l-5):(6*l-3)]<-c(Laprox,meanaprox,Uaprox)
\end_layout

\begin_layout Plain Layout

finaloutput[rowcount,(6*l-2):(6*l)]<-c(powLSDE,powsde[[l]],powUSDE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

                                           }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

###~~~~~~~~~~            Set out the results in a data frame    ~~~~~~~~~~###
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rowcount<-rowcount+1
\end_layout

\begin_layout Plain Layout

cat("--------------------------------------------------------------------
\backslash
n")
\end_layout

\begin_layout Plain Layout

                               } ## end of the loop  over the first level
\end_layout

\begin_layout Plain Layout

                           } ## end of the loop  over the second level
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 ###---------         Export output in a file                      ---------###
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

finaloutput<-as.data.frame(round(finaloutput,3))
\end_layout

\begin_layout Plain Layout

 output<-data.frame(cbind(rep(n2range,each=n1size),rep(n1range,n2size),finaloutpu
t))
\end_layout

\begin_layout Plain Layout

  names(output)<-c("N","n","zLb0","zpb0","zUb0","sLb0","spb0","sUb0","zLb1","zpb
1","zUb1","sLb1","spb1","sUb1")
\end_layout

\begin_layout Plain Layout

write.table(output,"powerout.txt",sep="
\backslash
t ",quote=F,eol="
\backslash
n",dec=".",col.names=T,row.names=F,qmethod="double")
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{MC Designs from an ANOVA Point of View}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Think of a random sample as a person/case in a study
\end_layout

\begin_deeper
\begin_layout Itemize
Multiple samples in each condition
\end_layout

\end_deeper
\begin_layout Itemize
Between-subjects factors change the data-generating process
\end_layout

\begin_deeper
\begin_layout Itemize
Parameters, distributions, missing data, scales
\end_layout

\end_deeper
\begin_layout Itemize
Within-subjects factors analyze the same data using different methods –
 Estimation method, with/out covariates, N?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Monte Carlo Outcomes}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Sampling distributions of...
 anything! 
\end_layout

\begin_layout Itemize
Consistency, efficiency, normality 
\end_layout

\begin_layout Itemize
Bias in point and SE estimates 
\end_layout

\begin_layout Itemize
(Root) mean-squared error 
\end_layout

\begin_layout Itemize
Confidence Interval coverage rates 
\end_layout

\begin_layout Itemize
Hypothesis tests rejection rates (alpha, power) 
\end_layout

\begin_layout Itemize
Model fit
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Design your study to test hypotheses}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Exploratory simulations can get out of hand
\end_layout

\begin_layout Itemize
Are all conditions necessary to test your hypotheses?
\end_layout

\begin_deeper
\begin_layout Itemize
Consider how factors are expected to affect outcomes of interest, including
 interactions
\end_layout

\end_deeper
\begin_layout Itemize
If exploring potential effects, try 2 levels of each parameter you want
 to explore.
\end_layout

\begin_deeper
\begin_layout Itemize
That gives 
\begin_inset Formula $2^{k}$
\end_inset

 separate conditions for 
\begin_inset Formula $k$
\end_inset

 parameters for pilot study
\end_layout

\begin_layout Itemize
Reduce number of conditions by intentionally confounding higher-order interactio
ns
\end_layout

\end_deeper
\begin_layout Itemize
Alternative strategy
\end_layout

\begin_deeper
\begin_layout Itemize
think of each parameter as a continuum, 
\end_layout

\begin_layout Itemize
draw parameters for a run from the continuous space
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Write down a recipe to plan your study}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Writing syntax can be daunting, so start with plain language
\end_layout

\begin_layout Itemize
Ingredients
\end_layout

\begin_deeper
\begin_layout Itemize
Characteristics of your population(s)
\end_layout

\begin_layout Itemize
Manipulated factors, outcomes of interest
\end_layout

\end_deeper
\begin_layout Itemize
Write down steps from beginning to end
\end_layout

\begin_deeper
\begin_layout Itemize
Can start broad, move to specific
\end_layout

\begin_layout Itemize
Ultimately, easier to translate to R, C, Fortran if you remember what you
 are trying to do
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Variance Reduction Techniques}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Save time and computing power, as well as reduce the amount of noise in
 your results 
\end_layout

\begin_layout Itemize
When is it necessary to draw new samples?
\end_layout

\begin_deeper
\begin_layout Itemize
NOT for factors like sample size, different estimators, prior variance,
 competing models 
\end_layout

\begin_layout Itemize
Typically, ONLY when the population differs (e.g., normal/nonnormal data),
 or the factor reflects an aspect of design that changes characteristics
 of the data (e.g., number of response categories)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Variance Reduction Techniques}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Consider sample size, etc., to be within- sample (or within-replication)
 factors
\end_layout

\begin_deeper
\begin_layout Itemize
Recycle same seeds, or better yet, perform all analyses/conditions on the
 data the one time is generated
\end_layout

\begin_layout Itemize
Generate largest N, then take first 
\begin_inset Formula $N_{j}$
\end_inset

 from sample
\end_layout

\begin_layout Itemize
Repeat this for # of replications, within each cell of between-replication
 design
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Analysis Plan}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Carefully consider outcomes of interest
\end_layout

\begin_deeper
\begin_layout Itemize
Have testable hypotheses/predictions
\end_layout

\begin_layout Itemize
In each replication, save the output you intend to investigate, in a way
 that makes it easy to analyze
\end_layout

\end_deeper
\begin_layout Itemize
Picture your analysis of results ahead of time
\end_layout

\begin_deeper
\begin_layout Itemize
Perhaps make up data in a spreadsheet that mimics the format of your results
\end_layout

\begin_layout Itemize
Could help your design
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Useful Tools}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In R, the package portableParallelSeeds allows you to exercise great control
 of replicability using random seed-states
\end_layout

\begin_deeper
\begin_layout Itemize
Developed at CRMDA, hosted on our KRAN server
\end_layout

\begin_layout Itemize
To install and find help files:
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

CRAN <- "http://rweb.crmda.ku.edu/cran" 
\end_layout

\begin_layout Plain Layout

KRAN <- "http://rweb.crmda.ku.edu/kran"
\end_layout

\begin_layout Plain Layout

options(repos = c(KRAN, CRAN))
\end_layout

\begin_layout Plain Layout

install.packages("portableParallelSeeds", type = "source")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{References}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../../R"
options "apalike2"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Session}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sess10>>=
\end_layout

\begin_layout Plain Layout

sessionInfo()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<opts20, include=F>>=
\end_layout

\begin_layout Plain Layout

## Don't delete this.
 It puts the interactive session options
\end_layout

\begin_layout Plain Layout

## back the way they were.
 If this is compiled within a session
\end_layout

\begin_layout Plain Layout

## it is vital to do this.
\end_layout

\begin_layout Plain Layout

options(opts.orig)
\end_layout

\begin_layout Plain Layout

options(par.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
