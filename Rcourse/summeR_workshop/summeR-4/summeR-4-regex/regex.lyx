#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usepackage{dcolumn}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{graphicx}
\renewcommand{\doiprefix}{doi:\kern-1pt}
\setlength{\bibsep}{10pt}

% use 'handout' to produce handouts
%\documentclass[handout]{beamer}
\usepackage{wasysym}
\usepackage{pgfpages}
%for bold upright roman in math for matrix algebra
\newcommand{\vn}[1]{\mbox{{\it #1}}}\newcommand{\vb}{\vspace{\baselineskip}}\newcommand{\vh}{\vspace{.5\baselineskip}}\newcommand{\vf}{\vspace{\fill}}\newcommand{\splus}{\textsf{S-PLUS}}\newcommand{\R}{\textsf{R}}

%%\input{theme/guidePreambleSweavel.tex} 
%%% From beamer slide:
\usepackage{Sweave}
%% 
%% This controls display of code chunks
\usepackage{ae,fancyvrb,relsize,listings}

\providecommand{\Sweavesize}{\normalsize}
\providecommand{\Rsize}{}
\renewcommand{\Rsize}{\normalsize}
\providecommand{\Routsize}{\scriptsize}

\providecommand{\Rcolor}{\color[rgb]{0.1, 0.1, 0.1}}
\providecommand{\Routcolor}{\color[rgb]{0.2, 0.2, 0.2}}
\providecommand{\Rcommentcolor}{\color[rgb]{0.101, 0.43, 0.432}}

\providecommand{\Rbackground}{\color[gray]{0.91}}
\providecommand{\Routbackground}{\color[gray]{0.935}}
% Can specify \color[gray]{1} for white background or just \color{white}

\lstdefinestyle{Rinput}{
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  basicstyle=\Rsize\Rcolor\ttfamily,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%,
  commentstyle=\Rcommentcolor\ttfamily,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1{==}{{=\,=}}2{--}{{-\,-}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
  backgroundcolor=\Rbackground,%
  numbers=left,%
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}%

% Other options of interest:
% frame=single,framerule=0.1pt,framesep=1pt,rulecolor=\color{blue},
% numbers=left,numberstyle=\tiny,stepnumber=1,numbersep=7pt,
% keywordstyle={\bf\Rcolor}

\lstdefinestyle{Routput}{fancyvrb=false,
  literate={~}{{$\sim$}}1{R^2}{{$R^{2}$}}2{^}{{$^{\scriptstyle\wedge}$}}1{R-squared}{{$R^{2}$}}2,%
  basicstyle=\Routcolor\Routsize\ttfamily,%
  backgroundcolor=\Routbackground,
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1 {==}{{=\,=}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},
  numbers=left,
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}

\renewenvironment{Schunk}{}{}
\renewenvironment{Sinput}{}{}
\let\Sinput\relax
\let\Scode\relax
\let\Soutput\relax
\lstnewenvironment{Sinput}{\lstset{style=Rinput}}{}
\lstnewenvironment{Scode}{\lstset{style=Rinput}}{}
\lstnewenvironment{Soutput}{\lstset{style=Routput}}{}
%%end paste in from guidePreambleSweavel.tex


\lstset{tabsize=2, breaklines=true, style=Rinput, breakatwhitespace=true}

\fvset{listparameters={\setlength{\topsep}{0em}}}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.90}
\usepackage{realboxes}
\providecommand*{\code}[1]{\texttt{#1}}
\renewcommand{\code}[1]{%
\Colorbox{light-gray}{#1}%
}%
%% end of paste

\usepackage[natbibapa]{apacite}

\definecolor{darkblue}{HTML}{1e2277}

%would be in beamerthemekucrmda%
\mode<presentation>
\definecolor{kublue}{RGB}{0,81,186}
\usefonttheme{professionalfonts}
\useoutertheme{infolines}
\useinnertheme{rounded}
%disable rounded for alert and example boxes%
\setbeamertemplate{blocks}[default]
\usecolortheme{whale}
\usecolortheme{orchid}
\setbeamercolor{structure}{bg=kublue,fg=kublue!90!black}
%\setbeamercolor{structure}{fg=kublue}
\setbeamercolor{frametitle}{bg=kublue}
\setbeamercolor{section in toc}{fg=kublue!40!black}

\setbeamertemplate{frametitle continuation}[from second]
\renewcommand\insertcontinuationtext{...}
\beamertemplatenavigationsymbolsempty
%end of beamerthemekucrmda%

%If you want bigger margins, try this:
\setbeamersize{text margin left=05mm,text margin right=10mm} 
\hypersetup{colorlinks,allcolors=.,urlcolor=darkblue}
%Following seems to have no effect now
%\usepackage{handoutWithNotes}
%\pgfpagesuselayout{3 on 1 with notes}[letterpaper, border shrink=5mm]

\titlegraphic{\includegraphics[width=6cm]{theme/logo}}
\logo{\includegraphics[width=5mm]{theme/logomini}}
\end_preamble
\options aspectratio=1609
\use_default_options false
\begin_modules
logicalmkup
sweave
natbibapa
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style \use_bibtopic false
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\branch R
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch semboot
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\branch cfalvm
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%following is LyX shortcut 
\backslash
vb for bold upright math for matrices
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\vb}[1]{\bm{\mathrm{#1}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch R
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% tmpout directory must exist first
\end_layout

\begin_layout Plain Layout

<<tmpout, echo=FALSE, include=FALSE, results=hide>>=
\end_layout

\begin_layout Plain Layout

tdir <- "tmpout"
\end_layout

\begin_layout Plain Layout

if(!dir.exists(tdir)) dir.create(tdir, showWarnings=FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{prefix.string=tmpout/t,split=T,ae=F,height=4.5,width=7}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, include=F, results=hide>>=
\end_layout

\begin_layout Plain Layout

opts.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=100, prompt = " ", continue = "  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE)
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

par.orig <- par(no.readonly = TRUE) 
\end_layout

\begin_layout Plain Layout

pjmar <- c(4.1, 4.1, 1.5, 2.1)
\end_layout

\begin_layout Plain Layout

options(SweaveHooks=list(fig=function() par(mar=pjmar, ps=12, xpd=F)))
\end_layout

\begin_layout Plain Layout

pdf.options(onefile=F,family="Times",pointsize=12)
\end_layout

\begin_layout Plain Layout

if(!file.exists("theme")) file.symlink("../../../../template/theme", "theme")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Title
Regular Expressions in R 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
regex
\end_layout

\end_inset


\end_layout

\begin_layout Author
Paul E.
 Johnson
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Johnson
\end_layout

\end_inset


\end_layout

\begin_layout Institute
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

Center for Research Methods and Data Analysis 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
CRMDA
\end_layout

\end_inset


\end_layout

\begin_layout Date
2018
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following causes the table of contents to be shown at the beginning
 of every subsection.
 Delete this, if you do not want it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSection[]{
\end_layout

\begin_layout Plain Layout

  
\backslash
frame<beamer>{ 
\end_layout

\begin_layout Plain Layout

    
\backslash
frametitle{Outline}
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection] 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Outline}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
What is a Regular Expression?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{What for?}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Regular expressions are used for
\end_layout

\begin_layout Enumerate
Matching: Identifying patterns that exist in strings
\end_layout

\begin_layout Enumerate
Editing and re-arranging matched patterns in strings
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{What for?}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Some users know 
\begin_inset Quotes eld
\end_inset

shell globs
\begin_inset Quotes erd
\end_inset

 for pattern matching, e.g.
 
\begin_inset Quotes eld
\end_inset

*.docx
\begin_inset Quotes erd
\end_inset

 represents all files that end in 
\begin_inset Quotes eld
\end_inset

docx
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Regular expressions are a different pattern matching system that allows
 much more delicate filtering.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename importfigs/perl_problems.png

\end_inset


\end_layout

\begin_layout Itemize
Regular expressions are Jedi light sabres compared to shell globs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{General Purpose Terminology}
\end_layout

\end_inset


\end_layout

\begin_layout ColumnsTopAligned

\end_layout

\begin_deeper
\begin_layout Column
6cm
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

grep
\begin_inset Quotes erd
\end_inset

: the GNU regular expression parser
\end_layout

\begin_layout Itemize
Regular expressions are heavily used Perl, Python, awk, sed, and other interacti
ve languages used in the Web
\end_layout

\begin_layout Itemize
More-or-less uniform, some variations among implementations
\end_layout

\begin_layout Column
6cm
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename importfigs/regular_expressions.png
	width 6cm

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{General Purpose Terminology}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
R 
\begin_inset CommandInset citation
LatexCommand citep
key "RCore"
literal "true"

\end_inset

 includes functions that use regular expressions.
 Today we focus on functions named
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
grep()
\end_layout

\end_inset

: identifying the presence of a pattern
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
gsub()
\end_layout

\end_inset

: replacing a matched pattern
\end_layout

\end_deeper
\begin_layout Itemize
We will only go about 25% below the surface of this (deep deep) water.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Regular Expression Symbol Highlights}
\end_layout

\end_inset


\end_layout

\begin_layout Description
.
 matches any character
\end_layout

\begin_layout Description
* a quantifier, meaning any number of times.
 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
.*
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 is any character, any number of times
\end_layout

\begin_layout Description
^ the beginning of a string
\end_layout

\begin_layout Description
$ the end of a string
\end_layout

\begin_layout Description
Other
\begin_inset space ~
\end_inset

special
\begin_inset space ~
\end_inset

symbols in regex: ( ) [ ] - + 
\backslash
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Pattern matching
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{grep is for finding values}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
grep: 
\begin_inset Quotes eld
\end_inset

GNU regular expression parser
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
In a terminal, I use grep all the time to filter text.
\end_layout

\begin_layout Itemize
R's implementation is an R function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
grep()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
primary arguments
\end_layout

\begin_deeper
\begin_layout Description
pattern a regular expression character string
\end_layout

\begin_layout Description
x the input character vector in which matches are to be found
\end_layout

\end_deeper
\begin_layout Itemize
Return will be the number of each matching item
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{simple example 1}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c("Dieter-Charles", "Charles", "Charlie", "Charles-William", "Charlene")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Which ones end with 
\begin_inset Quotes eld
\end_inset

Charles
\begin_inset Quotes erd
\end_inset

?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grep("Charles$", x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I want the ones that begin with 
\begin_inset Quotes eld
\end_inset

Charles
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grep("^Charles", x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
You want the names, not the positions in the vector? I forgot to mention
 this argument:
\end_layout

\begin_deeper
\begin_layout Description
value return the values of matching items
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grep("^Charles", x, value = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{The back slash problem}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The backslash is a special symbol, it is used in 
\begin_inset Quotes eld
\end_inset

escape combinations
\begin_inset Quotes erd
\end_inset

 like
\end_layout

\begin_deeper
\begin_layout Description

\backslash
n new line
\end_layout

\begin_layout Description

\backslash
t tab character
\end_layout

\end_deeper
\begin_layout Itemize
These are known as 
\begin_inset Quotes eld
\end_inset

escape sequences
\begin_inset Quotes erd
\end_inset

.
 Any 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

 is seen as the beginning of an escape sequence by the R interpreter.
 
\end_layout

\begin_layout Itemize
In regular expressions, some symbols have special meaning, so they have
 to be escaped by 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

 when we want to use them literally.
\end_layout

\begin_layout Itemize
Ex: If quotation marks are needed inside a quoted string, for example, we
 
\begin_inset Quotes eld
\end_inset

escape
\begin_inset Quotes erd
\end_inset

 the middle quotes
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

aname <- "Fred 
\backslash
"The Hammer
\backslash
" Williamson"
\end_layout

\begin_layout Plain Layout

aname
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Easier way to type that in uses single quotes, but you see end result is
 same
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

aname <- 'Fred "The Hammer" Williamson'
\end_layout

\begin_layout Plain Layout

aname
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The single backslash is not allowed to appear in text strings unless it
 is performing a special purpose of escaping something.
 So, if you want to type in 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

 literally, it must escape itself!
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

 is entered by 
\begin_inset Quotes eld
\end_inset


\backslash

\backslash

\begin_inset Quotes erd
\end_inset

!
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c("Dieter
\backslash

\backslash
Charles", "Friend/Foe")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Note, that the double backslash appears when we 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
print()
\end_layout

\end_inset

 the string, but not when we 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
cat()
\end_layout

\end_inset

 it.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

print(x)
\end_layout

\begin_layout Plain Layout

cat(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The cat output indicates that the 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 string just has one backslash, but the display of it shows two because
 the first one is escaping the second one.
\end_layout

\begin_layout Itemize
If you want to match the items that have the literal backslash, get ready
 for 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout

\backslash

\backslash

\backslash

\backslash

\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grep("
\backslash

\backslash

\backslash

\backslash
", x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Why 4? Well,
\end_layout

\begin_deeper
\begin_layout Itemize
R is an interpreter, so you need 2 escapes for R
\end_layout

\begin_layout Itemize
R is passing this to the GNU regex engine, and it needs 2 escapes as well
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Other grep parameters}
\end_layout

\end_inset


\end_layout

\begin_layout Description
fixed if TRUE, turns off regex matching, uses literal character matching
\end_layout

\begin_layout Description
ignore.case capitalization does not count
\end_layout

\begin_layout Description
perl use the regex style of the Perl program
\end_layout

\begin_layout Description
invert return the non-matching items
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{fixed parameter helps on the backslash problem}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Turning off regular expressions means we don't need 4 slashes anymore, just
 2
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grep("
\backslash

\backslash
", x, fixed = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Why do we still need 2? All character strings in computers always have 
\begin_inset Quotes eld
\end_inset


\backslash
n
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset


\backslash
t
\begin_inset Quotes erd
\end_inset

 for newline or tab, those are not regular expression escapes.
\end_layout

\begin_layout Itemize
If we include just 
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset

, the system will say we did not supply 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

t
\begin_inset Quotes erd
\end_inset

 to finish what we started.
\end_layout

\begin_layout Itemize
If we say 
\begin_inset Quotes eld
\end_inset


\backslash

\backslash

\begin_inset Quotes erd
\end_inset

, it is interpreted as one literal backslash.
\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

why do I need four backslashes to match one backslash?
\begin_inset Quotes erd
\end_inset

 problem is one of the FAQs for many programs.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Quiz}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

cities <- c("Dallas Texas", "Denver Colorado", "Austin Texas", "Salem Oregon",
 "Salem Massachusetts", "California Pennsylvania", "Long Beach California",
 "San Francisco California", "Texas Missouri", "Nevada Missouri", "St.
 Louis Missouri", "Truth or Consequences New Mexico", "Charleston South
 Carolina", "Charleston North Carolina") 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you ask 
\begin_inset Quotes eld
\end_inset

which elements are from the state of Texas
\begin_inset Quotes erd
\end_inset

, note that a fixed pattern match will not find them.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grep("Texas", cities, fixed = TRUE, value = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Can you find a regular expression to find cities in state of Texas?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

grep("______", cities)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Texas, As If you would want that}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

grep("Texas$", cities, value = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{A real life pattern matching problem}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We have a data set with a lot of variables, here are the column names, in
 a vector
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ht10>>=
\end_layout

\begin_layout Plain Layout

cnames <- c("ID", "Q1", "encounter", "forms", "ar_physinj.n", "ar_illness.n",
\end_layout

\begin_layout Plain Layout

"ar_chronic.n", "ar_job.n", "ar_hunger.n", "ar_STI.n", "ar_sa.n",
\end_layout

\begin_layout Plain Layout

"ar_UTI.n", "ar_abuse.n", "ar_dental.n", "ar_drugalc.n", "ar_suicide.n",
\end_layout

\begin_layout Plain Layout

"ar_chronrun.n", "ar_truancy.n", "ar_sysinvolve.n", "ar_menthealth.n",
\end_layout

\begin_layout Plain Layout

"ar_tattoos.n", "ar_other.n", "rf_pov.n", "rf_homeless.n", "rf_famdys.n",
\end_layout

\begin_layout Plain Layout

"rf_control.n", "rf_addiction.n", "rf_physdis.n", "rf_cogdis.n",
\end_layout

\begin_layout Plain Layout

"rf_race.n", "rf_LGBTQ.n", "rf_undoc.n", "rf_lang.n", "rf_pregnancy.n",
\end_layout

\begin_layout Plain Layout

"rf_dropout.n", "rf_running.n", "rf_sex.n", "rf_abuse.n", "rf_fincontrol.n",
\end_layout

\begin_layout Plain Layout

"rf_ssnetworks.n", "rf_other.n", "ar_physinj.l", "ar_illness.l",
\end_layout

\begin_layout Plain Layout

"ar_chronic.l", "ar_job.l", "ar_hunger.l", "ar_STI.l", "ar_sa.l",
\end_layout

\begin_layout Plain Layout

"ar_UTI.l", "ar_abuse.l", "ar_dental.l", "ar_drugalc.l", "ar_suicide.l",
\end_layout

\begin_layout Plain Layout

"ar_chronrun.l", "ar_truancy.l", "ar_sysinvolve.l", "ar_menthealth.l",
\end_layout

\begin_layout Plain Layout

"ar_tattoos.l", "ar_other.l", "rf_pov.l", "rf_homeless.l", "rf_famdys.l",
\end_layout

\begin_layout Plain Layout

"rf_control.l", "rf_addiction.l", "rf_physdis.l", "rf_cogdis.l",
\end_layout

\begin_layout Plain Layout

"rf_race.l", "rf_LGBTQ.l", "rf_undoc.l", "rf_lang.l", "rf_pregnancy.l",
\end_layout

\begin_layout Plain Layout

"rf_dropout.l", "rf_running.l", "rf_sex.l", "rf_abuse.l", "rf_fincontrol.l",
\end_layout

\begin_layout Plain Layout

"rf_ssnetworks.l", "rf_other.l", "ar_physinj.s", "ar_illness.s",
\end_layout

\begin_layout Plain Layout

"ar_chronic.s", "ar_job.s", "ar_hunger.s", "ar_STI.s", "ar_sa.s",
\end_layout

\begin_layout Plain Layout

"ar_UTI.s", "ar_abuse.s", "ar_dental.s", "ar_drugalc.s", "ar_suicide.s",
\end_layout

\begin_layout Plain Layout

"ar_chronrun.s", "ar_truancy.s", "ar_sysinvolve.s", "ar_menthealth.s",
\end_layout

\begin_layout Plain Layout

"ar_tattoos.s", "ar_other.s", "rf_pov.s", "rf_homeless.s", "rf_famdys.s",
\end_layout

\begin_layout Plain Layout

"rf_control.s", "rf_addiction.s", "rf_physdis.s", "rf_cogdis.s",
\end_layout

\begin_layout Plain Layout

"rf_race.s", "rf_LGBTQ.s", "rf_undoc.s", "rf_lang.s", "rf_pregnancy.s",
\end_layout

\begin_layout Plain Layout

"rf_dropout.s", "rf_running.s", "rf_sex.s", "rf_abuse.s", "rf_fincontrol.s",
\end_layout

\begin_layout Plain Layout

"rf_ssnetworks.s", "rf_other.s", "cr_strongfam", "cr_mentors",
\end_layout

\begin_layout Plain Layout

"cr_faithcom", "cr_culturecom", "cr_employment", "cr_edaccess",
\end_layout

\begin_layout Plain Layout

"cr_houseaccess", "cr_pathimm", "cr_physhealth", "cr_menthealth",
\end_layout

\begin_layout Plain Layout

"cr_insurance", "cr_govprog", "cr_other", "or_protocol", "or_collab",
\end_layout

\begin_layout Plain Layout

"or_lawenforce", "or_hotline", "or_training", "or_other", "sector",
\end_layout

\begin_layout Plain Layout

"chronrun", "truancy", "region", "arak", "arub", "arakUTI", "Q57", "Q59",
\end_layout

\begin_layout Plain Layout

"Q61", "Q63", "Q65", "Q19", "Q21", "Q23", "Q25", "Q27")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Here are the assignments}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use a regular expression to pull out the variable names that begin with
 
\begin_inset Quotes eld
\end_inset

ar
\begin_inset Quotes erd
\end_inset

 and end in 
\begin_inset Quotes eld
\end_inset

.n
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.s
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

.l
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Find the variables that have 
\begin_inset Quotes eld
\end_inset

chronrun
\begin_inset Quotes erd
\end_inset

 in the middle after 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

 and before 
\begin_inset Quotes eld
\end_inset

.s
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.n
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

.l
\begin_inset Quotes erd
\end_inset

 (hint: this is a literal period, not a regex 
\begin_inset Quotes eld
\end_inset

this .
 means anything
\begin_inset Quotes erd
\end_inset

 period, so it will need to be escaped 
\begin_inset Quotes eld
\end_inset


\backslash

\backslash
.
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Fill in the blanks}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use a regular expression to pull out the variable names that end in 
\begin_inset Quotes eld
\end_inset

.n
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

.s
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Quotes eld
\end_inset

.l
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

grep("______", _____, value = TRUE)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{My Answer 1}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I needed those as columns in a data frame, so lets try
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ht20>>=
\end_layout

\begin_layout Plain Layout

reslt1 <- data.frame(
\end_layout

\begin_layout Plain Layout

  n = grep("^ar_.*
\backslash

\backslash
.n$", cnames, value = TRUE), 
\end_layout

\begin_layout Plain Layout

  s = grep("^ar_.*
\backslash

\backslash
.s$", cnames, value = TRUE), 
\end_layout

\begin_layout Plain Layout

  l = grep("^ar_.*
\backslash

\backslash
.s$", cnames, value = TRUE))
\end_layout

\begin_layout Plain Layout

head(reslt1, 15)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{My Answer 2}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ht30>>=
\end_layout

\begin_layout Plain Layout

reslt2 <- grep("_chronrun
\backslash

\backslash
.", cnames, value = TRUE)
\end_layout

\begin_layout Plain Layout

reslt2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
And we could use that to pull columns from the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
hts
\end_layout

\end_inset

 data frame:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

hts[reslt2]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Replacing/Revising strings
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{gsub}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
gsub
\end_layout

\end_inset

 is for replacing character strings
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
gsub(
\begin_inset Quotes eld
\end_inset

pattern
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

replacement
\begin_inset Quotes erd
\end_inset

, x)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{City 
\backslash
& State names, again}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<cities10>>=
\end_layout

\begin_layout Plain Layout

cities <- c("Dallas Texas", "Denver Colorado", "Austin Texas", "Salem Oregon",
 "Salem Massachusetts", "California Pennsylvania", "Long Beach California",
 "San Francisco California", "Texas Missouri", "Nevada Missouri", "St.
 Louis Missouri", "Truth or Consequences New Mexico", "Charleston South
 Carolina", "Charleston North Carolina") 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Suppose you want to divide this into 2 variables, city names and state names.
\end_layout

\begin_layout Standard
The complications:
\end_layout

\begin_layout Itemize
names have spaces in them, so I can't choose all of the states by taking
 the last name.
\end_layout

\begin_layout Itemize
ideas?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Here's what I thought of before I asked you}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Step 1.
 Lets replace the state names with abbreviations.
 
\end_layout

\begin_layout Itemize
Step 2.
 Cut out the abbreviations to get the city names by themselves.
\end_layout

\begin_layout Itemize
Step 3.
 Keep only last 2 characters to get the State names.
\end_layout

\begin_layout Itemize
Step 4.
 Put the full names back in.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Step 1.
 Insert Abbreviated State names}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Easy to replace one state name at end by typing
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step11>>=
\end_layout

\begin_layout Plain Layout

gsub("Texas$", "TX", cities)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
But I don't want to type each state one by one
\end_layout

\begin_layout Itemize
R has variables 
\begin_inset Quotes eld
\end_inset

state.name
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

state.abb
\begin_inset Quotes erd
\end_inset

 built into the session
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step12>>=
\end_layout

\begin_layout Plain Layout

head(state.name)
\end_layout

\begin_layout Plain Layout

head(state.abb)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We can go one by one, through those names, with a for loop.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Step 1 Detour.
 named vector}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In the first workshop using this guide, the most surprising/unfamiliar items
 was the way we use a named vector.
 
\end_layout

\begin_layout Itemize
The following will name the items in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
state.name
\end_layout

\end_inset

, using the short 2-letter abbreviations as the names.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step13>>=
\end_layout

\begin_layout Plain Layout

names(state.name) <- state.abb
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Now the abbreviations and full names are tied together.
 Inspect the first few
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step13statename1>>=
\end_layout

\begin_layout Plain Layout

head(state.name)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Now I can retrieve a state's long name by using the index name from the
 abbreviation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step13statename2>>=
\end_layout

\begin_layout Plain Layout

state.name["TX"]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Step 1 Resumes, with a for loop}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The index, i, will be the abbreviations.
\end_layout

\begin_layout Itemize
The gsub inside the loop scans each item, looking for the long state name
 given by 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
state.name[i]
\end_layout

\end_inset

, and replacing it with the short name from 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
i
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step14>>=
\end_layout

\begin_layout Plain Layout

cities2 <- cities
\end_layout

\begin_layout Plain Layout

## I'll iterate on the abbreviations
\end_layout

\begin_layout Plain Layout

for(i in state.abb) {
\end_layout

\begin_layout Plain Layout

    cities2 <- gsub(state.name[i], i, cities2)
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Understanding Checkpoint}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
To test your understanding of the for loop, try these things.
\end_layout

\begin_deeper
\begin_layout Enumerate
Insert 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
print()
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 statements into the loop to cause verbose output from each step, such as
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
print(i)
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
print(state.name[i])
\end_layout

\end_inset

, or 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
print(cities2)
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Enumerate
Insert this 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
browser()
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 at the beginning of the for loop.
 This will stop the calculation so you can inspect the variables interactively.
 (Remember, to exit from browser, type 
\begin_inset Quotes eld
\end_inset

Q
\begin_inset Quotes erd
\end_inset

 return)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Step 1.
 There is an error, however}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Inspect the output, especially item 10
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step13b>>=
\end_layout

\begin_layout Plain Layout

cities2
\end_layout

\begin_layout Plain Layout

cities2[10]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
My state-name-matching gsub() usage was not smart enough.
 I need to restrict its work to the end of the string.
 We need to add a 
\begin_inset Quotes eld
\end_inset

$
\begin_inset Quotes erd
\end_inset

 to the end of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
state.name
\end_layout

\end_inset

 in the target.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Step 1.
 Correction for the state name error}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In Summer 2017, we tried 2 equivalent approaches
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step13c>>=
\end_layout

\begin_layout Plain Layout

## Keep cities safe, write on a copy cities2
\end_layout

\begin_layout Plain Layout

cities2 <- cities
\end_layout

\begin_layout Plain Layout

## Method 1
\end_layout

\begin_layout Plain Layout

## Puts the target match correction into the for loop
\end_layout

\begin_layout Plain Layout

for(i in state.abb) {
\end_layout

\begin_layout Plain Layout

    ## target is a string, only has one element
\end_layout

\begin_layout Plain Layout

    target <- paste0(state.name[i], "$") 
\end_layout

\begin_layout Plain Layout

    cities2 <- gsub(target, i, cities2)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

## Appears correct:
\end_layout

\begin_layout Plain Layout

cities2
\end_layout

\begin_layout Plain Layout

##
\end_layout

\begin_layout Plain Layout

## Here is method 2.
 We start over,
\end_layout

\begin_layout Plain Layout

## Creating a target VECTOR before the for loop.
\end_layout

\begin_layout Plain Layout

## After this, target is a vector of corrected matches
\end_layout

\begin_layout Plain Layout

cities2 <- cities
\end_layout

\begin_layout Plain Layout

target <- paste0(state.name, "$") 
\end_layout

\begin_layout Plain Layout

## names were lost, so re-apply them
\end_layout

\begin_layout Plain Layout

names(target) <- names(state.name)
\end_layout

\begin_layout Plain Layout

## inspect
\end_layout

\begin_layout Plain Layout

head(target, 5)
\end_layout

\begin_layout Plain Layout

for(i in state.abb) {
\end_layout

\begin_layout Plain Layout

    ## target is a vector, choose the i'th one
\end_layout

\begin_layout Plain Layout

    cities2 <- gsub(target[i], i, cities2)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

cities2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Step 1.
 Consider kutils::mgsub}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We found ourselves writing that for loop very often.
\end_layout

\begin_layout Itemize
To streamline, we made a simple function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mgsub()
\end_layout

\end_inset

 (as in 
\begin_inset Quotes eld
\end_inset

multi-gsub
\begin_inset Quotes erd
\end_inset

) in the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

 package.
 
\end_layout

\begin_layout Itemize
It does the exact same work in one line of code
\end_layout

\begin_layout Itemize
Inputs are 
\end_layout

\begin_deeper
\begin_layout Enumerate
the vector of 
\bar under
target
\bar default
 regular expressions that will be replaced
\end_layout

\begin_layout Enumerate
the vector of 
\bar under
replacements
\bar default
, must be same length as target
\end_layout

\begin_layout Enumerate
the string vector in which replacements are to be made.
 
\end_layout

\end_deeper
\begin_layout Itemize
Example usage
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(kutils)
\end_layout

\begin_layout Plain Layout

target <- paste0(state.name, "$")
\end_layout

\begin_layout Plain Layout

mgsub(target, state.abb, cities)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Step 2.
 Cut out the abbreviated state names from the ends}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step21>>=
\end_layout

\begin_layout Plain Layout

head(cities2, 5)
\end_layout

\begin_layout Plain Layout

cities3 <- gsub(" ..$", "", cities2) 
\end_layout

\begin_layout Plain Layout

head(cities3, 5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We deleted a space (
\begin_inset Quotes eld
\end_inset

 
\begin_inset Quotes eld
\end_inset

) and any two characters (
\begin_inset Quotes eld
\end_inset

..
\begin_inset Quotes erd
\end_inset

) at the end (
\begin_inset Quotes eld
\end_inset

$
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Step 3.
 Cut out city names to get state names}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This seems a bit too easy after all of that work.
 
\end_layout

\begin_layout Itemize
Abbreviated state names, called 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
stabbs
\end_layout

\end_inset

 here, results from replacing everything up to the last space with 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step31>>=
\end_layout

\begin_layout Plain Layout

stabbs <- gsub(".* ", "", cities2) 
\end_layout

\begin_layout Plain Layout

stabbs
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This exploits a regular expression default, 
\begin_inset Quotes eld
\end_inset

greedy matching
\begin_inset Quotes erd
\end_inset

.
 The match goes as far as logically possible, so it picks up all of the
 spaces until the last space.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Step 4.
 Create full state names from abbreviations}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The project requires full state names, not just abbreviations.
\end_layout

\begin_layout Itemize
Use the named 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
state.name
\end_layout

\end_inset

 vector to pull out the long names, one for each abbreviation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step41>>=
\end_layout

\begin_layout Plain Layout

stnames <- state.name[stabbs]
\end_layout

\begin_layout Plain Layout

stnames
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Put that together in data.frame to finish}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<step42>>=
\end_layout

\begin_layout Plain Layout

reslt <- data.frame(address = cities, 
\end_layout

\begin_layout Plain Layout

            cities = cities3, st.abb = stabbs, 
\end_layout

\begin_layout Plain Layout

            st.name = stnames)
\end_layout

\begin_layout Plain Layout

head(reslt)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{How did we do this without RE?}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We have gotten this wrong by trying to split on both spaces and commas with
 the R function 
\begin_inset Quotes eld
\end_inset

strsplit
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
What do you do next?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{How did we do this without RE?}
\end_layout

\end_inset


\end_layout

\begin_layout ColumnsTopAligned

\end_layout

\begin_deeper
\begin_layout Column
6cm
\end_layout

\begin_layout Itemize
Don't be too intimidated by regular expressions
\end_layout

\begin_layout Itemize
Don't let your life be consumed by them either
\end_layout

\begin_layout Column
6cm
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "levithan_regular_2012"
literal "true"

\end_inset

 strike the right balance for me
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename importfigs/regexbook.gif
	width 6cm

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{References}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../../R"
options "apalike2"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Session}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sess10>>=
\end_layout

\begin_layout Plain Layout

sessionInfo()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<opts20, include=F>>=
\end_layout

\begin_layout Plain Layout

## Don't delete this.
 It puts the interactive session options
\end_layout

\begin_layout Plain Layout

## back the way they were.
 If this is compiled within a session
\end_layout

\begin_layout Plain Layout

## it is vital to do this.
\end_layout

\begin_layout Plain Layout

options(opts.orig)
\end_layout

\begin_layout Plain Layout

options(par.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
