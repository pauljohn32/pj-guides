#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usepackage{dcolumn}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{graphicx}
%\newcommand\makebeamertitle{\frame{\maketitle}}%
\renewcommand{\doiprefix}{doi:\kern-1pt}
\setlength{\bibsep}{10pt}

% use 'handout' to produce handouts
%\documentclass[handout]{beamer}
\usepackage{wasysym}
\usepackage{pgfpages}
%for bold upright roman in math for matrix algebra
\newcommand{\vn}[1]{\mbox{{\it #1}}}\newcommand{\vb}{\vspace{\baselineskip}}\newcommand{\vh}{\vspace{.5\baselineskip}}\newcommand{\vf}{\vspace{\fill}}\newcommand{\splus}{\textsf{S-PLUS}}\newcommand{\R}{\textsf{R}}

%%\input{theme/guidePreambleSweavel.tex} 
%%% From beamer slide:
\usepackage{Sweave}
%% 
%% This controls display of code chunks
\usepackage{ae,fancyvrb,relsize,listings}

\providecommand{\Sweavesize}{\normalsize}
\providecommand{\Rsize}{}
\renewcommand{\Rsize}{\normalsize}
\providecommand{\Routsize}{\scriptsize}

\providecommand{\Rcolor}{\color[rgb]{0.1, 0.1, 0.1}}
\providecommand{\Routcolor}{\color[rgb]{0.2, 0.2, 0.2}}
\providecommand{\Rcommentcolor}{\color[rgb]{0.101, 0.43, 0.432}}

\providecommand{\Rbackground}{\color[gray]{0.91}}
\providecommand{\Routbackground}{\color[gray]{0.935}}
% Can specify \color[gray]{1} for white background or just \color{white}

\lstdefinestyle{Rinput}{
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  basicstyle=\Rsize\Rcolor\ttfamily,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%,
  commentstyle=\Rcommentcolor\ttfamily,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1{==}{{=\,=}}2{--}{{-\,-}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
  backgroundcolor=\Rbackground,%
  numbers=left,%
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}%

% Other options of interest:
% frame=single,framerule=0.1pt,framesep=1pt,rulecolor=\color{blue},
% numbers=left,numberstyle=\tiny,stepnumber=1,numbersep=7pt,
% keywordstyle={\bf\Rcolor}

\lstdefinestyle{Routput}{fancyvrb=false,
  literate={~}{{$\sim$}}1{R^2}{{$R^{2}$}}2{^}{{$^{\scriptstyle\wedge}$}}1{R-squared}{{$R^{2}$}}2,%
  basicstyle=\Routcolor\Routsize\ttfamily,%
  backgroundcolor=\Routbackground,
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1 {==}{{=\,=}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},
  numbers=left,
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}

\renewenvironment{Schunk}{}{}
\renewenvironment{Sinput}{}{}
\let\Sinput\relax
\let\Scode\relax
\let\Soutput\relax
\lstnewenvironment{Sinput}{\lstset{style=Rinput}}{}
\lstnewenvironment{Scode}{\lstset{style=Rinput}}{}
\lstnewenvironment{Soutput}{\lstset{style=Routput}}{}
%%end paste in from guidePreambleSweavel.tex


\lstset{tabsize=2, breaklines=true, style=Rinput, breakatwhitespace=true}

\fvset{listparameters={\setlength{\topsep}{0em}}}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.90}
\usepackage{realboxes}
\providecommand*{\code}[1]{\texttt{#1}}
\renewcommand{\code}[1]{%
\Colorbox{light-gray}{#1}%
}%
%% end of paste

\usepackage[natbibapa]{apacite}

\definecolor{darkblue}{HTML}{1e2277}

%would be in beamerthemekucrmda%
\mode<presentation>
\definecolor{kublue}{RGB}{0,81,186}
\usefonttheme{professionalfonts}
\useoutertheme{infolines}
\useinnertheme{rounded}
%disable rounded for alert and example boxes%
\setbeamertemplate{blocks}[default]
\usecolortheme{whale}
\usecolortheme{orchid}
\setbeamercolor{structure}{bg=kublue,fg=kublue!90!black}
%\setbeamercolor{structure}{fg=kublue}
\setbeamercolor{frametitle}{bg=kublue}
\setbeamercolor{section in toc}{fg=kublue!40!black}

\setbeamertemplate{frametitle continuation}[from second]
\renewcommand\insertcontinuationtext{...}
\beamertemplatenavigationsymbolsempty
%end of beamerthemekucrmda%

%If you want bigger margins, try this:
\setbeamersize{text margin left=05mm,text margin right=10mm} 
\hypersetup{colorlinks,allcolors=.,urlcolor=darkblue}
%Following seems to have no effect now
%\usepackage{handoutWithNotes}
%\pgfpagesuselayout{3 on 1 with notes}[letterpaper, border shrink=5mm]

\titlegraphic{\includegraphics[width=6cm]{theme/logo}}
\logo{\includegraphics[width=5mm]{theme/logomini}}
\end_preamble
\options aspectratio=1609
\use_default_options false
\begin_modules
logicalmkup
sweave
natbibapa
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style \use_bibtopic false
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\branch R
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch semboot
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\branch cfalvm
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%following is LyX shortcut 
\backslash
vb for bold upright math for matrices
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\vb}[1]{\bm{\mathrm{#1}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch R
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% tmpout directory must exist first
\end_layout

\begin_layout Plain Layout

<<tmpout, echo=FALSE, include=FALSE, results=hide>>=
\end_layout

\begin_layout Plain Layout

tdir <- "tmpout"
\end_layout

\begin_layout Plain Layout

if(!dir.exists(tdir)) dir.create(tdir, showWarnings=FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{prefix.string=tmpout/t,split=T,ae=F,height=4.5,width=7}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, include=F, results=hide>>=
\end_layout

\begin_layout Plain Layout

opts.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=100, prompt = " ", continue = "  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE)
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

par.orig <- par(no.readonly = TRUE) 
\end_layout

\begin_layout Plain Layout

pjmar <- c(4.1, 4.1, 1.5, 2.1)
\end_layout

\begin_layout Plain Layout

options(SweaveHooks=list(fig=function() par(mar=pjmar, ps=12, xpd=F)))
\end_layout

\begin_layout Plain Layout

pdf.options(onefile=F,family="Times",pointsize=12)
\end_layout

\begin_layout Plain Layout

if(!file.exists("theme")) file.symlink("../../../../template/theme", "theme")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Title
Functions 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
functions
\end_layout

\end_inset


\end_layout

\begin_layout Author
Paul E.
 Johnson
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Johnson
\end_layout

\end_inset


\end_layout

\begin_layout Institute
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
1
\end_layout

\end_inset

Department of Political Science
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset

Center for Research Methods and Data Analysis, University of Kansas
\begin_inset Argument 1
status open

\begin_layout Plain Layout
K.U.
\end_layout

\end_inset


\end_layout

\begin_layout Date
2018
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following causes the table of contents to be shown at the beginning
 of every subsection.
 Delete this, if you do not want it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSection[]{
\end_layout

\begin_layout Plain Layout

  
\backslash
frame<beamer>{ 
\end_layout

\begin_layout Plain Layout

    
\backslash
frametitle{Outline}
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection] 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Outline}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Functions differentiate R from Others
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{R is comparatively more open}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
S started as a programming language for statistical calculations
\end_layout

\begin_layout Itemize
The programs S and R 
\begin_inset CommandInset citation
LatexCommand citep
key "RCore"
literal "true"

\end_inset

 accept that language
\end_layout

\begin_layout Itemize
Because S/R was first a language, it retains many of the programmer-friendly
 features of a programming language
\end_layout

\begin_layout Itemize
In comparison to, for example, SAS or Stata
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{Generations of S}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{columns}
\end_layout

\begin_layout Plain Layout

    
\backslash
column{7cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

    
\backslash
item The S Language-- John Chambers, et al.
 at Bell Labs, mid 1970s.
\end_layout

\begin_layout Plain Layout

    
\backslash
item There have been 4 generations of the S language.
\end_layout

\begin_layout Plain Layout

    
\backslash
item Many packages now were written in S3, but S4 has existed for 10 years.
\end_layout

\begin_layout Plain Layout

    
\backslash
item New frameworks constantly debated 
\backslash
& proposed
\end_layout

\begin_layout Plain Layout

    
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
column{5cm}
\end_layout

\begin_layout Plain Layout

    
\backslash
includegraphics[scale=0.35]{importfigs/BeckerNewSLanguage}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    S3: 
\backslash
emph{The New S Language} 1988
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
end{columns}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout

   
\backslash
frametitle{Is R a Branch from S?}
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{columns}
\end_layout

\begin_layout Plain Layout

     
\backslash
column{6cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       Ross Ihaka and Robert Gentleman.
 1996.
 {}``R: A language for data
\end_layout

\begin_layout Plain Layout

       analysis and graphics.''
\backslash
emph{ Journal of Computational and Graphical
\end_layout

\begin_layout Plain Layout

       Statistics}, 5(3):299-314.
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

      
\backslash
item R is
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

	     
\backslash
begin{enumerate}
\end_layout

\begin_layout Plain Layout

               
\backslash
item a competing dialect of the S language.
\end_layout

\begin_layout Plain Layout

               
\backslash
item a competing software 
\backslash
& package management system.
\end_layout

\begin_layout Plain Layout

          
\backslash
end{enumerate}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     
\backslash
column{6cm}
\end_layout

\begin_layout Plain Layout

     S pioneers now work to advance R.
\end_layout

\begin_layout Plain Layout

     
\backslash
includegraphics[scale=0.35]{importfigs/ChambersSoftwareForDataAnalysis}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     S4: John Chambers,
\backslash
emph{Software for Data Analysis: Programming with R}, Springer, 2008
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\backslash
end{columns}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{functions}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The R design allows both
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
inclusion of function collections (packages) prepared by others
\end_layout

\begin_layout Enumerate
easy creation of user functions written during a user's session
\end_layout

\end_deeper
\begin_layout Itemize
In CRMDA, I notice a pattern.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
We work on 1 project, write some functions.
\end_layout

\begin_layout Enumerate
Work on another project, write same/similar functions
\end_layout

\begin_layout Enumerate
We notice the common need, sometimes try to write general purpose functions
 that 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
would have worked in past projects
\end_layout

\begin_layout Enumerate
are useful in future projects.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Many functions in the 
\begin_inset Quotes eld
\end_inset

rockchalk
\begin_inset Quotes erd
\end_inset

 package, and all of the function in 
\begin_inset Quotes eld
\end_inset

kutils
\begin_inset Quotes erd
\end_inset

, are borne of necessity in that way.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Looking Good is Feeling Good}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When your project is finished, I wish your work would look like this
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Sweavesize{
\backslash
small}
\end_layout

\begin_layout Plain Layout


\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

## Functions defined at the top!
\end_layout

\begin_layout Plain Layout

myfn1 <- function (arg1, arg2){
\end_layout

\begin_layout Plain Layout

   ## lines here using arg1, arg2
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

myfn2 <- function (arg1, arg2, arg3){
\end_layout

\begin_layout Plain Layout

   ## caution: reused arg1, arg2 local varnames
\end_layout

\begin_layout Plain Layout

   ## arg1, arg2 different here than in myfn1
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

## When I check your work, I focus below, not above this line
\end_layout

\begin_layout Plain Layout

 a <- 7
\end_layout

\begin_layout Plain Layout

 b <- c(4, 4, 4, 4, 2)
\end_layout

\begin_layout Plain Layout

 d <- c("New York", "Cincinnati")
\end_layout

\begin_layout Plain Layout

 result1 <- myfn1(a, b)
\end_layout

\begin_layout Plain Layout

 result2 <- myfn2(result1, d)
\end_layout

\begin_layout Plain Layout


\backslash
end{Sinput}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{In a perfect world}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Each function would carry out an understandable purpose that we can believe
 is done correctly
\end_layout

\begin_layout Itemize
After we verify 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
myfn1
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
myfn2
\end_layout

\end_inset

, we'd never 
\begin_inset Quotes eld
\end_inset

read through
\begin_inset Quotes erd
\end_inset

 them again, they are no longer part of the proof-reading exercise.
 There may be 
\begin_inset Quotes eld
\end_inset

troubleshooting
\begin_inset Quotes erd
\end_inset

, but we expect those functions to work dependably.
\end_layout

\begin_layout Itemize
Some 
\begin_inset Quotes eld
\end_inset

art
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

judgment
\begin_inset Quotes erd
\end_inset

 is needed, to make a function work correctly, with just the right inputs.
\end_layout

\begin_deeper
\begin_layout Itemize
Novice error: bury input constants inside functions.
 Should be arguments instead.
\end_layout

\end_deeper
\begin_layout Itemize
Can relocate functions in a separate file, or into a package, and everything
 
\begin_inset Quotes eld
\end_inset


\emph on
just works
\emph default

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{Anatomy of a function}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item R allows us to create functions ``on the fly''.
  This is the
\end_layout

\begin_layout Plain Layout

    essential difference between a compiled language like C and an
\end_layout

\begin_layout Plain Layout

    interpreted language like R.
  While an R session is running, we
\end_layout

\begin_layout Plain Layout

    can add new capabilities to it.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item The artist Escher would like this:
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{quote}
\end_layout

\begin_layout Plain Layout

      There is a 
\backslash
textbf{function} named 
\backslash
textbf{function}.
 That is to say, 
\backslash
textbf{function} is a 
\backslash
textbf{function} that creates functions!
\end_layout

\begin_layout Plain Layout

    
\backslash
end{quote}
\end_layout

\begin_layout Plain Layout

Maybe that is more 
\backslash
emph{Dr.
 Seuss}.
\end_layout

\begin_layout Plain Layout

  
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{Anatomy of a function}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item 
\backslash
code{somethingGood()} is a new function, created by the 
\backslash
code{function()} function like so:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

somethingGood <- function(x, y, z){
\end_layout

\begin_layout Plain Layout

    ## code in here
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

    
\backslash
end{Sinput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item We Choose
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{enumerate} 
\end_layout

\begin_layout Plain Layout

     
\backslash
item the function's name, 
\backslash
code{somethingGood}.
 
\end_layout

\begin_layout Plain Layout

     
\backslash
item the names of the arguments, which are x, y and z
\end_layout

\begin_layout Plain Layout

   
\backslash
end{enumerate}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\backslash
item To "call" (i.e, "use") that function, we'll write 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

somethingGood(whatever1, whatever2, whatever3)
\end_layout

\begin_layout Plain Layout

    
\backslash
end{Sinput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Built-in R functions have short names like 
\backslash
code{ls()} 
\backslash
code{lm()}, 
\backslash
code{glm()}.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item The terms 
\backslash
textbf{arguments} and 
\backslash
textbf{parameters} are
\end_layout

\begin_layout Plain Layout

    interchangeable.
 I often say 
\backslash
textbf{inputs}.
 
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  
\backslash
item In R, we do not use the word ``options'' for function inputs.
 
\end_layout

\begin_layout Plain Layout

    That confuses people, who think you are referring to session options
 
\end_layout

\begin_layout Plain Layout

    and the R function called
\end_layout

\begin_layout Plain Layout

    
\backslash
texttt{options()}.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item 
\backslash
texttt{arguments} 
\backslash
emph{may} be specified with default values, as in
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

somethingGood <- function(x1 = 0, x2 = NULL){
\end_layout

\begin_layout Plain Layout

    
\backslash
end{Sinput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item After the squiggly brace, any valid R code can be used.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item 
\backslash
textbf{What happens in the function stays in the function.}  Does not affect
 same-named variables in the workspace.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item Return results: When when the function's work is finished, a
\end_layout

\begin_layout Plain Layout

    single object's name is included on the last line.
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

somethingGood <- function(x1 = 0, x2 = NULL){
\end_layout

\begin_layout Plain Layout

   ## suppose really interesting calculations create res, a result
\end_layout

\begin_layout Plain Layout

   res
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

    
\backslash
end{Sinput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\backslash
item Please remember.
\end_layout

\begin_layout Plain Layout

     
\backslash
begin{enumerate}
\end_layout

\begin_layout Plain Layout

       
\backslash
item The return includes one object
\end_layout

\begin_layout Plain Layout

       
\backslash
item That object can be a vector, a matrix, a data frame, or
\end_layout

\begin_layout Plain Layout

         a list including (one or more of) all of the above.
\end_layout

\begin_layout Plain Layout

     
\backslash
end{enumerate}
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

   
\backslash
item If a returned value includes a large matrix or data frame, 
\end_layout

\begin_layout Plain Layout

one is wise to NOT PRINT it into the session by default.
 Wrap your
\end_layout

\begin_layout Plain Layout

return value inside 
\backslash
code{invisible()}
\end_layout

\begin_layout Plain Layout


\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

somethingGood <- function(x1 = 0, x2 = NULL){
\end_layout

\begin_layout Plain Layout

## suppose really interesting calculations create 
\backslash
texttt{res}, a result
\end_layout

\begin_layout Plain Layout

   invisible(res)
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

 
\backslash
end{Sinput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      
\backslash
item Can break out of function by calling 
\end_layout

\begin_layout Plain Layout


\backslash
code{return()}.
 This offers a pleasant way to use 
\end_layout

\begin_layout Plain Layout

an if/then condition to stop work.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

  somethingGood <- function(x1 = 0, x2 = NULL){
\end_layout

\begin_layout Plain Layout

  ##  suppose you created res
\end_layout

\begin_layout Plain Layout

   if (someLogicalCondition) return(invisible(res))
\end_layout

\begin_layout Plain Layout

  ## otherwise, go on and revise res further.
\end_layout

\begin_layout Plain Layout

   invisible(res)
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

 
\backslash
end{Sinput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
newpage
\end_layout

\begin_layout Plain Layout


\backslash
item Functions can be nested.
 If there is a special 
\end_layout

\begin_layout Plain Layout

purpose function that you don't expect to use anywhere 
\end_layout

\begin_layout Plain Layout

else, hide it in the top of the function where you use it.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

somethingGood <- function(x1 = 0, x2 = NULL){
\end_layout

\begin_layout Plain Layout

   chore <- function (z){
\end_layout

\begin_layout Plain Layout

   ## calculation about z argument 
\end_layout

\begin_layout Plain Layout

   ## or x1 or x2 from enclosuring environment 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

   z.candidate <- R calculations involving x1 and x2
\end_layout

\begin_layout Plain Layout

   result <- chore(z.candidate)  
\end_layout

\begin_layout Plain Layout

   result
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{Sinput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
code{chore()} is available only within 
\backslash
code{somethingGood()}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{R Functions pass information ``by value''}
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Users should organize their information ``here'', in the current environment
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
the function must not be allowed to damage information.
\end_layout

\end_deeper
\begin_layout Itemize
Thus, we send info ``over there'' to a function
\end_layout

\begin_layout Itemize
We get back a new something.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

g <- somethingGood(whatever1, whatever2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
spawns a new thing 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
g
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Can clobber old things (on purpose?)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

whatever1 <- somethingGood(whatever1, whatever2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Emphasis
\emph default
.
 A function 
\series bold
DOES NOT
\series default
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
change variables we give to the function
\end_layout

\begin_layout Itemize
change other variables in the user workspace
\end_layout

\end_deeper
\begin_layout Itemize
The super assignment 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
<<-
\end_layout

\end_inset

 allows an exception to this, but  R Core recommends we avoid it.
 If you must do this, the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
assign()
\end_layout

\end_inset

 function is a safer method.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Roxygen markup is increasingly popular
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Standardize notation about functions}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Programmers (me) often lazy about leaving behind clear documentation.
 
\end_layout

\begin_layout Itemize
They like to write functions, not instructions
\end_layout

\begin_layout Itemize
The Literate Programming movement (@1990) began as a way to blend documentation
 with functions, to encourage programmers to try harder
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Standardize notation about functions}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Roxygen style uses text markup like so
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

##' terse statement of function purpose
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' paragraph about function
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' Paragraphs of "Details"
\end_layout

\begin_layout Plain Layout

##' @param x words about x
\end_layout

\begin_layout Plain Layout

##' @param y words about y
\end_layout

\begin_layout Plain Layout

##' @return a description of the function's return
\end_layout

\begin_layout Plain Layout

##' @author Paul Johnson <pauljohn@@ku.edu>
\end_layout

\begin_layout Plain Layout

myfunction <- function(x, y){
\end_layout

\begin_layout Plain Layout

   ## imagine code here
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Roxygen can be turned into package documentation}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Hadley Wickham has provided many useful R packages, including roxygen2
\end_layout

\begin_layout Itemize
Write roxygen markup, then run the
\begin_inset Flex Code
status open

\begin_layout Plain Layout
roxygenize
\end_layout

\end_inset

 function that creates documentation.
\end_layout

\begin_layout Itemize
Details about package markup:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://r-pkgs.had.co.nz/man.html#text-formatting
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Example of a function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{reverse a factor's levels}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In many projects, we have 
\begin_inset Quotes eld
\end_inset

Likert Scales
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Often, users have factor variables for which the 
\begin_inset Quotes eld
\end_inset

polarity
\begin_inset Quotes erd
\end_inset

 must be reversed.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
high-to-low must become low-to-high
\end_layout

\begin_layout Itemize
However, they usually have some values like 
\begin_inset Quotes eld
\end_inset

Skip
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Not Avail
\begin_inset Quotes erd
\end_inset

 that they want to leave at the end of the output.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{If we did not have to worry about the special values, this would
 be easy as pie!}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<revs10>>=
\end_layout

\begin_layout Plain Layout

##' Reverse a factor's levels
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' This requires a factor variable
\end_layout

\begin_layout Plain Layout

##' @param x A factor variable
\end_layout

\begin_layout Plain Layout

##' @return A reversed factor variable
\end_layout

\begin_layout Plain Layout

##' @author Paul Johnson <pauljohn@@ku.edu>
\end_layout

\begin_layout Plain Layout

revs <- function (x){
\end_layout

\begin_layout Plain Layout

    if (!is.factor(x)) stop("your variable is not a factor")
\end_layout

\begin_layout Plain Layout

    rlevels <- rev(levels(x))
\end_layout

\begin_layout Plain Layout

    factor(x, levels = rlevels)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Lets test that}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<revs20>>=
\end_layout

\begin_layout Plain Layout

x <- c("hot", "hot", "cold", "medium", "medium", "hot")
\end_layout

\begin_layout Plain Layout

zz1 <- ordered(x, levels = c("hot", "medium", "cold"))
\end_layout

\begin_layout Plain Layout

x2 <- revs(zz1)
\end_layout

\begin_layout Plain Layout

table(x2, zz1, dnn = list("x2", "zz1 is the original"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Dance to fix the "End of the List" levels}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Here is a function that allows the user to specify some level names that
 are supposed to be kept out of the sorting, and they are placed at the
 end of the list of levels.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<revs30>>=
\end_layout

\begin_layout Plain Layout

##' Reverse the levels in a factor, tolerating end of list values
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' This is a simple literal reversal, with one exception.
 If there are
\end_layout

\begin_layout Plain Layout

##' valid levels named "Skip" or "DNP", they will be moved back to the
\end_layout

\begin_layout Plain Layout

##' end of the list.
\end_layout

\begin_layout Plain Layout

##' @param x a factor variable
\end_layout

\begin_layout Plain Layout

##' @param eol values to be kept at the end of the list.
 Defaults are "Skip" and "DNP"
\end_layout

\begin_layout Plain Layout

##' @return a new factor variable with reversed values
\end_layout

\begin_layout Plain Layout

##' @author Paul Johnson <pauljohn@@ku.edu>
\end_layout

\begin_layout Plain Layout

reverse <- function(x, eol = c("Skip", "DNP")){
\end_layout

\begin_layout Plain Layout

    if (!is.factor(x)) stop("x was not a factor")
\end_layout

\begin_layout Plain Layout

    rlevels <- rev(levels(x))
\end_layout

\begin_layout Plain Layout

    for (jj in eol){
\end_layout

\begin_layout Plain Layout

        if (yyy <- grep(jj, rlevels)){
\end_layout

\begin_layout Plain Layout

            rlevels <- c(rlevels[-yyy], jj)
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    y <- factor(x, levels = rlevels)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Lets test that}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<revs40>>=
\end_layout

\begin_layout Plain Layout

x3 <- c("Skip", "hot", "hot", "cold", "Not Avail", "medium", "medium", "hot")
\end_layout

\begin_layout Plain Layout

zz2 <- ordered(x3, levels = c("hot", "Skip", "medium", "cold", "Not Avail"))
\end_layout

\begin_layout Plain Layout

x4 <- reverse(zz2, eol = c("Skip", "Not Avail"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
It worked.
 See?
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<revs41>>=
\end_layout

\begin_layout Plain Layout

table(x4, zz2, dnn = list("x4", "zz2 has 'Skip' and 'Not Avail'"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Works fine on data without any Skips or such}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<revs50>>=
\end_layout

\begin_layout Plain Layout

x5 <- reverse(zz1, eol = NULL)
\end_layout

\begin_layout Plain Layout

table(x5, zz1, dnn = list("x5", "zz1 is the original"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
You will get an error, however, if your eol input includes a level that
 does not actually exist.
 (
\begin_inset Quotes eld
\end_inset

Its never a good idea to leave no work for tomorrow,
\begin_inset Quotes erd
\end_inset

 I always say).
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Problems/Opportunities to be Aware Of
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{R uses "lexical scope"}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The highest, available-everywhere 
\begin_inset Quotes eld
\end_inset

environment
\begin_inset Quotes erd
\end_inset

 is the user workspace.
\end_layout

\begin_layout Itemize
Using a function creates an 
\begin_inset Quotes eld
\end_inset

closure
\begin_inset Quotes erd
\end_inset

 within which changes are contained.
\end_layout

\begin_layout Itemize
However, in R a function can 
\begin_inset Quotes eld
\end_inset

look up
\begin_inset Quotes erd
\end_inset

 for something that it thinks it needs.
 It can reach 
\begin_inset Quotes eld
\end_inset

up
\begin_inset Quotes erd
\end_inset

 to the user workspace and pull in information.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{That outward-looking tendency is helpful}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If your functions use the same information, perhaps it is too boring or
 tedious to name those things as variables in your function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fun10>>=
\end_layout

\begin_layout Plain Layout

x <- 30
\end_layout

\begin_layout Plain Layout

aa <- letters[5:10]
\end_layout

\begin_layout Plain Layout

getXYZ <- function(m1, m2){
\end_layout

\begin_layout Plain Layout

   res1 <- paste(m1, x, sep = "_")
\end_layout

\begin_layout Plain Layout

   res2 <- paste(aa, m2, sep = "_what?_")
\end_layout

\begin_layout Plain Layout

   list(res1, res2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

getXYZ(m1 = c(1, 2, 3), m2 = c(98, 99))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Notice: The function went and retrieved 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
x
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
aa
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 from the workspace
\end_layout

\begin_layout Itemize
They were not passed in as arguments
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{That outward-looking tendency may be harmful}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Fail! If the x and aa in the workspace are not the same ones you wanted
 in your function
\end_layout

\begin_layout Itemize
That's why I'm very worried about undefined variables in functions.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
In C or similar language, we would get an error
\end_layout

\begin_layout Itemize
In R, we don't get an error or even a warning if R finds something that
 
\emph on
seems
\emph default
 to fit.
\end_layout

\end_deeper
\begin_layout Itemize
Because commonly used variable names like 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
x
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
y
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
dat
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 are floating about both in the workspace and in functions I write, I'm
 especially vulnerable to this trouble.
 
\end_layout

\begin_layout Itemize
The package 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
codetools
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 has a function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
checkUsage()
\end_layout

\end_inset

 which can help identify undefined variables.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Another example
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{A "Variable Key" example}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The input data set had names like 
\begin_inset Quotes eld
\end_inset

V1
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

V2
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Formula $\ldots$
\end_inset

, 
\begin_inset Quotes eld
\end_inset

V99
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Client provided an Excel sheet with new names like this
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
oldname
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
newname
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Respondent ID
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Respondent Age
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
city - residence
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
state - residence
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize
We want to respect their 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
newname
\end_layout

\end_inset

 choices as much as possible, but
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
we cannot use those as column names (spaces and some minus signs).
\end_layout

\end_deeper
\begin_layout Itemize
We also want consistency, so we decided to make all of these lower case.
\end_layout

\begin_layout Itemize
Can fix by running 4 commands on 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
newname
\end_layout

\end_inset

 before replacing it:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=T>>=
\end_layout

\begin_layout Plain Layout

newname <- c("Respondent ID", "Respondent Age", "city - residence", "state
 - residence")
\end_layout

\begin_layout Plain Layout

## Change space to underscore
\end_layout

\begin_layout Plain Layout

newname <- gsub(" ", "_", newname, fixed = TRUE)
\end_layout

\begin_layout Plain Layout

## Replace minus with underscore
\end_layout

\begin_layout Plain Layout

newname <- gsub("-", "_", newname, fixed = TRUE)
\end_layout

\begin_layout Plain Layout

## Replace multiple underscores with one underscore
\end_layout

\begin_layout Plain Layout

newname <- gsub("(_)
\backslash

\backslash
1+", "_", newname)
\end_layout

\begin_layout Plain Layout

## Lower case
\end_layout

\begin_layout Plain Layout

newname <- tolower(newname)
\end_layout

\begin_layout Plain Layout

newname
\end_layout

\begin_layout Plain Layout

##colnames(dat) <- newname
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{A "Variable Key" example}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If we import 10 data frames with that same issue, then we have to have 40
 lines of code to fix their names.
 
\end_layout

\begin_layout Itemize
I'd rather sequester those commands in a function,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

##' Remove spaces, minus signs, and change letters to lower case
\end_layout

\begin_layout Plain Layout

##'
\end_layout

\begin_layout Plain Layout

##' Cleans up a character string.
 Does not do comprenensive
\end_layout

\begin_layout Plain Layout

##' cleanup, just minus, spaces and capitals.
 Could extend to other flaws
\end_layout

\begin_layout Plain Layout

##' @param x A vector of character string.
\end_layout

\begin_layout Plain Layout

##' @return cleaned vector of strings
\end_layout

\begin_layout Plain Layout

##' @author pauljohn@@ku.edu
\end_layout

\begin_layout Plain Layout

cleanVarName <- function(x){
\end_layout

\begin_layout Plain Layout

    x <- gsub(" ", "_", x, fixed = TRUE)
\end_layout

\begin_layout Plain Layout

    x <- gsub("-", "_", x, fixed = TRUE)
\end_layout

\begin_layout Plain Layout

    x <- gsub("(_)
\backslash

\backslash
1+", "_", x)
\end_layout

\begin_layout Plain Layout

    x <- tolower(x)
\end_layout

\begin_layout Plain Layout

    x
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
And then run one line per data frame
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

colnames(dat1) <- cleanVarName(colnames(dat1))
\end_layout

\begin_layout Plain Layout

colnames(dat2) <- cleanVarName(colnames(dat2))
\end_layout

\begin_layout Plain Layout

## ...
\end_layout

\begin_layout Plain Layout

colnames(dat10) <- cleanVarNames(colname(dat10))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Possibly even a for loop that saves so much typing.
 If we had the data.frame names within a vector, or if we were importing
 files from a list, we could automate this.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Interacting with function objects
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{browser() and debug()}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are 3 things to try to get a handle on what your function does.
 
\end_layout

\begin_layout Enumerate
Type the function's name, check out the way R looks at your code.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

getXYZ
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note: No parens, no arguments
\end_layout

\begin_layout Standard
This works with any R function.
 Type its name.
 Even 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
q
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
Ask R to 
\begin_inset Quotes eld
\end_inset

stop
\begin_inset Quotes erd
\end_inset

 whenever it tries to use your function with 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
debug()
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

debug(getXYZ)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After that, when you use that function, R will offer an interactive view
 of what that function does.
\end_layout

\begin_layout Itemize
result depends on which editor you are using, I'll demonstrate.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
debug cheatsheet
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
keystroke
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
result
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
move into next sub-process or next line
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Enter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
run current line (similar to 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
c
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
let the function run
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
abort the function at its current position
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Put the function call 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
browser()
\end_layout

\end_inset

 in the middle of your function's code.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

getXYZ <- function(m1, m2){
\end_layout

\begin_layout Plain Layout

   res1 <- paste(m1, x, sep = "_")
\end_layout

\begin_layout Plain Layout

   res2 <- paste(aa, m2, sep = "_what?_")
\end_layout

\begin_layout Plain Layout

   browser()
\end_layout

\begin_layout Plain Layout

   list(res1, res2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is the same as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
debug()
\end_layout

\end_inset

, except that the function runs up to the point at which you inserted 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
browser()
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Itemize
especially handy when you have a long function and you don't want to run
 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 over and over again.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{The Ease of Creating Functions}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The ease of creating (and packaging) new functions is, no doubt, an important
 part of the R success story
\end_layout

\begin_layout Itemize
We hope these slides give the user some confidence about writing functions,
 or reading more about writing functions.
\end_layout

\begin_layout Itemize
There is a chapter about writing functions in the 
\emph on
Introduction to R
\emph default
 that is provided with R itself.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Additional Readings}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Additional readings that I enjoy are
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Matloff, Norman.
 S.
 (2011).
 
\emph on
The Art of R Programming: a tour of statistical software design
\emph default
.
 San Francisco: No Starch Press.
\end_layout

\begin_layout Itemize
Chambers, J.
 M.
 (2008).
 
\emph on
Software for Data Analysis: programming with R
\emph default
.
 London: Springer.
 
\end_layout

\begin_layout Itemize
Wickham, Hadley (2014).
 Advanced R.
 Boca Raton, FL: CRC.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{vignettes in the rockchalk package}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Rstyle: Commentary about how your code ought to look.
\end_layout

\begin_layout Itemize
Rchaeology: more advanced function writing tips, especially concentrating
 on terminology about 
\begin_inset Quotes eld
\end_inset

calls
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

eval
\begin_inset Quotes erd
\end_inset

, and R functions to interpret function arguments.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{References}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../../R"
options "apalike2"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Session}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sess10>>=
\end_layout

\begin_layout Plain Layout

sessionInfo()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<opts20, include=F>>=
\end_layout

\begin_layout Plain Layout

## Don't delete this.
 It puts the interactive session options
\end_layout

\begin_layout Plain Layout

## back the way they were.
 If this is compiled within a session
\end_layout

\begin_layout Plain Layout

## it is vital to do this.
\end_layout

\begin_layout Plain Layout

options(opts.orig)
\end_layout

\begin_layout Plain Layout

options(par.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
