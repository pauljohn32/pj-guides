#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usepackage{dcolumn}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{graphicx}
\renewcommand{\doiprefix}{doi:\kern-1pt}
\setlength{\bibsep}{10pt}

% use 'handout' to produce handouts
%\documentclass[handout]{beamer}
\usepackage{wasysym}
\usepackage{pgfpages}
%for bold upright roman in math for matrix algebra
\newcommand{\vn}[1]{\mbox{{\it #1}}}\newcommand{\vb}{\vspace{\baselineskip}}\newcommand{\vh}{\vspace{.5\baselineskip}}\newcommand{\vf}{\vspace{\fill}}\newcommand{\splus}{\textsf{S-PLUS}}\newcommand{\R}{\textsf{R}}

%%\input{theme/guidePreambleSweavel.tex} 
%%% From beamer slide:
\usepackage{Sweave}
%% 
%% This controls display of code chunks
\usepackage{ae,fancyvrb,relsize,listings}

\providecommand{\Sweavesize}{\normalsize}
\providecommand{\Rsize}{}
\renewcommand{\Rsize}{\normalsize}
\providecommand{\Routsize}{\scriptsize}

\providecommand{\Rcolor}{\color[rgb]{0.1, 0.1, 0.1}}
\providecommand{\Routcolor}{\color[rgb]{0.2, 0.2, 0.2}}
\providecommand{\Rcommentcolor}{\color[rgb]{0.101, 0.43, 0.432}}

\providecommand{\Rbackground}{\color[gray]{0.91}}
\providecommand{\Routbackground}{\color[gray]{0.935}}
% Can specify \color[gray]{1} for white background or just \color{white}

\lstdefinestyle{Rinput}{
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  basicstyle=\Rsize\Rcolor\ttfamily,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%,
  commentstyle=\Rcommentcolor\ttfamily,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1{==}{{=\,=}}2{--}{{-\,-}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
  backgroundcolor=\Rbackground,%
  numbers=left,%
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}%

% Other options of interest:
% frame=single,framerule=0.1pt,framesep=1pt,rulecolor=\color{blue},
% numbers=left,numberstyle=\tiny,stepnumber=1,numbersep=7pt,
% keywordstyle={\bf\Rcolor}

\lstdefinestyle{Routput}{fancyvrb=false,
  literate={~}{{$\sim$}}1{R^2}{{$R^{2}$}}2{^}{{$^{\scriptstyle\wedge}$}}1{R-squared}{{$R^{2}$}}2,%
  basicstyle=\Routcolor\Routsize\ttfamily,%
  backgroundcolor=\Routbackground,
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1 {==}{{=\,=}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},
  numbers=left,
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}

\renewenvironment{Schunk}{}{}
\renewenvironment{Sinput}{}{}
\let\Sinput\relax
\let\Scode\relax
\let\Soutput\relax
\lstnewenvironment{Sinput}{\lstset{style=Rinput}}{}
\lstnewenvironment{Scode}{\lstset{style=Rinput}}{}
\lstnewenvironment{Soutput}{\lstset{style=Routput}}{}
%%end paste in from guidePreambleSweavel.tex


\lstset{tabsize=2, breaklines=true, style=Rinput, breakatwhitespace=true}

\fvset{listparameters={\setlength{\topsep}{0em}}}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.90}
\usepackage{realboxes}
\providecommand*{\code}[1]{\texttt{#1}}
\renewcommand{\code}[1]{%
\Colorbox{light-gray}{#1}%
}%
%% end of paste

\usepackage[natbibapa]{apacite}

\definecolor{darkblue}{HTML}{1e2277}

%would be in beamerthemekucrmda%
\mode<presentation>
\definecolor{kublue}{RGB}{0,81,186}
\usefonttheme{professionalfonts}
\useoutertheme{infolines}
\useinnertheme{rounded}
%disable rounded for alert and example boxes%
\setbeamertemplate{blocks}[default]
\usecolortheme{whale}
\usecolortheme{orchid}
\setbeamercolor{structure}{bg=kublue,fg=kublue!90!black}
%\setbeamercolor{structure}{fg=kublue}
\setbeamercolor{frametitle}{bg=kublue}
\setbeamercolor{section in toc}{fg=kublue!40!black}

\setbeamertemplate{frametitle continuation}[from second]
\renewcommand\insertcontinuationtext{...}
\beamertemplatenavigationsymbolsempty
%end of beamerthemekucrmda%

%If you want bigger margins, try this:
\setbeamersize{text margin left=05mm,text margin right=10mm} 
\hypersetup{colorlinks,allcolors=.,urlcolor=darkblue}
%Following seems to have no effect now
%\usepackage{handoutWithNotes}
%\pgfpagesuselayout{3 on 1 with notes}[letterpaper, border shrink=5mm]

\titlegraphic{\includegraphics[width=6cm]{theme/logo}}
\logo{\includegraphics[width=5mm]{theme/logomini}}
\end_preamble
\options aspectratio=1609
\use_default_options false
\begin_modules
logicalmkup
sweave
natbibapa
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style \use_bibtopic false
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\branch R
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch semboot
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\branch cfalvm
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%following is LyX shortcut 
\backslash
vb for bold upright math for matrices
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\vb}[1]{\bm{\mathrm{#1}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch R
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% tmpout directory must exist first
\end_layout

\begin_layout Plain Layout

<<tmpout, echo=FALSE, include=FALSE, results=hide>>=
\end_layout

\begin_layout Plain Layout

tdir <- "tmpout"
\end_layout

\begin_layout Plain Layout

if(!dir.exists(tdir)) dir.create(tdir, showWarnings=FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{prefix.string=tmpout/t,split=T,ae=F,height=4.5,width=7}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, include=F, results=hide>>=
\end_layout

\begin_layout Plain Layout

opts.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=100, prompt = " ", continue = "  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE)
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

par.orig <- par(no.readonly = TRUE) 
\end_layout

\begin_layout Plain Layout

pjmar <- c(4.1, 4.1, 1.5, 2.1)
\end_layout

\begin_layout Plain Layout

options(SweaveHooks=list(fig=function() par(mar=pjmar, ps=12, xpd=F)))
\end_layout

\begin_layout Plain Layout

pdf.options(onefile=F,family="Times",pointsize=12)
\end_layout

\begin_layout Plain Layout

if(!file.exists("theme")) file.symlink("../../../../template/theme", "theme")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Title
Merge 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
merge
\end_layout

\end_inset


\end_layout

\begin_layout Author
Zack Roman
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Roman
\end_layout

\end_inset


\end_layout

\begin_layout Institute
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
1
\end_layout

\end_inset

Center for Research Methods and Data Analysis 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
CRMDA
\end_layout

\end_inset


\end_layout

\begin_layout Date
2018
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following causes the table of contents to be shown at the beginning
 of every subsection.
 Delete this, if you do not want it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSection[]{
\end_layout

\begin_layout Plain Layout

  
\backslash
frame<beamer>{ 
\end_layout

\begin_layout Plain Layout

    
\backslash
frametitle{Outline}
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection] 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Outline}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Goals of This Session}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
textbf{Conceptual:}
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Types of merges
\end_layout

\begin_layout Plain Layout


\backslash
item Merging vocabulary
\end_layout

\begin_layout Plain Layout


\backslash
item When to use merges 
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
textbf{Skill Building:}
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Practicing merging variants
\end_layout

\begin_layout Plain Layout


\backslash
item Different implementations of merging in R
\end_layout

\begin_layout Plain Layout


\backslash
item Dangers associated with improper merging and how to avoid them
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%%%Begin Slides
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
section{What is Merging}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Small Example}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item{This is an example provided with R 
\backslash
citep{RCore}}
\end_layout

\begin_layout Plain Layout

 
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

<<  echo=F>>=
\end_layout

\begin_layout Plain Layout

#Build Some Data
\end_layout

\begin_layout Plain Layout

authors <- data.frame(
\end_layout

\begin_layout Plain Layout

  surname = I(c("Tukey", "Venables", "Tierney", "Ripley", "McNeil")),
\end_layout

\begin_layout Plain Layout

  nationality = c("US", "Australia", "US", "UK", "Australia"),
\end_layout

\begin_layout Plain Layout

  deceased = c("yes", rep("no", 4)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Build Another Data Set
\end_layout

\begin_layout Plain Layout

books <- data.frame(
\end_layout

\begin_layout Plain Layout

  name = I(c("Tukey", "Venables", "Tierney",
\end_layout

\begin_layout Plain Layout

             "Ripley", "Ripley", "McNeil", "R Core")),
\end_layout

\begin_layout Plain Layout

  title = c("Exploratory Data Analysis",
\end_layout

\begin_layout Plain Layout

            "Modern Applied Statistics",
\end_layout

\begin_layout Plain Layout

            "LISP-STAT",
\end_layout

\begin_layout Plain Layout

            "Spatial Statistics", "Stochastic Simulation",
\end_layout

\begin_layout Plain Layout

            "Interactive Data Analysis",
\end_layout

\begin_layout Plain Layout

            "An Introduction to R"),
\end_layout

\begin_layout Plain Layout

  other_author = c(NA, "Ripley", NA, NA, NA, NA,
\end_layout

\begin_layout Plain Layout

                   "Venables & Smith"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<se10, echo=T>>=
\end_layout

\begin_layout Plain Layout

authors
\end_layout

\begin_layout Plain Layout

books
\end_layout

\begin_layout Plain Layout

merge(x = authors, y = books, by.x = "surname", by.y = "name")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Merge Arguments}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<  echo=T, eval = FALSE>>=
\end_layout

\begin_layout Plain Layout

merge(x, y, by.x, by.y, by, incomparables, sort, all.x, all.y, all )
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{enumerate}
\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
code{x} Specifies the left data set
\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
code{y} Specifies the right data set
\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
code{by.x, by.y, by} specifies the key as a character
\end_layout

\begin_layout Plain Layout

  string.
 
\backslash
code{by} is common to both 
\backslash
code{x} and 
\backslash
code{y}.
\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
code{incomparables} provides values in the key to not be used
\end_layout

\begin_layout Plain Layout

  for matching, such as NA, blank space, or NaN (not a number).
\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
code{sort} Logical (TRUE or FALSE), sorts the output 
\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
code{all.x, all.y, all} Logical, will help us determine the behavior of the
 merge.
 We will talk more about this as we go
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
section{Types of Merges}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Binding is not a merging}
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item The functions 
\backslash
code{rbind()} and 
\backslash
code{cbind()} can be used to
\end_layout

\begin_layout Plain Layout

    ``stack'' matrices on top of each other (rows bound together), or
\end_layout

\begin_layout Plain Layout

    place them side by side (columns bound together)
\end_layout

\begin_layout Plain Layout


\backslash
item Binding puts data sets together, but if the rows (or columns) are not
 in
\end_layout

\begin_layout Plain Layout

  exactly the same order, it will corrupt the result.
 Binding two data
\end_layout

\begin_layout Plain Layout

  sets is not merging
\end_layout

\begin_layout Plain Layout


\backslash
item Merging takes into account a "Key" variable (typically an ID 
\backslash
#
\end_layout

\begin_layout Plain Layout

  or Name), so that the correct rows are aligned with each other.
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{SQL Terminology}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item SQL = ``Structured Query Language''.
 Very widely used general
\end_layout

\begin_layout Plain Layout

    purpose data-base framework.
\end_layout

\begin_layout Plain Layout

  
\backslash
item R merge developed in isolation, used different terminology.
\end_layout

\begin_layout Plain Layout

  
\backslash
item Next we show that the SQL terms ``left join'', ``inner join''
\end_layout

\begin_layout Plain Layout

    and so forth can be achieved by properly setting the value of the
\end_layout

\begin_layout Plain Layout

    merges 
\backslash
code{all} parameter (
\backslash
code{all}, 
\backslash
code{all.x}, and
\end_layout

\begin_layout Plain Layout

    
\backslash
code{all.y})
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Left Join} 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The "Left Join" is used when the goal data set should 
\backslash
textbf{only} have rows that
\end_layout

\begin_layout Plain Layout

are present in X.
 The key variable is used to scan Y for matches,
\end_layout

\begin_layout Plain Layout

which are then merged with the X rows.
\end_layout

\begin_layout Plain Layout

<<lj10, echo=F>>=
\end_layout

\begin_layout Plain Layout

dat_legs <- data.frame(animal = I(c("dog", "cats", "human", "snake", "tree")),
 legs = c(4, 4, 2, 0, 0))
\end_layout

\begin_layout Plain Layout

dat_fur <- data.frame(animal = I(c("dog", "cats", "human", "bird")), fur
 = c("yes", "Mostly", "No", " No"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<lj20, echo=T>>=
\end_layout

\begin_layout Plain Layout

dat_legs
\end_layout

\begin_layout Plain Layout

dat_fur
\end_layout

\begin_layout Plain Layout

merge(x = dat_legs, y = dat_fur, by = "animal", all.x = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Setting "all.x" to 
\backslash
textbf{TRUE} produces a "Left Join".
 The output
\end_layout

\begin_layout Plain Layout

data will contain rows that are in x and there will be additional columns
 aligned from y.
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Left Join}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[]{importfigs/left_join_ven.pdf}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Left Join Switched}
\end_layout

\begin_layout Plain Layout

Let's do a Left Join again, but switch the data sets.
\end_layout

\begin_layout Plain Layout

<<lj30, echo=T>>=
\end_layout

\begin_layout Plain Layout

dat_legs
\end_layout

\begin_layout Plain Layout

dat_fur
\end_layout

\begin_layout Plain Layout

merge(x = dat_fur, y = dat_legs, by = "animal", all.x = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Situations calling for Left Join}
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item You want to investigate the relationship between fur and legs in
\end_layout

\begin_layout Plain Layout

  animals
\end_layout

\begin_layout Plain Layout


\backslash
item You have a data set of the animals you are interested in and
\end_layout

\begin_layout Plain Layout

  their fur status
\end_layout

\begin_layout Plain Layout


\backslash
item You obtain a list of 
\backslash
textbf{all} animals legs count
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Key = Animal Name
\end_layout

\begin_layout Plain Layout


\backslash
item Output data is the length of the fur data set
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item You want to investigate the effect of tuition on retention rate
\end_layout

\begin_layout Plain Layout

  in Florida
\end_layout

\begin_layout Plain Layout


\backslash
item You have Floridian school tuition rates data set
\end_layout

\begin_layout Plain Layout


\backslash
item You obtain a nationwide data set of retention rates
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Key = School Name
\end_layout

\begin_layout Plain Layout


\backslash
item Output data is the length of the tuition rates data set
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Inner Join}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The "Inner join" is used when the goal data set should only have
\end_layout

\begin_layout Plain Layout

rows that have keys in both the X and Y data.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

all = FALSE is the default setting.
 It is not required to achieve an inner join
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<ij10,  echo=T>>=
\end_layout

\begin_layout Plain Layout

dat_legs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dat_fur
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

merge(x = dat_legs, y = dat_fur, by = "animal")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Omitting 
\backslash
code{all}, or setting 
\backslash
code{all = FALSE} produces an "Inner Join".
 The output data will only contain rows that have matching key values on
\end_layout

\begin_layout Plain Layout


\backslash
textbf{both} input data sets.
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Inner Join}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[]{importfigs/inner_join.pdf}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Qualities of Inner Joins}
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Pro, result data set will be more complete than other merges.
 
\end_layout

\begin_layout Plain Layout


\backslash
item Con, result data set loses more information than other merges.
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Full Join}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Full Join keeps all data rows, filling in unmatched rows with missing
\end_layout

\begin_layout Plain Layout

values.
\end_layout

\begin_layout Plain Layout

<<fj10,  echo=T>>=
\end_layout

\begin_layout Plain Layout

dat_legs
\end_layout

\begin_layout Plain Layout

dat_fur
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Full Join}
\end_layout

\begin_layout Plain Layout

<<fj20,  echo=T>>=
\end_layout

\begin_layout Plain Layout

merge(x = dat_legs, y = dat_fur, by = "animal", all = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Full Join}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[]{importfigs/full_join.pdf}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Properties of Full Joins}
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Output set includes rows for all cases from both data sets
\end_layout

\begin_layout Plain Layout


\backslash
item There may be lots of "missing" values where rows are not present in
 one set or the other
\end_layout

\begin_layout Plain Layout


\backslash
item You don't lose any information, but the value of wholly missing rows
 may be low
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
section{Practice}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Practice}
\end_layout

\begin_layout Plain Layout

<<  echo=F>>=
\end_layout

\begin_layout Plain Layout

dat1 <- data.frame(Company = I(c("A", "B", "C", "D", "E")), Earnings = c(126345,
 492012, 234512, -28124, 128675))
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

dat2 <- data.frame(Company = I(c("A", "B", "C", "F")), Region = c("Midwest",
 "Southeast", "West", " North"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

dat1
\end_layout

\begin_layout Plain Layout

dat2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

Can you:
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Left Join the data so we have all Earnings in the Output set.
\end_layout

\begin_layout Plain Layout


\backslash
item Left Join the data so we have all Regions in the Output set.
\end_layout

\begin_layout Plain Layout


\backslash
item Inner Join the data so we have no missing data.
\end_layout

\begin_layout Plain Layout


\backslash
item Full Join the data so we have everything in the Output set.
 
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Practice: Answer 1}
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

merge(x = dat1, y = dat2, by = "Company", all.x = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Left Join the data so we have all Earnings in the Output set.
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Practice: Answer 2}
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

merge(x = dat2, y = dat1, by = "Company", all.x = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Left Join the data so we have all Regions in the Output set.
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Practice: Answer 3}
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

merge(x = dat1, y = dat2, by = "Company", all = FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Inner Join the data so we have no missing data.
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Practice: Answer 4}
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

merge(x = dat1, y = dat2, by = "Company", all = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Full Join the data so we have everything in the Output set.
 
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
section{Merging Long Data: Multiple IDs}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Longitudinal Data}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Data comes in 2 typical formats
\end_layout

\begin_layout Plain Layout


\backslash
begin{enumerate}
\end_layout

\begin_layout Plain Layout


\backslash
item Wide: Columns that describe units of observation (one row per state,
\end_layout

\begin_layout Plain Layout

  or per school, or per child)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tabular}{rr}
\end_layout

\begin_layout Plain Layout

    state & region
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

    
\backslash
hline
\end_layout

\begin_layout Plain Layout

    Alabama & south
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

    Alaska & north
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

    $
\backslash
vdots$ & 
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

  
\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout


\backslash
item Long: Repeated observations, several times for each unit.
 
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{tabular}{rrr}
\end_layout

\begin_layout Plain Layout

year & state & poverty
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

2000 & Alabama & 13
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

2001 & Alabama & 12
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

$
\backslash
vdots$ & & 
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

2017 & Wisconsin & 11
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\begin_layout Plain Layout


\backslash
item We often want to merge the information about the units from the
\end_layout

\begin_layout Plain Layout

  wide format onto the longitudinal data that is in the long format.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Example: Merging Wide data onto Longitudinal Data}
\end_layout

\begin_layout Plain Layout

<<long10,  echo=F>>=
\end_layout

\begin_layout Plain Layout

dat_long <- data.frame(
\end_layout

\begin_layout Plain Layout

  child_id = I(c("110", "110", "110", "210", "210", "210")), Time = c(1,
 2, 3, 1, 2, 3), FSIQ = c(98, 102, 104, 89, 91, 95))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dat_edu <- data.frame(child_id = I(c("210", "110")), par_edu = c("BA", "HS"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The longitudinal data is about children measured at 3 time points
\end_layout

\begin_layout Plain Layout

<<long50,  echo=T>>=
\end_layout

\begin_layout Plain Layout

dat_long
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Separate data about the education of parents is available
\end_layout

\begin_layout Plain Layout

for some children
\end_layout

\begin_layout Plain Layout

<<long60,  echo=T>>=
\end_layout

\begin_layout Plain Layout

dat_edu
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Longitudinal Data: Long}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<long70  echo=T>>=
\end_layout

\begin_layout Plain Layout

merge(x = dat_long, y = dat_edu, by = "child_id", all = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item This is a full join
\end_layout

\begin_layout Plain Layout

  
\backslash
item No problems encountered, result 
\backslash
emph{seems} adequate.
 
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize} 
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Points of caution in the full join}
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{enumerate}
\end_layout

\begin_layout Plain Layout

      
\backslash
item If information about some families is missing from the
\end_layout

\begin_layout Plain Layout

        wide data, then missing values will be created in the result
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

        Example:
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

        We change the wide data by removing one child
\end_layout

\begin_layout Plain Layout

<<long71a,  echo=F, include=F>>=
\end_layout

\begin_layout Plain Layout

dat_edu2 <- data.frame(child_id = I(c("210")), par_edu =
\end_layout

\begin_layout Plain Layout

c("BA"))
\end_layout

\begin_layout Plain Layout

@   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<long71b, echo=F>>=
\end_layout

\begin_layout Plain Layout

dat_edu2
\end_layout

\begin_layout Plain Layout

@   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<long71c>>=
\end_layout

\begin_layout Plain Layout

merge(x = dat_long, y = dat_edu2, by = "child_id", all = TRUE)
\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\begin_layout Plain Layout

    
\backslash
item If wide data includes information about children/families
\end_layout

\begin_layout Plain Layout

        that are not tracked in the long data, then the full join will
\end_layout

\begin_layout Plain Layout

        create ``extra'' all missing lines in the longitudinal part.
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    Example:
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

<<long80,  echo=F, include=F>>=
\end_layout

\begin_layout Plain Layout

dat_edu2 <- data.frame(child_id = I(c("210", "110",  "400", "501")), par_edu
 =
\end_layout

\begin_layout Plain Layout

c("BA", "HS", "ES", "HS"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

We only change 
\backslash
code{dat
\backslash
_edu} by inserting additional rows for some
\end_layout

\begin_layout Plain Layout

children.
 
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

<<long82, echo=F>>=
\end_layout

\begin_layout Plain Layout

dat_edu2
\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Why would this happen in real life? Suppose these are child/parent
\end_layout

\begin_layout Plain Layout

data rows from a different study in which some of the children
\end_layout

\begin_layout Plain Layout

participated.
  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\begin_layout Plain Layout

<<long85>>=
\end_layout

\begin_layout Plain Layout

merge(x = dat_long, y = dat_edu2, by = "child_id", all = TRUE)
\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item Some users may prefer to think of this as a left join, keeping
\end_layout

\begin_layout Plain Layout

  only rows about children in a study (and omitting rows about families
\end_layout

\begin_layout Plain Layout

  of children who are not in the study)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

<<long86>>=
\end_layout

\begin_layout Plain Layout

merge(x = dat_long, y = dat_edu2, by = "child_id", all.x = TRUE, all.y = FALSE)
\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}    
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Longitudinal Data: Long Data by Long Data}
\end_layout

\begin_layout Plain Layout

<<  echo=F>>=
\end_layout

\begin_layout Plain Layout

dat_long1 <- data.frame(
\end_layout

\begin_layout Plain Layout

  child_id = I(c("110", "110", "110", "210", "210", "210")),
\end_layout

\begin_layout Plain Layout

  Time = c(1, 2, 3, 1, 2, 3),
\end_layout

\begin_layout Plain Layout

  FSIQ = c(98, 102, 104, 89, 91, 95))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dat_long2 <- data.frame(
\end_layout

\begin_layout Plain Layout

  child_id = c("210", "210", "210", "110", "110", "110"),
\end_layout

\begin_layout Plain Layout

  Time = c(1, 2, 3, 1, 2, 3),
\end_layout

\begin_layout Plain Layout

  Reaction = c(0.34, 0.28, 0.19, 0.33, 0.32, 0.28), 
\end_layout

\begin_layout Plain Layout

  stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

dat_long1
\end_layout

\begin_layout Plain Layout

dat_long2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

Notice here, the dangers are repeating ID's in both data sets.
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Longitudinal Data: Long Data by Long Data}
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

head(merge(x = dat_long1, y = dat_long2, by = "child_id", all.x = TRUE),
 12)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

This is 
\backslash
textbf{WRONG!!!} look closely.
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Longitudinal Data: Long Data by Long Data}
\end_layout

\begin_layout Plain Layout

To solve our problem we provide multiple Keys to the "by" argument:
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

merge(x = dat_long1, y = dat_long2, by = c("child_id", "Time"), all.x = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

That is much better, notice the fix:
\end_layout

\begin_layout Plain Layout

<<  echo=T, evel = FALSE>>=
\end_layout

\begin_layout Plain Layout

by = c("child_id", "Time")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Longitudinal Data: Long Data by Long Data}
\end_layout

\begin_layout Plain Layout

An intuitive way to determine when you need to 
\end_layout

\begin_layout Plain Layout

supply multiple keys to the "by" argument is to ask yourself:
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Can every occurrence of my ID variable be uniquely identified ?
\end_layout

\begin_layout Plain Layout


\backslash
item If not, which other variable is necessary to produce an uniquely identified
 ID ?
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Longitudinal Data: QUIZ}
\end_layout

\begin_layout Plain Layout

Which columns together create the proper uniquely identifiable key set?
\end_layout

\begin_layout Plain Layout

<<  echo=F>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dat_nat <- data.frame(
\end_layout

\begin_layout Plain Layout

  ID = c("USA", "USA", "USA", "USA", "UK", "UK", "UK", "UK"),
\end_layout

\begin_layout Plain Layout

  Year = c(1990, 1990, 1991, 1991, 1990, 1990, 1991, 1991),
\end_layout

\begin_layout Plain Layout

  Quarter = c("Q1", "Q2", "Q1", "Q2", "Q1", "Q2", "Q1", "Q2"),
\end_layout

\begin_layout Plain Layout

  population = rnorm(8, 10, 1),
\end_layout

\begin_layout Plain Layout

  illnesses = rnorm(8, 100, 10), stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

dat_nat
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Longitudinal Data: A Useful way to Identify Keys}
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

table(dat_nat$ID)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

Not unique, we need another key
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

table(dat_nat$ID, dat_nat$Quarter)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

getting closer
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

table(dat_nat$ID, dat_nat$Quarter, dat_nat$Year)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

Winner! Each data point can be uniquely identified as being collected from
 a country, during a year, and a quarter.
 
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
section{Typical Issues and How to Avoid Them}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Different Key Names}
\end_layout

\begin_layout Plain Layout

<<  echo=F>>=
\end_layout

\begin_layout Plain Layout

datX <- data.frame(
\end_layout

\begin_layout Plain Layout

  ID = c("USA", "USA", "USA", "USA", "UK", "UK", "UK", "UK"),
\end_layout

\begin_layout Plain Layout

  Year = c(1990, 1990, 1991, 1991, 1990, 1990, 1991, 1991),
\end_layout

\begin_layout Plain Layout

  Quarter = c("Q1", "Q2", "Q1", "Q2", "Q1", "Q2", "Q1", "Q2"),
\end_layout

\begin_layout Plain Layout

  pop = rnorm(8, 10, 1), illnesses = rnorm(8, 100, 10), 
\end_layout

\begin_layout Plain Layout

  stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

datY <- data.frame(
\end_layout

\begin_layout Plain Layout

  Country = c("USA", "USA", "USA", "USA", "UK", "UK", "UK", "UK"),
\end_layout

\begin_layout Plain Layout

  year = c(1990, 1990, 1991, 1991, 1990, 1990, 1991, 1991),
\end_layout

\begin_layout Plain Layout

  Semester = c("Q1", "Q2", "Q1", "Q2", "Q1", "Q2", "Q1", "Q2"),
\end_layout

\begin_layout Plain Layout

  percipitation = rnorm(8, 10, 1), cars = rnorm(8, 100, 10), 
\end_layout

\begin_layout Plain Layout

  stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

head(datX)
\end_layout

\begin_layout Plain Layout

head(datY)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Different Key Names}
\end_layout

\begin_layout Plain Layout

<<  echo=F>>=
\end_layout

\begin_layout Plain Layout

datX <- data.frame(
\end_layout

\begin_layout Plain Layout

  ID = I(c("USA", "USA", "USA", "USA", "UK", "UK", "UK", "UK")),
\end_layout

\begin_layout Plain Layout

  Year = c(1990, 1990, 1991, 1991, 1990, 1990, 1991, 1991),
\end_layout

\begin_layout Plain Layout

  Quarter = I(c("Q1", "Q2", "Q1", "Q2", "Q1", "Q2", "Q1", "Q2")),
\end_layout

\begin_layout Plain Layout

  pop = rnorm(8, 10, 1), illnesses = rnorm(8, 100, 10))
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

datY <- data.frame(
\end_layout

\begin_layout Plain Layout

  Country = I(c(
\end_layout

\begin_layout Plain Layout

  "USA", "USA", "USA", "USA", "UK", "UK", "UK", "UK")),
\end_layout

\begin_layout Plain Layout

  year = c(1990, 1990, 1991, 1991, 1990, 1990, 1991, 1991),
\end_layout

\begin_layout Plain Layout

  Semester = I(c("Q1", "Q2", "Q1", "Q2", "Q1", "Q2", "Q1", "Q2")),
\end_layout

\begin_layout Plain Layout

  percipitation = rnorm(8, 10, 1),cars = rnorm(8, 100, 10))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

head(datX)
\end_layout

\begin_layout Plain Layout

head(datY)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Different Key Names}
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

merge(x = datX, y = datY, by.x = c("ID", "Year", "Quarter"), by.y = c("Country",
 "year", "Semester"), all = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Matching Missing}
\end_layout

\begin_layout Plain Layout

<<  echo=F>>=
\end_layout

\begin_layout Plain Layout

datX <- data.frame(
\end_layout

\begin_layout Plain Layout

  ID = I(c(
\end_layout

\begin_layout Plain Layout

  "111", "112", "NA", "114", "115", "116", "NA")), cars = rbinom(7, 10,
 0.5), fear = rnorm(7, 100, 10))
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

datY <- data.frame(ID = I( c("111", "NA", "113", "114", "115", "NA", "117")),
 pets = rbinom(7, 10, 0.5))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

datX
\end_layout

\begin_layout Plain Layout

datY
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Matching Missing:The Problem}
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

merge(x = datX, y = datY, by = "ID", all.x = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
textbf{Oops!} That is a dangerous outcome:  Keys with NA values will be
 row-aligned
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Matching Missing:The Remedy}
\end_layout

\begin_layout Plain Layout


\backslash
code{incomparables} to the rescue
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

merge(x = datX, y = datY, by = "ID", all= FALSE, incomparables = "NA")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

That is much better! Always remember to use the 
\backslash
code{incomparables} 
\end_layout

\begin_layout Plain Layout

argument if you have any missing data on keys.
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
section{Further Help and Resources}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{kutils::mergeCheck}
\end_layout

\begin_layout Plain Layout

<<  echo=F>>=
\end_layout

\begin_layout Plain Layout

library(kutils)
\end_layout

\begin_layout Plain Layout

df1 <- data.frame(id = 1:7, x = rnorm(7))
\end_layout

\begin_layout Plain Layout

df2 <- data.frame(id = c(2:6, 9:10), x = rnorm(7))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

df1
\end_layout

\begin_layout Plain Layout

df2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Kutils::mergeCheck}
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

library(kutils)
\end_layout

\begin_layout Plain Layout

mergeCheck(df1, df2, by = "id")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
code{mergeCheck} alerts you to potential merging issues
\end_layout

\begin_layout Plain Layout


\backslash
item ID 1 and 7 in the 
\backslash
code{df1} dont have matching IDs in 
\backslash
code{df2}
\end_layout

\begin_layout Plain Layout


\backslash
item ID 9 and 10, in the 
\backslash
code{df1} dont have matching id in 
\backslash
code{df2}
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{kutils::mergeCheck}
\end_layout

\begin_layout Plain Layout

<<  echo=F>>=
\end_layout

\begin_layout Plain Layout

library(kutils)
\end_layout

\begin_layout Plain Layout

df1 <- data.frame(idx = c(1:5, NA, NaN), x = rnorm(7))
\end_layout

\begin_layout Plain Layout

df2 <- data.frame(idy = c(2:6, 9:10), x = rnorm(7))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

df1
\end_layout

\begin_layout Plain Layout

df2
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Kutils::mergeCheck}
\end_layout

\begin_layout Plain Layout

<<  echo=T>>=
\end_layout

\begin_layout Plain Layout

mergeCheck(df1, df2, by.x = "idx", by.y = "idy")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item In this situation we are warned of:
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Unacceptable key values: NA and NaN
\end_layout

\begin_layout Plain Layout


\backslash
item Again, unmatched IDs: 1,6,7,9,10
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{kutils::mergeCheck}
\end_layout

\begin_layout Plain Layout

Load 
\backslash
code{library(kutils)} and run 
\backslash
code{example(mergeCheck)} to learn more about the function.
 Our kutils package has much more to offer! check out the kutils help page
 with 
\backslash
code{help(package = "kutils")}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{More Information}
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item{The CRMDA has a guide available on merges:}
\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item 
\backslash
url{https://crmda.ku.edu/guide-41-merge_R_SQL}
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{References}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../../R"
options "apalike2"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Session}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sess10>>=
\end_layout

\begin_layout Plain Layout

sessionInfo()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<opts20, include=F>>=
\end_layout

\begin_layout Plain Layout

## Don't delete this.
 It puts the interactive session options
\end_layout

\begin_layout Plain Layout

## back the way they were.
 If this is compiled within a session
\end_layout

\begin_layout Plain Layout

## it is vital to do this.
\end_layout

\begin_layout Plain Layout

options(opts.orig)
\end_layout

\begin_layout Plain Layout

options(par.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
