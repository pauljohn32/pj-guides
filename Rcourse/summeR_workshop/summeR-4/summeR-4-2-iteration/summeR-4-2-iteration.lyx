#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usepackage{dcolumn}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{graphicx}
%\newcommand\makebeamertitle{\frame{\maketitle}}%
\renewcommand{\doiprefix}{doi:\kern-1pt}
\setlength{\bibsep}{10pt}

% use 'handout' to produce handouts
%\documentclass[handout]{beamer}
\usepackage{wasysym}
\usepackage{pgfpages}
%for bold upright roman in math for matrix algebra
\newcommand{\vn}[1]{\mbox{{\it #1}}}\newcommand{\vb}{\vspace{\baselineskip}}\newcommand{\vh}{\vspace{.5\baselineskip}}\newcommand{\vf}{\vspace{\fill}}\newcommand{\splus}{\textsf{S-PLUS}}\newcommand{\R}{\textsf{R}}

%%\input{theme/guidePreambleSweavel.tex} 
%%% From beamer slide:
\usepackage{Sweave}
%% 
%% This controls display of code chunks
\usepackage{ae,fancyvrb,relsize,listings}

\providecommand{\Sweavesize}{\normalsize}
\providecommand{\Rsize}{}
\renewcommand{\Rsize}{\normalsize}
\providecommand{\Routsize}{\scriptsize}

\providecommand{\Rcolor}{\color[rgb]{0.1, 0.1, 0.1}}
\providecommand{\Routcolor}{\color[rgb]{0.2, 0.2, 0.2}}
\providecommand{\Rcommentcolor}{\color[rgb]{0.101, 0.43, 0.432}}

\providecommand{\Rbackground}{\color[gray]{0.91}}
\providecommand{\Routbackground}{\color[gray]{0.935}}
% Can specify \color[gray]{1} for white background or just \color{white}

\lstdefinestyle{Rinput}{
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  basicstyle=\Rsize\Rcolor\ttfamily,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%,
  commentstyle=\Rcommentcolor\ttfamily,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1{==}{{=\,=}}2{--}{{-\,-}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
  backgroundcolor=\Rbackground,%
  numbers=left,%
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}%

% Other options of interest:
% frame=single,framerule=0.1pt,framesep=1pt,rulecolor=\color{blue},
% numbers=left,numberstyle=\tiny,stepnumber=1,numbersep=7pt,
% keywordstyle={\bf\Rcolor}

\lstdefinestyle{Routput}{fancyvrb=false,
  literate={~}{{$\sim$}}1{R^2}{{$R^{2}$}}2{^}{{$^{\scriptstyle\wedge}$}}1{R-squared}{{$R^{2}$}}2,%
  basicstyle=\Routcolor\Routsize\ttfamily,%
  backgroundcolor=\Routbackground,
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1 {==}{{=\,=}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},
  numbers=left,
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}

\renewenvironment{Schunk}{}{}
\renewenvironment{Sinput}{}{}
\let\Sinput\relax
\let\Scode\relax
\let\Soutput\relax
\lstnewenvironment{Sinput}{\lstset{style=Rinput}}{}
\lstnewenvironment{Scode}{\lstset{style=Rinput}}{}
\lstnewenvironment{Soutput}{\lstset{style=Routput}}{}
%%end paste in from guidePreambleSweavel.tex


\lstset{tabsize=2, breaklines=true, style=Rinput, breakatwhitespace=true}

\fvset{listparameters={\setlength{\topsep}{0em}}}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.90}
\usepackage{realboxes}
\providecommand*{\code}[1]{\texttt{#1}}
\renewcommand{\code}[1]{%
\Colorbox{light-gray}{#1}%
}%
%% end of paste

\usepackage[natbibapa]{apacite}

\definecolor{darkblue}{HTML}{1e2277}

%would be in beamerthemekucrmda%
\mode<presentation>
\definecolor{kublue}{RGB}{0,81,186}
\usefonttheme{professionalfonts}
\useoutertheme{infolines}
\useinnertheme{rounded}
%disable rounded for alert and example boxes%
\setbeamertemplate{blocks}[default]
\usecolortheme{whale}
\usecolortheme{orchid}
\setbeamercolor{structure}{bg=kublue,fg=kublue!90!black}
%\setbeamercolor{structure}{fg=kublue}
\setbeamercolor{frametitle}{bg=kublue}
\setbeamercolor{section in toc}{fg=kublue!40!black}

\setbeamertemplate{frametitle continuation}[from second]
\renewcommand\insertcontinuationtext{...}
\beamertemplatenavigationsymbolsempty
%end of beamerthemekucrmda%

%If you want bigger margins, try this:
\setbeamersize{text margin left=05mm,text margin right=10mm} 
\hypersetup{colorlinks,allcolors=.,urlcolor=darkblue}
%Following seems to have no effect now
%\usepackage{handoutWithNotes}
%\pgfpagesuselayout{3 on 1 with notes}[letterpaper, border shrink=5mm]

\titlegraphic{\includegraphics[width=6cm]{theme/logo}}
\logo{\includegraphics[width=5mm]{theme/logomini}}
\end_preamble
\options aspectratio=1609
\use_default_options false
\begin_modules
logicalmkup
sweave
natbibapa
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style \use_bibtopic false
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\branch R
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch semboot
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\branch cfalvm
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%following is LyX shortcut 
\backslash
vb for bold upright math for matrices
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\vb}[1]{\bm{\mathrm{#1}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch R
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% tmpout directory must exist first
\end_layout

\begin_layout Plain Layout

<<tmpout, echo=FALSE, include=FALSE, results=hide>>=
\end_layout

\begin_layout Plain Layout

tdir <- "tmpout"
\end_layout

\begin_layout Plain Layout

if(!dir.exists(tdir)) dir.create(tdir, showWarnings=FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{prefix.string=tmpout/t,split=T,ae=F,height=4.5,width=7}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, include=F, results=hide>>=
\end_layout

\begin_layout Plain Layout

opts.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=100, prompt = " ", continue = "  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE)
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

par.orig <- par(no.readonly = TRUE) 
\end_layout

\begin_layout Plain Layout

pjmar <- c(4.1, 4.1, 1.5, 2.1)
\end_layout

\begin_layout Plain Layout

options(SweaveHooks=list(fig=function() par(mar=pjmar, ps=12, xpd=F)))
\end_layout

\begin_layout Plain Layout

pdf.options(onefile=F,family="Times",pointsize=12)
\end_layout

\begin_layout Plain Layout

if(!file.exists("theme")) file.symlink("../../../../template/theme", "theme")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Title
Iteration 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
iteration
\end_layout

\end_inset


\end_layout

\begin_layout Author
Paul E.
 Johnson
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\begin_layout Institute
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
1
\end_layout

\end_inset

Department of Political Science
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset

Center for Research Methods and Data Analysis, University of Kansas
\begin_inset Argument 1
status open

\begin_layout Plain Layout
K.U.
\end_layout

\end_inset


\end_layout

\begin_layout Date
2018
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following causes the table of contents to be shown at the beginning
 of every subsection.
 Delete this, if you do not want it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSection[]{
\end_layout

\begin_layout Plain Layout

  
\backslash
frame<beamer>{ 
\end_layout

\begin_layout Plain Layout

    
\backslash
frametitle{Outline}
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection] 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Outline}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{R Frame of Mind}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item Iteration is commonly needed in R  
\backslash
citep{RCore}
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

    
\backslash
item repeat the same thing over and over with new samples
\end_layout

\begin_layout Plain Layout

    
\backslash
item process several subgroups of data (compare cities)
\end_layout

\begin_layout Plain Layout

    
\backslash
item apply various functions to one data set
\end_layout

\begin_layout Plain Layout

    
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item Some idioms make code faster.
\end_layout

\begin_layout Plain Layout

  
\backslash
item Some idioms make code more understandable.
\end_layout

\begin_layout Plain Layout

  
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{For Loops and Iterators}
\end_layout

\begin_layout Plain Layout

     
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item I'm cutting out a lot of philosophical BS about iterators here.
 I hope nobody says "We want to hear a lot more computer science theory
 about keys, iterators, and index variables"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item All computer languages with which I'm aware have some variant of a
 
\backslash
textbf{for loop}, a way to say "here are 14 rows, process each one in order"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item R has for loops, as well as a family of "apply" functions that are
 very widely used.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   
\backslash
item Many usages of the "apply" functions require the user to write little
 functions (that's why it is important to review functions before working
 on apply).
\end_layout

\begin_layout Plain Layout

  
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{R has lots of ways to do things over and over}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

    
\backslash
item for and while loops: similar to (easier to write than) C and Java
\end_layout

\begin_layout Plain Layout

    
\backslash
item The R (s)(l)(m)(v)apply family functions: similar to less-well-known
 languages like Lisp
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
code{apply}: for matrices.
 Process all rows or columns
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
code{lapply}: process each element in a list
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
code{sapply}: lapply with output simplification
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
code{vapply}: improved, safer version of sapply
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
code{replicate}: shorthand for sapply for simple simulations
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
code{mapply}: for functions that need several arguments,
\end_layout

\begin_layout Plain Layout

      separately drawn from separate vectors or lists
\end_layout

\begin_layout Plain Layout

    
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item Today, lets contrast for and lapply
\end_layout

\begin_layout Plain Layout

  
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{What are the key differences}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Most people will emphasize
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
speed
\end_layout

\begin_layout Itemize
code clarity
\end_layout

\end_deeper
\begin_layout Itemize
Another important difference is 
\begin_inset Quotes eld
\end_inset

scope
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Itemize
the apply functions operate in an closure, cannot alter objects in the workspace
 except by the return value
\end_layout

\begin_layout Itemize
for loop can alter objects in the workspace because its calculations are
 not done in an enclosed environment.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
for loop
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{for looping}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
It is easier to teach this with examples than jargon.
\end_layout

\begin_layout Itemize
Example 1.
 Suppose 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
i is integers 1 through 10
\end_layout

\begin_layout Itemize
x and y are 2 vectors.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- vector()
\end_layout

\begin_layout Plain Layout

y <- vector()
\end_layout

\begin_layout Plain Layout

for (i in 1:10) {
\end_layout

\begin_layout Plain Layout

   x[i] <- log(i)
\end_layout

\begin_layout Plain Layout

   y[i] <- exp(x[i])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

cbind(i = 1:10, x, y)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Aha! 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
exp()
\end_layout

\end_inset

 undoes 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
log()
\end_layout

\end_inset

.
 HS math was correct.
\end_layout

\end_deeper
\begin_layout Itemize
Example 2.
 Suppose
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
x
\end_layout

\end_inset

 already exists
\end_layout

\begin_layout Itemize
The recommended method of creating the index is the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
seq_along()
\end_layout

\end_inset

 function, saves us the trouble of counting how many elements there are.
\end_layout

\begin_layout Itemize
Because I don't want to convey the impression that the index always has
 to be called 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

, I will name this index 
\begin_inset Quotes eld
\end_inset

johnelway
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- log(1:10)
\end_layout

\begin_layout Plain Layout

y <- vector()
\end_layout

\begin_layout Plain Layout

for (johnelway in seq_along(x)){
\end_layout

\begin_layout Plain Layout

  y[johnelway] <- exp(x[johnelway])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

cbind(johnelway = seq_along(x), x, y)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Nervous people say 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
vector()
\end_layout

\end_inset

 makes this slower.
 
\begin_inset Quotes eld
\end_inset

We should tell R how many elements there are supposed to be first: 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
vector(mode = "numeric", length = 10)
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

.
 I agree.
\end_layout

\begin_layout Itemize
We can take elements out of R lists with 
\begin_inset Quotes eld
\end_inset

[[
\begin_inset Quotes eld
\end_inset

 notation.
 Suppose
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
myL
\end_layout

\end_inset

 is an R list
\end_layout

\begin_layout Itemize
The individual pieces in which are obtained by writing 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
myL[[i]]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This function 
\begin_inset Quotes eld
\end_inset

steps through
\begin_inset Quotes erd
\end_inset

 the 10 elements and replaces them with something else.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

myL <- list()
\end_layout

\begin_layout Plain Layout

## pretend myL is full of some precious objects
\end_layout

\begin_layout Plain Layout

for (i in seq_along(myL)){
\end_layout

\begin_layout Plain Layout

  myL[[i]] <- someFunctionYouMakeUp(myL[[i]])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results from 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
someFunctionYouMakeUp
\end_layout

\end_inset

 will replace original values in 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
myL
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
It is not necessary to obliterate your old list elements.
 We can create a new list to store the output.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

newL <- list()
\end_layout

\begin_layout Plain Layout

for (i in 1:10){
\end_layout

\begin_layout Plain Layout

  newL[[i]] <- someFunctionYouMakeUp(myL[[i]])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The important thing to notice is that the for loop is allowed to write on
 objects in the global workspace.
\end_layout

\begin_layout Itemize
Hence it is a handy way to cycle through a collection of data frames.
\end_layout

\begin_layout Itemize
Again, the efficiency experts will criticize this, rightly so.
 In a big problem, it would be much faster to create with 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
newL <- vector(
\begin_inset Quotes eld
\end_inset

list
\begin_inset Quotes erd
\end_inset

, length = 10)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Why do for loops have a bad reputation?}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
People who are unfamiliar with R think that it is 
\begin_inset Quotes eld
\end_inset

just like
\begin_inset Quotes erd
\end_inset

 C or Fortran, in which for loops are fast.
\end_layout

\begin_deeper
\begin_layout Itemize
they also assume that reading elements with 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
x[i]
\end_layout

\end_inset

, or writing elements with 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
x[i] <- 7
\end_layout

\end_inset

 runs fine.
\end_layout

\end_deeper
\begin_layout Itemize
A loopy sort of person would want to write this:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rep10,echo=T,include=T>>=
\end_layout

\begin_layout Plain Layout

## Declare a vector heinz57, do something to each element
\end_layout

\begin_layout Plain Layout

heinz57 <- vector(mode = "numeric", length = 57)
\end_layout

\begin_layout Plain Layout

for(i in 1:57) {
\end_layout

\begin_layout Plain Layout

    heinz57[i] <- log(i)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
It will be much faster in R to simply write this:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rep20,echo=T,include=T>>=
\end_layout

\begin_layout Plain Layout

x1 <- log(1:57)
\end_layout

\begin_layout Plain Layout

identical(x1, heinz57)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The difference is in 
\series bold
vectorization
\series default
.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Repeatedly accessing individual pieces with 
\begin_inset Quotes eld
\end_inset

[
\begin_inset Quotes eld
\end_inset

 causes a slowdown.
\end_layout

\end_deeper
\begin_layout Itemize
The story I tell myself is that the second method 
\begin_inset Quotes eld
\end_inset

pushes computation into the R compute kernel
\begin_inset Quotes erd
\end_inset

, while the first method requires 
\begin_inset Quotes eld
\end_inset

a constant interchange of information between the user workspace (to update
 heinz57[i]) and the R kernel
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
I'm not against for loops on principle, but only because in practice I find
 most newcomers cause very slow code if they rely on them.
\end_layout

\begin_layout Itemize
Example comparing 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ifelse()
\end_layout

\end_inset

 function and for loop.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The built-in function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ifelse()
\end_layout

\end_inset

 offers a convenient method of recoding a variable.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Description
ifelse(logical_condition, x, y): if logical is true, return 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
x
\end_layout

\end_inset

; if not, return 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
y
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This is vectorized, so it can be applied to columns in a data frame, as
 in
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

dat$z <- ifelse(dat$x1 > dat$y, dat$x1, dat$x2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
That is faster than a for loop:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

dat$z2 <- NA
\end_layout

\begin_layout Plain Layout

for(i in 1:NROW(dat)){
\end_layout

\begin_layout Plain Layout

    dat$z2[i] <- if(dat$x1[i] > dat$y[i]){
\end_layout

\begin_layout Plain Layout

        dat$x1[i] 
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        dat$x2[i]
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
dat$z2
\end_layout

\end_inset

 has to be initialized before the for loop
\end_layout

\begin_layout Itemize
And the code is a lot longer, more prone to typographical error
\end_layout

\end_deeper
\begin_layout Itemize
The loopy approach to R coding it is s-l-o-w because of 
\end_layout

\begin_deeper
\begin_layout Itemize
over-use of 
\begin_inset Quotes eld
\end_inset

[
\begin_inset Quotes eld
\end_inset

.
\end_layout

\begin_layout Itemize
failure to 
\begin_inset Quotes eld
\end_inset

preallocate
\begin_inset Quotes erd
\end_inset

 structures into which values are being filled.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{About pre-allocating memory for storage}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In my R website, I have an example 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "data_structures-lists"
target "http://pj.freefaculty.org/guides/Rcourse/data_structures/data_structures-lists.html"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

 which shows that even if we use a 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
for
\end_layout

\end_inset

 loop, we can speed up the result considerably if we allocate a list of
 a given size before we use it.
\end_layout

\begin_layout Itemize
Example, fill 10,000 matrices into a list.
 This goes much faster if we do not create the storage list by the lazy
 way (
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
list()
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

) and instead run this:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

alist <- vector(mode = "list", length = 10000)
\end_layout

\begin_layout Plain Layout

for(i in 1:10000){
\end_layout

\begin_layout Plain Layout

    alist2[[i]] <- matrix(rnorm(9), ncol = 3)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Because this grabs storage slots for 10,000 items, it does not have to pause
 and
\end_layout

\begin_deeper
\begin_layout Itemize
create a new list with one more element
\end_layout

\begin_layout Itemize
copy the old list members to the new list
\end_layout

\begin_layout Standard
every time it goes through the loop.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
lapply
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{``lapply()'': Do same thing to all Elements of a List}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item 
\backslash
texttt{lapply(someList, someFunction)} will 
\end_layout

\begin_layout Plain Layout

   
\backslash
begin{enumerate}
\end_layout

\begin_layout Plain Layout

    
\backslash
item take a list of things
\end_layout

\begin_layout Plain Layout

    
\backslash
item apply the function to each item
\end_layout

\begin_layout Plain Layout

    
\backslash
item returning a new list as result.
\end_layout

\begin_layout Plain Layout

    
\backslash
end{enumerate}
\end_layout

\begin_layout Plain Layout

   
\backslash
item Use case
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

      
\backslash
item we have 50 data sets on people in 50 states
\end_layout

\begin_layout Plain Layout

      
\backslash
item we have a function that can build a summary tables or plot for each
 of these
\end_layout

\begin_layout Plain Layout

      
\backslash
item we lapply those functions to the list
\end_layout

\begin_layout Plain Layout

     
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{jumboData example}
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      
\backslash
item Suppose there are 150 data frames saved in a list named 
\backslash
code{jumboData}.
 Here is code you can run to actually generate 150 data frames:
\end_layout

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

set.seed(234)
\end_layout

\begin_layout Plain Layout

getDF <- function(i) {data.frame(ds = i, x1 = rnorm(100), x2 = rnorm(100))}
\end_layout

\begin_layout Plain Layout

jumboData <- lapply(1:150, getDF)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

      
\backslash
item This creates the data generator function, and "lapplies" it to 1:150.
 If you want to, investigate that by looking at individual pieces, 
\backslash
code{jumboData[[144]]} for example.
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item We obtain the means of each one with the built-in function 
\backslash
code{colMeans()} 
\end_layout

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colMresults <- lapply(jumboData, colMeans)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item What did we get?
\end_layout

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

is.list(colMresults)
\end_layout

\begin_layout Plain Layout

print(colMresults[[1]])
\end_layout

\begin_layout Plain Layout

print(colMresults[[2]])
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

	The result is a list, with 150 vectors, each summarizing one of the data
 frames inside 
\backslash
code{jumboData}.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item We have many (MANY) ways in R to stack those 150 vectors into a matrix.
 Here's one:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colMstacked <- do.call(rbind, colMresults)
\end_layout

\begin_layout Plain Layout

dim(colMstacked)
\end_layout

\begin_layout Plain Layout

head(colMstacked)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The use of 
\backslash
code{do.call} puts this lecture into the intermediate, rather than elementary
 R user range.
 I can explain, and point to this example where I learned about it in my
 WorkingExamples collection:
\end_layout

\begin_layout Plain Layout


\backslash
href{http://pj.freefaculty.org/guides/Rcourse/WorkingExamples/efficiency-stackList
Items-01.R}{efficiency-stackListItems}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Functions that require more arguments}
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
item The simplest example will have 2 arguments, a list and a function name
\end_layout

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

    aNewList <- lapply(someList, FUN = someFunction)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

  
\backslash
item someFunction 
\backslash
textbf{MUST} accept an elements from someList 
\backslash
emph{as the
\end_layout

\begin_layout Plain Layout

    first} argument
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item Additional arguments 
\backslash
code{arg2}, 
\backslash
code{arg3}, to 
\backslash
code{someFunction} can be provided like this
\end_layout

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

    aNewList <- lapply(someList, FUN = someFunction, arg2 = 7, arg3 = 5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

 but it is required that someFunction's first argument must be filled by
 the element of 
\backslash
code{someList}
\end_layout

\begin_layout Plain Layout

  
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{lapply example with more arguments}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
My data generator in previous example did not allow any parameters.
 
\end_layout

\begin_layout Itemize
Here is my new candidate:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

getDF <- function(i, m1 = 0, m2 = 0, s1 = 1, s2 = 1) {
\end_layout

\begin_layout Plain Layout

   data.frame(ds = i, x1 = rnorm(100, m1, s1), 
\end_layout

\begin_layout Plain Layout

                      x2 = rnorm(100, m2, s2))}
\end_layout

\begin_layout Plain Layout

jumboData <- lapply(1:150, getDF, m1 = 90, s1 = 10, m2 = 33, s2 = 10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Lets check the column means first
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colM3T <- t(sapply(jumboData, colMeans))
\end_layout

\begin_layout Plain Layout

colM3T[1:5, ]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Pick one data frame for inspection
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<hist133>>=
\end_layout

\begin_layout Plain Layout

ex133 <- jumboData[[133]]
\end_layout

\begin_layout Plain Layout

head(ex133)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<hist134, fig=T, include=F>>=
\end_layout

\begin_layout Plain Layout

hist(ex133$x1, xlab = "x1", prob = TRUE, main = "Sample 133", ylim = c(0,
 0.07))
\end_layout

\begin_layout Plain Layout

mtext("Histogram with KDE smooth", 3, -1)
\end_layout

\begin_layout Plain Layout

lines(density(ex133$x1))
\end_layout

\begin_layout Plain Layout

legend("right", legend = paste(c("mean =", "std.dev ="), round(c(mean(ex133$x1),
 sd(ex133$x1, 2)),2)))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includegraphics[width=8cm]{tmpout/t-hist134}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I had to fight a while to get that legend into shape, and that broke the
 graph in several ways.
 Grrr!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{tmpout/t-hist134.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
sapply and vapply
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{``sapply()'' is only slightly different}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
colMresults
\end_layout

\end_inset

 output from 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
lapply
\end_layout

\end_inset

 is a list with 150 vectors.
\end_layout

\begin_layout Itemize
We already found that we can 
\begin_inset Quotes eld
\end_inset

post process
\begin_inset Quotes erd
\end_inset

 that list by rbinding the elements into a matrix with 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
do.call(rbind, colMresults)
\end_layout

\end_inset

.
 There are, however, one-step solutions.
\end_layout

\begin_layout Itemize
We can get back an array if we use 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sapply
\end_layout

\end_inset

, or its newer, more-save cousin 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
vapply
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

s
\begin_inset Quotes erd
\end_inset

 is for 
\begin_inset Quotes eld
\end_inset

simplify
\begin_inset Quotes erd
\end_inset

 the result.
 
\emph on
Ask R to guess
\emph default
 what each pieces is supposed to give back, then guess how to compactify
 that.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colMresults2 <- sapply(jumboData, colMeans)
\end_layout

\begin_layout Plain Layout

dim(colMresults2)
\end_layout

\begin_layout Plain Layout

## That's 150 columns with 3 rows each.
 The first 3 columns
\end_layout

\begin_layout Plain Layout

colMresults2[ , 1:3]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The return is a matrix that has one column for each of the input data frames.
 
\end_layout

\begin_layout Itemize
The result seems 
\begin_inset Quotes eld
\end_inset

sideways
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
I would rather have that information transposed, so I use 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
t()
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colMresults2T <- t(colMresults2)
\end_layout

\begin_layout Plain Layout

head(colMresults2T)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{
\backslash
texttt{vapply()} is safer version of 
\backslash
texttt{sapply()}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In 
\emph on
Advanced R, 
\emph default
Wickham makes a good argument that 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sapply
\end_layout

\end_inset

 should not be used in functions or long scripts because it may guess incorrectl
y about return values
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
vapply
\end_layout

\end_inset

 is a similar/newer version.
 We must specify the structure expected from the return.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colMresults3 <- vapply(jumboData, colMeans, numeric(3))
\end_layout

\begin_layout Plain Layout

## 3rd argument gives structure required in output from colMeans
\end_layout

\begin_layout Plain Layout

str(colMresults3)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Ach! Output is sideways again.
 
\end_layout

\begin_layout Itemize
The output has 150 columns, too wide to show here.
 But we can peek at the first 5 columns
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colMresults3[ , 1:5]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{If you want more about iterators}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In 2013, I wrote a longer presentation, from which about 10% of this presentatio
n is taken
\end_layout

\begin_layout Itemize
There are two large worked out examples of simulations using 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
lapply
\end_layout

\end_inset


\end_layout

\begin_layout Quote
\begin_inset CommandInset href
LatexCommand href
name "iteration-1.pdf"
target "http://pj.freefaculty.org/guides/Rcourse/iteration-1/iteration-1.pdf"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
section{Bootstrapping}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{Bootstrapping: Some ``Do it Yourself'' Work Is Required}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item Many R functions require users to write little functions
\end_layout

\begin_layout Plain Layout

    that do little things.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item In many cases (like lapply or apply), look for FUN as an argument.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item Sometimes no builtin-exists.
 useR must create!
\end_layout

\begin_layout Plain Layout

  
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{boot Function Requires a Special Function ``statistic''}
\end_layout

\begin_layout Plain Layout


\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

  library(boot)
\end_layout

\begin_layout Plain Layout

  ?boot
\end_layout

\begin_layout Plain Layout


\backslash
end{Sinput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
def
\backslash
Sweavesize{
\backslash
scriptsize}
\end_layout

\begin_layout Plain Layout


\backslash
begin{Soutput}
\end_layout

\begin_layout Plain Layout

Bootstrap Resampling
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Description:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Generate 'R' bootstrap replicates of a statistic applied to data.
\end_layout

\begin_layout Plain Layout

Both parametric and nonparametric resampling are possible.
 ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

boot(data, statistic, R, sim = ''ordinary'', stype = ''i'',
\end_layout

\begin_layout Plain Layout

strata=rep(1, n), L = NULL, m = 0, weights = NULL,
\end_layout

\begin_layout Plain Layout

ran.gen=function(d, p) d, mle = NULL, simple = FALSE, ...)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

statistic: A function which when applied to data returns a vector
\end_layout

\begin_layout Plain Layout

containing the statistic(s) of interest...
\end_layout

\begin_layout Plain Layout


\backslash
end{Soutput}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% _______________________________
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{Bootstrap: Background Explanation}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item Bootstrap: draw samples repeatedly and re-estimate $
\backslash
theta$
\end_layout

\begin_layout Plain Layout

  
\backslash
item Resulting values approximate a sampling distribution $
\backslash
theta$
\end_layout

\begin_layout Plain Layout

  
\backslash
item The ``boot'' package asks for a data frame and a special
\end_layout

\begin_layout Plain Layout

    function ``statistic''.
 statistic must
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

      
\backslash
item accept a data frame as the first argument
\end_layout

\begin_layout Plain Layout

      
\backslash
item accept an ``index vector'' as the second argument
\end_layout

\begin_layout Plain Layout

      
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

    
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Don't Panic: This is Confusing to Everybody}
\end_layout

\end_inset


\end_layout

\begin_layout ColumnsTopAligned

\end_layout

\begin_deeper
\begin_layout Column
5cm
\end_layout

\begin_layout Standard
This is your DF
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
index
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
x4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ddots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ddots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Column
7cm
\end_layout

\begin_layout Itemize
All the iterations are the same, they just use different row subsets
\end_layout

\begin_layout Itemize
boot will choose a set of rows, say 
\begin_inset Quotes eld
\end_inset

c(1, 6, 8, 10)
\begin_inset Quotes erd
\end_inset

.
 Your statistic function is supposed to do the right thing with the data
 subset.
 
\end_layout

\begin_deeper
\begin_layout Itemize
X[c(1, 6, 8, 10), ]
\end_layout

\end_deeper
\begin_layout Itemize
Then boot re-draws an index, 
\begin_inset Quotes eld
\end_inset

c(3, 5, 7, 9)
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Then analysis happens with:
\end_layout

\begin_deeper
\begin_layout Itemize
X[c(3, 5, 7, 9), ]
\end_layout

\end_deeper
\begin_layout Itemize
Over and over
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{Example usage}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{Sinput}
\end_layout

\begin_layout Plain Layout

    boot(data, statistic = yourFunction, R = 1000)
\end_layout

\begin_layout Plain Layout


\backslash
end{Sinput}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item boot will iterate 1000 times, and 
\backslash
code{yourFunction} will provide the
\end_layout

\begin_layout Plain Layout

  statistic of interest.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item You write yourFunction to make required calculation.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item boot will tell yourFunction which
\end_layout

\begin_layout Plain Layout

  lines to use in the data frame, 
\backslash
emph{over-and-over}.
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%___________________________________
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{The Median of a Poisson Distribution}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item Suppose you have a sample from a Poisson Process:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<poisson10,echo=T>>=
\end_layout

\begin_layout Plain Layout

samp <- rpois(20, lambda=3)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item And you calculate the median:
\end_layout

\begin_layout Plain Layout

<<poisson20,echo=T>>=
\end_layout

\begin_layout Plain Layout

median(samp)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item How confident are you in that estimate of the median?
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%_____________________
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{Bootstrap Your Median}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
item Here is yourFunction, it takes just a column vector as input:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<poisson30,echo=T>>=
\end_layout

\begin_layout Plain Layout

calcMed <- function(x, ind){
\end_layout

\begin_layout Plain Layout

  median(x[ind])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
item x[ind] has the effect of ``pulling'' rows that match ``ind''
\end_layout

\begin_layout Plain Layout

  from ``x''
\end_layout

\begin_layout Plain Layout


\backslash
item The boot function will send 1000 ``case indexes'' to your function.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<poisson90, echo=T>>=
\end_layout

\begin_layout Plain Layout

library(boot)
\end_layout

\begin_layout Plain Layout

bpois <- boot(samp, calcMed, R = 1000)
\end_layout

\begin_layout Plain Layout

bpois
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{The plot method for boot output}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<poisson100,fig=T,echo=T,include=F>>=
\end_layout

\begin_layout Plain Layout

  plot(bpois)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=10cm]{tmpout/t-poisson100}
\end_layout

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

% _________________________________________
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout

  
\backslash
frametitle{Why Do They Do It That Way?}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

  
\backslash
item Your instinct is to do this the ``simple'' way
\end_layout

\begin_layout Plain Layout

    
\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

    
\backslash
item (Just) ``Manually'' draw new random samples of rows from a data frame.
\end_layout

\begin_layout Plain Layout

    
\backslash
item But: Creating 1000s of ``new'' re-sampled data sets would
\end_layout

\begin_layout Plain Layout

      ``waste'' (exhaust?) memory
\end_layout

\begin_layout Plain Layout

    
\backslash
item Would be especially slow if separate data sets have to be
\end_layout

\begin_layout Plain Layout

      copied between systems.
\end_layout

\begin_layout Plain Layout

     
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

    
\backslash
item More efficient to keep 1 data frame, but 1000's of vectors
\end_layout

\begin_layout Plain Layout

      of row numbers.
\end_layout

\begin_layout Plain Layout

   
\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

 
\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Balancing Speed and Comprehension}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I'm not divorced from 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
for
\end_layout

\end_inset

 loops.
 But I recognize that vectorization is always faster, if we can use it.
\end_layout

\begin_layout Itemize
If one is patient with the manuals and documentation, the usage of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
lapply
\end_layout

\end_inset

, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
vapply
\end_layout

\end_inset

, and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
boot
\end_layout

\end_inset

 can be elegant, fast.
\end_layout

\begin_layout Itemize
If one is impatient, and treats R code as if it were intended for C or fortran,
 one might have code that is 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
done more quickly
\end_layout

\begin_layout Itemize
harder to debug
\end_layout

\begin_layout Itemize
runs more slowly
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{References}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../../R"
options "apalike2"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Session}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sess10>>=
\end_layout

\begin_layout Plain Layout

sessionInfo()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<opts20, include=F>>=
\end_layout

\begin_layout Plain Layout

## Don't delete this.
 It puts the interactive session options
\end_layout

\begin_layout Plain Layout

## back the way they were.
 If this is compiled within a session
\end_layout

\begin_layout Plain Layout

## it is vital to do this.
\end_layout

\begin_layout Plain Layout

options(opts.orig)
\end_layout

\begin_layout Plain Layout

options(par.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
