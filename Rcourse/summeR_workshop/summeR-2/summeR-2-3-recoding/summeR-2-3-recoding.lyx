#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble
\usepackage{dcolumn}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{graphicx}
%\newcommand\makebeamertitle{\frame{\maketitle}}%
\renewcommand{\doiprefix}{doi:\kern-1pt}
\setlength{\bibsep}{10pt}

% use 'handout' to produce handouts
%\documentclass[handout]{beamer}
\usepackage{wasysym}
\usepackage{pgfpages}
%for bold upright roman in math for matrix algebra
\newcommand{\vn}[1]{\mbox{{\it #1}}}\newcommand{\vb}{\vspace{\baselineskip}}\newcommand{\vh}{\vspace{.5\baselineskip}}\newcommand{\vf}{\vspace{\fill}}\newcommand{\splus}{\textsf{S-PLUS}}\newcommand{\R}{\textsf{R}}

%%\input{theme/guidePreambleSweavel.tex} 
%%% From beamer slide:
\usepackage{Sweave}
%% 
%% This controls display of code chunks
\usepackage{ae,fancyvrb,relsize,listings}

\providecommand{\Sweavesize}{\normalsize}
\providecommand{\Rsize}{}
\renewcommand{\Rsize}{\scriptsize}
\providecommand{\Routsize}{\scriptsize}

\providecommand{\Rcolor}{\color[rgb]{0.1, 0.1, 0.1}}
\providecommand{\Routcolor}{\color[rgb]{0.2, 0.2, 0.2}}
\providecommand{\Rcommentcolor}{\color[rgb]{0.101, 0.43, 0.432}}

\providecommand{\Rbackground}{\color[gray]{0.91}}
\providecommand{\Routbackground}{\color[gray]{0.935}}
% Can specify \color[gray]{1} for white background or just \color{white}

\lstdefinestyle{Rinput}{
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  basicstyle=\Rsize\Rcolor\ttfamily,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%,
  commentstyle=\Rcommentcolor\ttfamily,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1{==}{{=\,=}}2{--}{{-\,-}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
  backgroundcolor=\Rbackground,%
  numbers=left,%
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}%

% Other options of interest:
% frame=single,framerule=0.1pt,framesep=1pt,rulecolor=\color{blue},
% numbers=left,numberstyle=\tiny,stepnumber=1,numbersep=7pt,
% keywordstyle={\bf\Rcolor}

\lstdefinestyle{Routput}{fancyvrb=false,
  literate={~}{{$\sim$}}1{R^2}{{$R^{2}$}}2{^}{{$^{\scriptstyle\wedge}$}}1{R-squared}{{$R^{2}$}}2,%
  basicstyle=\Routcolor\Routsize\ttfamily,%
  backgroundcolor=\Routbackground,
  language=R,
  escapechar=`,
  fancyvrb=false,%
  tabsize=2,%
  breaklines=true,
  breakatwhitespace=true,%
  captionpos=b,%
  frame=single,%
  framerule=0.2pt,%
  framesep=1pt,%
  showstringspaces=false,%
  columns=fixed%,
  \lst@ifdisplaystyle\scriptsize\fi,%
  identifierstyle=,%
  keywords=\bfseries,%
  keywordstyle=\color[rgb]{0, 0.5, 0.5},
  escapeinside={(*}{*)},
  literate={~}{{$\sim$}}1 {==}{{=\,=}}2,
  alsoother={$},
  alsoletter={.<-},%
  otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},
  numbers=left,
  %numberblanklines=false,%
  stepnumber=5,
  firstnumber=1,
  numberstyle={\tiny}
}

\renewenvironment{Schunk}{}{}
\renewenvironment{Sinput}{}{}
\let\Sinput\relax
\let\Scode\relax
\let\Soutput\relax
\lstnewenvironment{Sinput}{\lstset{style=Rinput}}{}
\lstnewenvironment{Scode}{\lstset{style=Rinput}}{}
\lstnewenvironment{Soutput}{\lstset{style=Routput}}{}
%%end paste in from guidePreambleSweavel.tex


\lstset{tabsize=2, breaklines=true, style=Rinput, breakatwhitespace=true}

\fvset{listparameters={\setlength{\topsep}{0em}}}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.90}
\usepackage{realboxes}
\providecommand*{\code}[1]{\texttt{#1}}
\renewcommand{\code}[1]{%
\Colorbox{light-gray}{#1}%
}%
%% end of paste

\usepackage[natbibapa]{apacite}

\definecolor{darkblue}{HTML}{1e2277}

%would be in beamerthemekucrmda%
\mode<presentation>
\definecolor{kublue}{RGB}{0,81,186}
\usefonttheme{professionalfonts}
\useoutertheme{infolines}
\useinnertheme{rounded}
%disable rounded for alert and example boxes%
\setbeamertemplate{blocks}[default]
\usecolortheme{whale}
\usecolortheme{orchid}
\setbeamercolor{structure}{bg=kublue,fg=kublue!90!black}
%\setbeamercolor{structure}{fg=kublue}
\setbeamercolor{frametitle}{bg=kublue}
\setbeamercolor{section in toc}{fg=kublue!40!black}

\setbeamertemplate{frametitle continuation}[from second]
\renewcommand\insertcontinuationtext{...}
\beamertemplatenavigationsymbolsempty
%end of beamerthemekucrmda%

%If you want bigger margins, try this:
\setbeamersize{text margin left=05mm,text margin right=10mm} 
\hypersetup{colorlinks,allcolors=.,urlcolor=darkblue}
%Following seems to have no effect now
%\usepackage{handoutWithNotes}
%\pgfpagesuselayout{3 on 1 with notes}[letterpaper, border shrink=5mm]

\titlegraphic{\includegraphics[width=6cm]{theme/logo}}
\logo{\includegraphics[width=5mm]{theme/logomini}}
\end_preamble
\options aspectratio=1609
\use_default_options false
\begin_modules
logicalmkup
sweave
natbibapa
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures false
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style \use_bibtopic false
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\branch R
\selected 1
\filename_suffix 0
\color #faf0e6
\end_branch
\branch semboot
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\branch cfalvm
\selected 1
\filename_suffix 0
\color #d6fbd6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%following is LyX shortcut 
\backslash
vb for bold upright math for matrices
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\vb}[1]{\bm{\mathrm{#1}}}
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch R
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% tmpout directory must exist first
\end_layout

\begin_layout Plain Layout

<<tmpout, echo=FALSE, include=FALSE, results=hide>>=
\end_layout

\begin_layout Plain Layout

tdir <- "tmpout"
\end_layout

\begin_layout Plain Layout

if(!dir.exists(tdir)) dir.create(tdir, showWarnings=FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

% In document Latex options:
\end_layout

\begin_layout Plain Layout


\backslash
fvset{listparameters={
\backslash
setlength{
\backslash
topsep}{0em}}}
\end_layout

\begin_layout Plain Layout


\backslash
SweaveOpts{prefix.string=tmpout/t,split=T,ae=F,height=4.5,width=7}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Roptions, include=F, results=hide>>=
\end_layout

\begin_layout Plain Layout

opts.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=100, prompt = " ", continue = "  ")
\end_layout

\begin_layout Plain Layout

options(useFancyQuotes = FALSE)
\end_layout

\begin_layout Plain Layout

set.seed(12345)
\end_layout

\begin_layout Plain Layout

par.orig <- par(no.readonly = TRUE) 
\end_layout

\begin_layout Plain Layout

pjmar <- c(4.1, 4.1, 1.5, 2.1)
\end_layout

\begin_layout Plain Layout

options(SweaveHooks=list(fig=function() par(mar=pjmar, ps=12, xpd=F)))
\end_layout

\begin_layout Plain Layout

pdf.options(onefile=F,family="Times",pointsize=12)
\end_layout

\begin_layout Plain Layout

if(!file.exists("theme")) file.symlink("../../../../template/theme", "theme")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Title
Recoding 
\begin_inset Argument 1
status open

\begin_layout Plain Layout
recoding
\end_layout

\end_inset


\end_layout

\begin_layout Author
Paul E.
 Johnson
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Johnson 
\end_layout

\end_inset


\end_layout

\begin_layout Institute
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
1
\end_layout

\end_inset

Department of Political Science
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset

Center for Research Methods and Data Analysis, University of Kansas
\begin_inset Argument 1
status open

\begin_layout Plain Layout
K.U.
\end_layout

\end_inset


\end_layout

\begin_layout Date
2018
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following causes the table of contents to be shown at the beginning
 of every subsection.
 Delete this, if you do not want it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSection[]{
\end_layout

\begin_layout Plain Layout

  
\backslash
frame<beamer>{ 
\end_layout

\begin_layout Plain Layout

    
\backslash
frametitle{Outline}
\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection] 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Outline}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What's the big idea?
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Quotes eld
\end_inset

They
\begin_inset Quotes erd
\end_inset

 give us variables that need to be 
\emph on
cleaned up
\end_layout

\begin_layout Itemize
Recoding:
\end_layout

\begin_deeper
\begin_layout Itemize
change variable names
\end_layout

\begin_layout Itemize
alter numeric values
\end_layout

\begin_layout Itemize
assign labels to values
\end_layout

\end_deeper
\begin_layout Itemize
Difficult record-keeping process, requires teamwork
\end_layout

\end_deeper
\begin_layout Section
Variable Types
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
numbers, strings, and factors (oh my!)
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Today focus on R 
\begin_inset CommandInset citation
LatexCommand citep
key "RCore"
literal "true"

\end_inset

 variable classes
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
integers
\end_layout

\begin_layout Enumerate
numeric floating point numbers (AKA 
\begin_inset Quotes eld
\end_inset

doubles
\begin_inset Quotes erd
\end_inset

), 
\end_layout

\begin_layout Enumerate
character strings, and 
\end_layout

\begin_layout Enumerate
factors
\end_layout

\end_deeper
\begin_layout Itemize
Not discussing 
\begin_inset Quotes eld
\end_inset

Date
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

POSIXct
\begin_inset Quotes erd
\end_inset

 for date/time information
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
allowframebreaks
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Be Careful, Check your work
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Always check effect of recodes.
\end_layout

\begin_deeper
\begin_layout Itemize
Don't erase old variables & values
\end_layout

\begin_layout Itemize
Do create new variables or new data frame
\end_layout

\end_deeper
\begin_layout Itemize
One way is to rename every variable
\end_layout

\begin_layout Itemize
Sometimes I'll do the following 
\end_layout

\begin_deeper
\begin_layout Enumerate
Make a backup copy
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

dat.orig <- dat
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Do recodes in dat
\end_layout

\begin_layout Enumerate
Can compare variable across data.frames
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

table(dat$x123, dat.orig$x123)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Numeric variables: Scatterplot
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

plot.default(dat$x456, dat.orig$x456)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
compare side by side
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

cbind(dat$x456, dat.orig$x456)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
allowframebreaks,containsverbatim
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Variable modes in R
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A 
\series bold
vector
\series default
 is a collection of scores, all of which are stored in the same storage
 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Mode examples:
\end_layout

\begin_deeper
\begin_layout Itemize
integer
\end_layout

\begin_layout Itemize
numeric (floating point number, AKA 
\begin_inset Quotes eld
\end_inset

double
\begin_inset Quotes erd
\end_inset

 precision floating number)
\end_layout

\begin_layout Itemize
character (letters, non-number characters, or numbers that are quoted (
\begin_inset Quotes eld
\end_inset

3
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Itemize
logical (legal values TRUE and FALSE represent 1 and 0)
\end_layout

\end_deeper
\begin_layout Itemize
Most common methods to create vectors are
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
c()
\end_layout

\end_inset

 function (c = concatenate) will guess the storage mode from your input
\end_layout

\begin_layout Itemize
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
vector()
\end_layout

\end_inset

 function will explicitly ask for a vector using a storage mode.
\end_layout

\end_deeper
\begin_layout Itemize
Character vector
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c("alpha", "beta", "gamma", "omega", "psi")
\end_layout

\begin_layout Plain Layout

is.character(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If you create a vector with one character-value and some numbers, guess
 what happens?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c("alpha", 2, 3, 3, 4)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
R converts (demotes?) the numbers to characters.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why? All elements in a vector must be of the same type.
 
\end_layout

\begin_layout Standard
Ways to check:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

is.character(x)
\end_layout

\begin_layout Plain Layout

mode(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Conversion back to numeric will replace the character with the missing value
 symbol (because there is no number for the character 
\begin_inset Quotes eld
\end_inset

alpha
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

as.numeric(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If you enter data that appears to be integers, R guesses you wanted floating
 point numbers (double-precision real-valued numbers)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c(55, 2, 3, 3, 4)
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

is.double(x)
\end_layout

\begin_layout Plain Layout

is.integer(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
But if you 
\emph on
really do want integer data
\emph default
, you can signal R about that by the letter 
\begin_inset Quotes eld
\end_inset

L
\begin_inset Quotes erd
\end_inset

 (short for 
\begin_inset Quotes eld
\end_inset

long integer
\begin_inset Quotes erd
\end_inset

 storage format) with your integers:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c(55L, 2L, 3L, 3L, 4L)
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

is.integer(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
framebreak
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
What if you combine integers and floating point numbers?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c(2L, 3L, 3L, 4L, 5.5323)
\end_layout

\begin_layout Plain Layout

is.integer(x)
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

is.double(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
R has 
\begin_inset Quotes eld
\end_inset

promoted
\begin_inset Quotes erd
\end_inset

 the integers to floating point numbers in order to store them along with
 the floating value.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Itemize
Does not help if you explicitly create a vector by declaring its storage
 mode:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- vector(mode = "integer", length = 5)
\end_layout

\begin_layout Plain Layout

is.integer(x)
\end_layout

\begin_layout Plain Layout

x <- c(1, 2, 3, 4, 5)
\end_layout

\begin_layout Plain Layout

is.integer(x)
\end_layout

\begin_layout Plain Layout

## R is hiding the decimals from you
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

mode(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
containsverbatim,allowframebreaks
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Computer Scientists and Normal People.
 Can we all just get along?
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
I thought I would show how smart I am, claiming that the integer vector
 is not a numeric.
\end_layout

\begin_layout Itemize

\series bold
WRONG!
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

is.numeric(x)
\end_layout

\begin_layout Plain Layout

## Whoops! But its not a floating point number
\end_layout

\begin_layout Plain Layout

is.double(x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Colloquially, most R users think numeric means a 
\begin_inset Quotes eld
\end_inset

decimal number
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Itemize
Formally, R's mode 
\begin_inset Quotes eld
\end_inset

numeric
\begin_inset Quotes erd
\end_inset

 includes both floating-point and integer numbers.
\end_layout

\begin_layout Itemize
See commentary in ?
\begin_inset Flex Code
status open

\begin_layout Plain Layout
is.numeric
\end_layout

\end_inset

:
\begin_inset listings
lstparams "tabsize=2"
inline false
status open

\begin_layout Plain Layout

Note on names:
\end_layout

\begin_layout Plain Layout

- It is a historical anomaly that R has two names for its floating-point
 vectors, 'double' and 'numeric' (and formerly had 'real').
\end_layout

\begin_layout Plain Layout

- 'double' is the name of the type.
 'numeric' is the name of the mode and also of the implicit class.
 As an S4 formal class, use '"numeric"'.
\end_layout

\begin_layout Plain Layout

- The potential confusion is that R has used _mode_ '"numeric"' to mean
 'double or integer', which conflicts with the S4 usage.
 Thus 'is.numeric' tests the mode, not the class, but 'as.numeric' (which
 is identical to 'as.double') coerces to the class.
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In other words, there are good reasons most 
\begin_inset Quotes eld
\end_inset

R for beginners
\begin_inset Quotes erd
\end_inset

 manuals avoid the whole question of variable types.
\end_layout

\begin_layout Itemize
If you ever need to rely on fact that one column is an integer, or is double-pre
cision real values, be careful.
\end_layout

\end_deeper
\end_inset


\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Recoding Examples
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Replace 999 with NA (in an age variable, perhaps)
\end_layout

\begin_layout Itemize
Create new columns, such as 
\begin_inset Quotes eld
\end_inset

xlog
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

xsquared
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Change 
\begin_inset Quotes eld
\end_inset

Male
\begin_inset Quotes erd
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

M
\begin_inset Quotes erd
\end_inset

 in a string variable
\end_layout

\begin_layout Itemize
Correct the misspelling of 
\begin_inset Quotes eld
\end_inset

Cincinnati
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Re-group observations, to combine 
\begin_inset Quotes eld
\end_inset

aged
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

elderly
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes eld
\end_inset

old
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

senior
\begin_inset Quotes erd
\end_inset

 in a character variable or a factor.
\end_layout

\begin_layout Itemize
Numeric and string recodes are comparatively easy
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

atomic
\begin_inset Quotes erd
\end_inset

 data types (they have no R 
\begin_inset Quotes eld
\end_inset

attributes
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Factor variables require more effort, more internal components have to be
 fixed properly.
 
\end_layout

\end_deeper
\begin_layout Section
Numeric
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Recoding Numeric Variables is easy
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
We are interested in 3 particular problems
\end_layout

\begin_layout Enumerate
Setting some values as missings
\end_layout

\begin_layout Enumerate
Re-scaling and transforming values
\end_layout

\begin_layout Enumerate
Re-grouping values
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
allowframebreaks
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Small test data frame
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Rsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,eval=F>>=
\end_layout

\begin_layout Plain Layout

set.seed(234)
\end_layout

\begin_layout Plain Layout

N <- 48 ## Small sample
\end_layout

\begin_layout Plain Layout

dat <- 
\end_layout

\begin_layout Plain Layout

  data.frame(x = exp(rnorm(N, mean = 5, sd = 0.7)), 
\end_layout

\begin_layout Plain Layout

     y = rpois(N, lambda = 13),
\end_layout

\begin_layout Plain Layout

     w = sample(letters[6:10], N, replace = TRUE), 
\end_layout

\begin_layout Plain Layout

     z = gl(4, 12, labels = c("eenie", "meanie", "miney", "mo")),
\end_layout

\begin_layout Plain Layout

     stringsAsFactors = FALSE) 
\end_layout

\begin_layout Plain Layout

## Safe copy for checking recodes
\end_layout

\begin_layout Plain Layout

dat.orig <- dat
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat <- readRDS(file = "data/smtest.rds")
\end_layout

\begin_layout Plain Layout

str(dat)
\end_layout

\begin_layout Plain Layout

dat.orig <- dat ## spare copy
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
allowframebreaks,containsverbatim
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Two Styles for Setting missing values
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Suppose every score for 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
y
\end_layout

\end_inset

 greater than 11 is bogus, must be reset as missing
\end_layout

\begin_layout Enumerate
The index approach
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

dat$y[dat$y > 11] <- NA
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Find all values for which 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
y > 11
\end_layout

\end_inset

 and change them to symbol 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
NA
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ifelse
\end_layout

\end_inset

 function
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

dat$y <- ifelse(dat$y > 11, NA, dat$y)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the value of 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
y
\end_layout

\end_inset

 exceeds 11, return NA, but return y otherwise
\end_layout

\end_deeper
\begin_layout Itemize
Either way, all values above 11 become missing.
 
\end_layout

\begin_layout Itemize
To understand the detail here, I suggest you look at the TRUE-FALSE vector
 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
dat$y > 11
\end_layout

\end_inset

.
 I'll show first 10 values:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=T>>=
\end_layout

\begin_layout Plain Layout

head(dat$y > 11, 10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
allowframebreaks, containsverbatim
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Always double-check recodes
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout AlertBlock
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Always Double-check
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
I've got the original data set, so I can compare easily
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
scriptsize}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

table(is.na(dat$y), dat.orig$y, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
begin{Schunk}
\end_layout

\begin_layout Plain Layout

  
\backslash
begin{Soutput}
\end_layout

\begin_layout Plain Layout

        6 8 9 10 11 12 13 14 15 16 17 18 <NA>
\end_layout

\begin_layout Plain Layout

  FALSE 2 4 5  4  7  0  0  0  0  0  0  0    0
\end_layout

\begin_layout Plain Layout

  TRUE  0 0 0  0  0  1  6  5  5  4  3  2    0
\end_layout

\begin_layout Plain Layout

  <NA>  0 0 0  0  0  0  0  0  0  0  0  0    0
\end_layout

\begin_layout Plain Layout


\backslash
end{Soutput}
\end_layout

\begin_layout Plain Layout


\backslash
end{Schunk}
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

exclude = NULL
\begin_inset Quotes erd
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

show me everything, missings and all
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout ExampleBlock
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Otherwise, create new variables with new names.
\end_layout

\end_inset


\end_layout

\begin_layout ExampleBlock

\end_layout

\begin_layout ExampleBlock
This creates a new variable 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
\begin_inset Formula $y2$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Rsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$y2 <- dat$y
\end_layout

\begin_layout Plain Layout

dat$y2[dat$y2 > 11] <- NA
\end_layout

\begin_layout Plain Layout

## I run this to save space in output
\end_layout

\begin_layout Plain Layout

table(is.na(dat$y2), dat$y, exclude = NULL)
\end_layout

\begin_layout Plain Layout

## Could as well do
\end_layout

\begin_layout Plain Layout

## table(dat$y2, dat$y, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout ExampleBlock
\begin_inset Quotes eld
\end_inset

exclude = NULL
\begin_inset Quotes erd
\end_inset

 means 
\begin_inset Quotes eld
\end_inset

show me everything, missings and all
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
allowframebreaks,containsverbatim
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Any Logical Vector can be applied 
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
I don't know why this might happen, but suppose a co-author reports that
 all odd numbers between 11 and 19 are invalid
\end_layout

\begin_deeper
\begin_layout Itemize
Did I show you the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
seq()
\end_layout

\end_inset

 function yet?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

seq(11, 19, by = 2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Did I show you about 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
%in%
\end_layout

\end_inset

 yet?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

c(10, 11, 12, 13, 14, 15, 16) %in% seq(11, 19, by = 2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Put those together
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

dat$y[dat$y %in% seq(11, 19, by = 2)] <- NA
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Any 
\begin_inset Formula $y$
\end_inset

 in the sequence 
\begin_inset Formula $11,13,\ldots,19$
\end_inset

 are set to NA
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
containsverbatim, allowframebreaks
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Rescaling and transforming
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
R has math functions like +, -, /, log(), sqrt(), exp(), and so forth.
\end_layout

\begin_layout Itemize
Run 
\begin_inset Quotes eld
\end_inset

help(
\begin_inset Quotes eld
\end_inset

+
\begin_inset Quotes erd
\end_inset

)
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

?log
\begin_inset Quotes erd
\end_inset

, etc.
\end_layout

\begin_layout Itemize
It is as simple as column in, column out
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$x2 <- 0.01 * dat$x
\end_layout

\begin_layout Plain Layout

dat$xexp <- exp(dat$x)
\end_layout

\begin_layout Plain Layout

dat$xlog <- log(dat$x)
\end_layout

\begin_layout Plain Layout

dat$xsqrt <- sqrt(dat$x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Note
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
I created new variables, but you are allowed to destroy/replace 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
x
\end_layout

\end_inset

 itself if you want to
\end_layout

\begin_layout Enumerate
I 
\series bold
strongly prefer
\series default
 to name new variables by appending a suffix(
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
xlog
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 yes!, 
\begin_inset Quotes eld
\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
logx
\end_layout

\end_inset


\begin_inset Quotes erd
\end_inset

 no!)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Alternative declaration approach
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
I often use this method instead:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat[ , "xlog.2"] <- log(dat$x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Because 
\end_layout

\begin_deeper
\begin_layout Enumerate
I can use a calculated value in the newly named column
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

newname <- paste0("xlog", ".3")
\end_layout

\begin_layout Plain Layout

dat[ , newname] <- exp(dat$x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
It works with matrices (with which $ does not)
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
allowframebreaks
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Use cut to create categorical ranges
\end_layout

\end_inset

 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This converts a numeric variable into a factor variable
\end_layout

\begin_layout Itemize
Divide a numeric range into groupings, use the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
cut
\end_layout

\end_inset

 function
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$xcut <-cut(dat$x, 
\end_layout

\begin_layout Plain Layout

    breaks = c(-5, 60, 100, 1000000), 
\end_layout

\begin_layout Plain Layout

    labels = c("Minimal", "Medium", "Huge"))
\end_layout

\begin_layout Plain Layout

table(dat$xcut, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Plain Layout
cut for length
\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
containsverbatim, allowframebreaks
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
We sometimes use quantile to figure out the breaks
\end_layout

\end_inset

 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The quantile function finds dividing points that put the data into a given
 number of sections
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

quantile(dat$x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Here we have the 5 quantile values, corresponding to the scores that are
 in the percentiles 0, 25, 50, 75, 100
\end_layout

\end_deeper
\begin_layout Itemize
The cut function needs uses 5 to create 4 categories:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$xcut2 <-cut(dat$x, breaks = quantile(dat$x))
\end_layout

\begin_layout Plain Layout

table(dat$xcut, dat$xcut2, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
we see an 
\series bold
accidental
\series default
 missing in xcut2: the lowest score for x was not included in the lowest
 group.
\end_layout

\end_deeper
\begin_layout Itemize
The cut function uses ranges in the format (a, b], meaning 
\begin_inset Formula $a<x\leq b$
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

greater than a, up to and including b
\begin_inset Quotes erd
\end_inset

.
 Hence we need 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

xquantile <- quantile(dat$x)
\end_layout

\begin_layout Plain Layout

xquantile[1] <- min(dat$x) - 1
\end_layout

\begin_layout Plain Layout

dat$xcut3 <-cut(dat$x, breaks = xquantile)
\end_layout

\begin_layout Plain Layout

table(dat$xcut, dat$xcut3, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\end_inset


\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
containsverbatim
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Conditional Recodes are Easy As Well
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ifelse()
\end_layout

\end_inset

 is convenient
\end_layout

\begin_layout Itemize
arguments are a 
\begin_inset Quotes eld
\end_inset

logical condition
\begin_inset Quotes erd
\end_inset

, and a value if the condition is true, and one if it is false.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

y <- c(31, 33, 41, 61)
\end_layout

\begin_layout Plain Layout

ifelse(x < 3, y, x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
allowframebreaks, containsverbatim
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
The only dangers are 
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
You don't understand the function you apply:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

z <- c(-2, -0.4, 0, 1, 2, 3)
\end_layout

\begin_layout Plain Layout

log(z)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Floating point numbers deserve caution: digitial computers are vulnerable
 to 
\begin_inset Quotes eld
\end_inset

rounding error
\begin_inset Quotes erd
\end_inset

.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Comparison of a numeric variable against a particular numeric value is hazardous
/fatal.
\end_layout

\begin_layout Itemize
Math: 2/3 is not exactly equal to 0.666667, but it may look like it.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

2/3
\end_layout

\begin_layout Plain Layout

print(2/3, digits = 20)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The R-FAQ has a section explicitly devoted to this question: 
\begin_inset Quotes eld
\end_inset

7.31 Why doesnâ€™t R think these numbers are equal?
\begin_inset Quotes erd
\end_inset

 Conclusion: This is not an R problem, it is a digital computing problem.
\end_layout

\begin_layout Itemize
Because computers have finite, discrete storage, it is technically impossible
 to represent the continuum of the real number line in a computer variable
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
allowframebreaks
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
Example: Ambiguous Subtraction
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Until 2015, I thought 
\begin_inset Formula $>=$
\end_inset

and 
\begin_inset Formula $<=$
\end_inset

 were safe from trouble, but here's a counter-example
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

a <- 0.58; b <- 0.08 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

(a-b) >= 0.5
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
WTF? 
\end_layout

\begin_layout Itemize
First look here:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

a
\end_layout

\begin_layout Plain Layout

b
\end_layout

\begin_layout Plain Layout

a-b
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Turn up the precision of the display, the problem is easy-enough to see.
 First, I'll fiddle my environment
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

op.orig <- options()
\end_layout

\begin_layout Plain Layout

options(digits=20)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

a
\end_layout

\begin_layout Plain Layout

b
\end_layout

\begin_layout Plain Layout

a-b
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then I put the environment back the way it was
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

options(op.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
From this, I am humbled
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 3
status open

\begin_layout Plain Layout
allowframebreaks
\end_layout

\end_inset


\begin_inset Argument 4
status open

\begin_layout Plain Layout
A real life example
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
This is from a project in Spring, 2017.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

a <- 100*(23/40)
\end_layout

\begin_layout Plain Layout

b <- (100*23)/40
\end_layout

\begin_layout Plain Layout

all.equal(a, b)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But...
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

round(a)
\end_layout

\begin_layout Plain Layout

round(b)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Need some hints?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

print(a, digits = 20)
\end_layout

\begin_layout Plain Layout

print(b, digits = 20)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
100/40 has an exact representation in floating point numbers in base 10,
 2.5
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

print((100/40)*23, digits = 20)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is reasonable to expect 100*23/40 = 2.5 * 23 should be exactly 57.5
\end_layout

\begin_layout Standard
23/40 is a non-repeating decimal in base 10
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

print(23/40, digits = 20)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Yet another example and the take-away}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Surprise: Even a simple decimal like 0.1 has no exact representation in digital
 numbers, it must be approximated by a nearby value
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

0.1
\end_layout

\begin_layout Plain Layout

print(0.1, digits = 22)
\end_layout

\begin_layout Plain Layout

x <- 0.1
\end_layout

\begin_layout Plain Layout

x == 0.1
\end_layout

\begin_layout Plain Layout

x == 0.1000000000000000055511
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Computers try to tell us what they think we want.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Should 
\begin_inset Quotes eld
\end_inset

==
\begin_inset Quotes erd
\end_inset

 succeed in both of those cases? I think NO!
\end_layout

\end_deeper
\begin_layout Itemize
Major takeaway message: The use of 
\begin_inset Quotes eld
\end_inset

==
\begin_inset Quotes erd
\end_inset

 with numeric, non integer variables is very problematic
\end_layout

\begin_layout Itemize
The use of inequalities 
\begin_inset Quotes eld
\end_inset

>=
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

<=
\begin_inset Quotes erd
\end_inset

 should be cautious, possibly requiring re-design of an algorithm to allow
 some 
\begin_inset Quotes eld
\end_inset

numerical wobble
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Strings
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Character variables}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Why bother with character variables?
\end_layout

\begin_layout Itemize
The names of the columns need tidying.
\end_layout

\begin_layout Itemize
Character columns have errors
\end_layout

\begin_layout Itemize
We need beautiful labels.
 Convert country names, abbreviate states, etc.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Creating Character Variables: paste and paste0}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The most frequently used string functions
\end_layout

\begin_layout Itemize
Manufacture a vector of integers, convert them to characters
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$rn <- as.character(1:NROW(dat))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
paste()
\end_layout

\end_inset

 function combines vectors, using an indicated separator
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$wn <- paste(dat$w, dat$rn, sep = "_")
\end_layout

\begin_layout Plain Layout

head(dat[ ,c("w", "rn", "wn")])
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you forget to specify sep, then a space will be inserted.
\end_layout

\end_deeper
\begin_layout Itemize
A convenience function 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
paste0()
\end_layout

\end_inset

, was created to save us the trouble of typing 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
sep = ""
\end_layout

\end_inset

 when we don't want a separator of any kind.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fff>>=
\end_layout

\begin_layout Plain Layout

dat$wn <- paste0(dat$w, dat$rn)
\end_layout

\begin_layout Plain Layout

head(dat[ ,c("w", "rn", "wn")])
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{I often need to clean up colnames}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Retrieve column names
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

oldnames <- colnames(dat)
\end_layout

\begin_layout Plain Layout

oldnames
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Sometimes, the needed change is simple, like changing to all CAPITAL letters
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=60)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
def
\backslash
Rsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
footnotesize}
\end_layout

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colnames(dat) <- toupper(oldnames)
\end_layout

\begin_layout Plain Layout

head(dat, 2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options(options.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Sometimes they need more information, before combining with other data sets
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=60)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colnames(dat) <- paste0(oldnames, "_", 2017) 
\end_layout

\begin_layout Plain Layout

head(dat, 2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options(options.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I'd better replace the original names now
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

colnames(dat) <- oldnames 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Renaming columns can be a tricky business}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In one recent project, all of the column names have an accidentally repeated
 word, as in {
\begin_inset Quotes erd
\end_inset

religion_religion_1
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

religion_religion_2
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

gender_gender_1
\begin_inset Quotes erd
\end_inset

, ...}.
 To fix that, we extracted the column names and applied some fancy 
\begin_inset Quotes eld
\end_inset

regular expression
\begin_inset Quotes erd
\end_inset

 code.
\end_layout

\begin_layout Itemize
Project had 9 data input files from different prison hospitals.
 In each one, there were hundreds of columns that represented the SAME informati
on with different variable names.
 The goal was to reduce the unique names to standard names like 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
dxcode1, dxcode2, dxcode3
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Client had an employee make a 
\begin_inset Quotes eld
\end_inset

name old
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

name new
\begin_inset Quotes erd
\end_inset

 roster for each file in an Excel sheet.
 We import those values, apply 
\emph on
without retyping them
\emph default
 (avoid typos).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Brief list of string functions}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Flex Code
status open

\begin_layout Plain Layout
paste
\end_layout

\end_inset

.
 Mentioned above.
 Combines vectors, often used for creating row names for data frames.
 
\end_layout

\begin_layout Enumerate
substr(x, start, stop).
 Chops a character vector x, keeping only the characters from the positions
 between start and stop
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<str10>>=
\end_layout

\begin_layout Plain Layout

x <- c("hello", "jello", "fellow", "mellow")
\end_layout

\begin_layout Plain Layout

substr(x, 2, 5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Flex Code
status open

\begin_layout Plain Layout
strsplit(x, splt)
\end_layout

\end_inset

.
 Creates a new list, in which the elements of x are chopped into pieces
 separated by the symbol 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
splt
\end_layout

\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<str20>>=
\end_layout

\begin_layout Plain Layout

strsplit(x, "ll")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
CAUTION
\series default
: Regular Expressions are discussed in more depth in the 4th day of this
 workshop.
 REs are a specialized language that offers powerful filtering tools
\end_layout

\end_deeper
\begin_layout Enumerate
grep(pattern, x): 
\begin_inset Quotes eld
\end_inset

GNU regular expression parser
\begin_inset Quotes erd
\end_inset

, scans for presence of 
\begin_inset Quotes eld
\end_inset

pattern
\begin_inset Quotes erd
\end_inset

 in string 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

, 
\end_layout

\begin_deeper
\begin_layout Itemize
the argument 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
fixed = TRUE
\end_layout

\end_inset

 turns off regex support, treats the pattern and like ordinary letters.
\end_layout

\begin_layout Itemize
Check for 
\begin_inset Quotes eld
\end_inset

ee
\begin_inset Quotes erd
\end_inset

 in dat$z.
 Note return is index number of matches
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

ees <- grep("ee", dat$z, fixed = TRUE)
\end_layout

\begin_layout Plain Layout

head(ees)
\end_layout

\begin_layout Plain Layout

@	
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Want a vector of matching values?
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<str30>>=
\end_layout

\begin_layout Plain Layout

ees <- grep("ee", dat$z, value = TRUE, fixed = TRUE)
\end_layout

\begin_layout Plain Layout

head(ees)
\end_layout

\begin_layout Plain Layout

@	
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

regex
\begin_inset Quotes erd
\end_inset

 pattern matching (a staple of formal computer science training)
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
^
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
$
\end_layout

\end_inset

: 2 key symbols in RE:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

^
\begin_inset Quotes erd
\end_inset

 symbol stands for 
\begin_inset Quotes eld
\end_inset

the beginning of the string
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

$
\begin_inset Quotes erd
\end_inset

 symbol stands for the end of the string
\end_layout

\end_deeper
\begin_layout Itemize
Example: which values of dat$wn that begin with g
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<str40>>=
\end_layout

\begin_layout Plain Layout

startswd <- grep("^g", dat$wn, value = TRUE)
\end_layout

\begin_layout Plain Layout

head(startswd, 10)
\end_layout

\begin_layout Plain Layout

@	
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
grepl
\end_layout

\end_inset

 function returns logical TRUE/FALSE instead
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<str50>>=
\end_layout

\begin_layout Plain Layout

startswdl <- grepl("^g", dat$wn)
\end_layout

\begin_layout Plain Layout

head(startswdl, 10)
\end_layout

\begin_layout Plain Layout

@	
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset Flex Code
status open

\begin_layout Plain Layout
gsub(x, y, var)
\end_layout

\end_inset

: 
\begin_inset Quotes eld
\end_inset

Substitute all occurrences of x with the characters y in var
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Standard
Allows regex, but 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
fixed = TRUE
\end_layout

\end_inset

 can disable regex support.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<str60>>=
\end_layout

\begin_layout Plain Layout

dat$wn2 <- gsub("f", "PJ", dat$wn, fixed = TRUE)
\end_layout

\begin_layout Plain Layout

head(dat[ , c("wn", "wn2")], 7)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
We have a project that imports name data.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Character strings for names should not include any characters except letters,
 numbers, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
_
\end_layout

\end_inset

 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
'
\end_layout

\end_inset

 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
(
\end_layout

\end_inset


\begin_inset Flex Code
status open

\begin_layout Plain Layout
)
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
-
\end_layout

\end_inset

.
 Remove all other characters.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<str70, eval=F>>=
\end_layout

\begin_layout Plain Layout

y <- gsub("[^a-zA-Z0-9
\backslash

\backslash

\backslash

\backslash
'_()-]", "", x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Regular expression
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

[]
\begin_inset Quotes erd
\end_inset

 in regular expression means 
\begin_inset Quotes eld
\end_inset

any of the following
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
^ negation in first position, converts that to 
\begin_inset Quotes eld
\end_inset

anything but the following
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
dash between 2 letters or numbers is interpreted as a range
\end_layout

\begin_layout Itemize
dash before ] literally means dash
\end_layout

\begin_layout Itemize
four backslashes before '.
 Will explain Thursday.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Factors
\end_layout

\begin_layout Subsection*
What's a Factor?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks,containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Factor Variables = Categorical Variables}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
A factor is a categorical variable, discrete values like {Catholic, Protestant}
 or {left, right, middle}
\end_layout

\begin_layout Itemize
A factor that is subjectively ordered is called an 
\begin_inset Quotes eld
\end_inset

ordered factor
\begin_inset Quotes erd
\end_inset

, or simply an 
\begin_inset Quotes eld
\end_inset

ordered
\begin_inset Quotes erd
\end_inset

 variable.
\end_layout

\begin_layout Itemize
Factors have attributes (the 
\begin_inset Quotes eld
\end_inset

levels
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Itemize
Functions notice that and customize calculations and beautify displays
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks,containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Factor Variables = Categorical Variables}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Inside R, a factor has an integer index, always beginning with 1
\end_layout

\begin_layout Itemize
From the user's point of view, the factor's values usually appear as text
 strings.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

table(dat$z)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Inside R, there's a 
\begin_inset Quotes eld
\end_inset

lookup table
\begin_inset Quotes erd
\end_inset

, so the value is really stored as 1, 2, 3, 4, but often, when you interact
 with it, it behaves like a character string variable.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Internal Integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

eenie
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

meanie
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

miney
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

mo
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
How are Factors Created?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks,containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Creating Factors}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
We've already seen that the 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
cut()
\end_layout

\end_inset

 function can create a factor variable
\end_layout

\begin_layout Itemize
Functions that create factors
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
\begin_inset Flex Code
status open

\begin_layout Plain Layout
factor()
\end_layout

\end_inset


\end_layout

\end_inset

: Unordered categories
\end_layout

\begin_layout Itemize
\begin_inset Flex Code
status open

\begin_layout Plain Layout
ordered()
\end_layout

\end_inset

: ordinal variables, subjectively ranked levels 
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
factor()
\end_layout

\end_inset

 has 3 key arguments, 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
a variable: something with values that need to be converted to a factor
\end_layout

\begin_layout Itemize
levels: values to be used, in order we want them to appear
\end_layout

\begin_layout Itemize
labels: character strings.
 If omitted, R runs 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
as.character(levels)
\end_layout

\end_inset

 to manufacture labels.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout ExampleBlock
\begin_inset Argument 2
status collapsed

\begin_layout Plain Layout
factor() example: Convert a character string to a factor
\end_layout

\end_inset


\end_layout

\begin_layout Standard
R guesses levels and labels.
 It guesses levels 
\emph on
in alphabetical order
\end_layout

\begin_layout Itemize
See what you got
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

table(dat$w)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
w2 is the default factor
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$w2 <- factor(dat$w)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
w2 looks like w, superficially
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

table(dat$w2, dat$w)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
but the internal structures are different:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

str(dat$w)
\end_layout

\begin_layout Plain Layout

str(dat$w2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Internal integers are always 1, 2, 3, $
\backslash
ldots$}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
SPSS and Stata allow any integer values with labels
\end_layout

\begin_layout Itemize
R will 
\begin_inset Quotes eld
\end_inset

throw away
\begin_inset Quotes erd
\end_inset

 the integers
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

myintegers <- c(1, 3, 5, 7, 9, 9, 7, 5, 3, 1)
\end_layout

\begin_layout Plain Layout

myfactor <- factor(myintegers, levels = c(1, 3, 5, 7, 9), 
\end_layout

\begin_layout Plain Layout

                   labels = c("E", "D", "C", "B", "A"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Note the numbers for the levels
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

str(myfactor)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Internal Integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

E
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

D
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

C
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

B
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

A
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The original numbers cannot be recovered
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

as.integer(myfactor)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout ExampleBlock
\begin_inset Argument 2
status open

\begin_layout Plain Layout
Can Specify particular values
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

myintegers <- c(1, 3, 5, 7, 9, 9, 7, 5, 3, 1)
\end_layout

\begin_layout Plain Layout

yourfactor <- factor(myintegers, levels = c(1, 9, 7), 
\end_layout

\begin_layout Plain Layout

labels = c("cold", "warm", "hot"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout AlertBlock
\begin_inset Argument 2
status open

\begin_layout Plain Layout
But you still lose the original integer values
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

str(yourfactor)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Observe:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

table(as.integer(myfactor), as.integer(yourfactor), exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{A Related Problem: Accidental factor-ization of an integer}
\end_layout

\end_inset


\end_layout

\begin_layout ExampleBlock
\begin_inset Argument 2
status collapsed

\begin_layout Plain Layout
factor() example: Convert an integer variable to a labeled factor
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Rsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c(1, 2, 1, 2, 2, 7)
\end_layout

\begin_layout Plain Layout

xf <- factor(x, levels = c(7, 2, 1), labels = c("seven","two", "one"))
\end_layout

\begin_layout Plain Layout

levels(xf)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Strong
status collapsed

\begin_layout Plain Layout
levels=
\end_layout

\end_inset

 tells R 
\begin_inset Quotes eld
\end_inset

in which order should the values of x come in?
\begin_inset Quotes erd
\end_inset

 I jumbled the order to make a point.
 
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
original value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R assigned internal value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
label for the level
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

seven
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

two
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

one
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Suppose we forget the labels argument in the factor function.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

xf2 <- factor(x, levels = c(7, 2, 1))
\end_layout

\begin_layout Plain Layout

levels(xf2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All appears well, the labels are just the numbers, but with quotation marks.
 
\end_layout

\begin_layout Itemize
Now the part that has caused plenty of confusion:
\end_layout

\begin_deeper
\begin_layout Standard
Internal numbers are 1, 2, 3, but the named labels are 
\begin_inset Quotes eld
\end_inset

7
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

2
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
original value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R assigned internal value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
label for the level
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

7
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

2
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Do you want the face-value labels to turn back into the 7-2-1 scores you
 started with? (
\emph on
Not so fast, my friend!
\emph default
) 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

as.numeric(xf2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
In the help page 
\begin_inset Quotes eld
\end_inset

?factor
\begin_inset Quotes erd
\end_inset

, they recommend this method to convert a 
\begin_inset Quotes eld
\end_inset

levels are numbers
\begin_inset Quotes erd
\end_inset

 factor back to the numbers:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

xnew <- as.numeric(levels(xf2))[xf2]
\end_layout

\begin_layout Plain Layout

xnew
\end_layout

\begin_layout Plain Layout

table(xnew, x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The more obvious method is
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

xnew2 <- as.numeric(as.character(xf2))
\end_layout

\begin_layout Plain Layout

xnew2
\end_layout

\begin_layout Plain Layout

table(xnew2, x)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
But it is not recommended in ?factor
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Factor Benefits
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks,containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Benefits of Using Factors}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Using factors reduces human errors associated with integer scores.
 
\begin_inset Quotes eld
\end_inset

Is '1' a male or female?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Procedures notice the levels.
 Regression in R will notice and create 'dummy variables' (
\begin_inset Quotes eld
\end_inset

contrast
\begin_inset Quotes erd
\end_inset

 variables).
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

m1 <- lm(x ~ z + w2, data = dat)
\end_layout

\begin_layout Plain Layout

summary(m1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If you give the factor variable to a plotting function, that function should
 notice it is not a numeric variable and act accordingly.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Rsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<factor20, fig=T,echo=T,include=F>>=
\end_layout

\begin_layout Plain Layout

plot(xf, main = "plot noticed its a factor!", xlab = "xf: a factor", ylab
 = "Count")
\end_layout

\begin_layout Plain Layout

text(0.2, 2, "R noticed xf 
\backslash
n is a factor.
 
\backslash
n So R ran table 
\backslash
n and sent output 
\backslash
n to barplot", pos=4)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{tmpout/t-factor20.tex}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=9cm]{tmpout/t-factor20}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Recoding Factors
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Examples of Needed Recodes}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Combine erroneously coded labels, reduce labels {Male, Man, Female, Woman}
 to {M, F} or something like that.
\end_layout

\begin_layout Itemize
Take verbose labels and make them shorter.
 Convert {Strongly Disagree, Disagree, ...} to {SD, D, N, A, SA}
\end_layout

\begin_layout Itemize
R's built in tools work well, but have a number of technical details that
 will frustrate new uses.
 
\end_layout

\begin_layout Itemize
In the rockchalk package, I created a function 
\begin_inset Quotes eld
\end_inset

combineLevels()
\begin_inset Quotes erd
\end_inset

 that can work on a problem like that, and it does some error checking to
 make sure it works correctly.
 
\end_layout

\begin_layout Itemize
In the 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plyr
\end_layout

\end_inset

 package, there is a very elegant function (
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mapvalues()
\end_layout

\end_inset

) that can be used and it makes this kind of chore rather painless.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Working with factors}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Use levels() to read and set levels.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Check existing levels.
 Use a copy so we don't mangle the original
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$w5 <- dat$w2
\end_layout

\begin_layout Plain Layout

levels(dat$w5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Replace by assigning a new vector of same length.
 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

levels(dat$w5) <- c("John", "Paul", "George", "Ringo", "Eric")
\end_layout

\begin_layout Plain Layout

table(dat$w5, dat$w2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Vital: 
\begin_inset Flex Alert
status collapsed

\begin_layout Plain Layout
Must provide names for all levels
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use the factor function and assign levels and labels (here, levels means
 
\begin_inset Quotes eld
\end_inset

current values
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$w6 <- factor(dat$w2, levels = c("f", "g", "h", "i", "j"), labels = c("John",
 "Paul", "George", "Ringo", "Eric"))
\end_layout

\begin_layout Plain Layout

table(dat$w6, dat$w2, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
\begin_inset Flex Code
status open

\begin_layout Plain Layout
rockchalk::combineLevels
\end_layout

\end_inset

 has some handy sanity-preserving features :)
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Rsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(rockchalk)
\end_layout

\begin_layout Plain Layout

dat$w5 <- combineLevels(dat$w2, levs = c("f", "j"), newLabel = c("fandj"))
\end_layout

\begin_layout Plain Layout

table(dat$w5, dat$w2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
dat$w5
\end_layout

\end_inset

 is an ordinal variable, 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
combineLevels
\end_layout

\end_inset

 will refuse to 
\begin_inset Quotes eld
\end_inset

put together
\begin_inset Quotes erd
\end_inset

 levels that are not adjacent with one another
\end_layout

\end_deeper
\begin_layout Enumerate
A good general purpose discrete variable recoder is 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
plyr::mapvalues
\end_layout

\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Flex Code
status open

\begin_layout Plain Layout
mapvalues(x, value_old, value_new)
\end_layout

\end_inset

 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_old
\end_layout

\end_inset

 and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
value_new
\end_layout

\end_inset

 must be vectors with the same numbers of elements
\end_layout

\end_deeper
\begin_layout Enumerate
works well if x is an integer, character, or factor variable
\end_layout

\begin_layout Enumerate
example
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(plyr)
\end_layout

\begin_layout Plain Layout

dat$w5 <- mapvalues(dat$w2, from = c("f", "g", "h", "i", "j"), to = c("John",
 "Paul", "George", "Ringo", "Erik"))
\end_layout

\begin_layout Plain Layout

str(dat$w5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
To reduce human error (avoid mis-matched elements), I usually create a named
 vector:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

newvals <- c("f" = "John", "g" = "Paul", "h" = "George", "i" = "Ringo",
 "j" = "Erik")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That puts the paired (old=new) items together, and we can extract the names
 like so
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

names(newvals)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or put them to use as:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$w6 <- mapvalues(dat$w2, from = names(newvals), to = newvals)
\end_layout

\begin_layout Plain Layout

table(dat$w6, dat$w5)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Can use this to reset just a few levels:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$w8 <- mapvalues(dat$w2, from = c("f", "g"), to = c("Roosevelt", "Lincoln"))
\end_layout

\begin_layout Plain Layout

table(dat$w8)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To combine some levels and re-label all of them as 
\begin_inset Quotes eld
\end_inset

fgh
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$w9 <- mapvalues(dat$w2, from = c("f", "g", "h"), 
\end_layout

\begin_layout Plain Layout

          to = c("fgh", "fgh","fgh"))
\end_layout

\begin_layout Plain Layout

table(dat$w9)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Convert factor values to missings}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Can reset values 
\begin_inset Quotes eld
\end_inset

i
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

j
\begin_inset Quotes erd
\end_inset

 as NA either by 
\begin_inset Quotes eld
\end_inset

indexing
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$w7 <- dat$w2
\end_layout

\begin_layout Plain Layout

dat$w7[dat$w7 %in% c("i","j")] <- NA
\end_layout

\begin_layout Plain Layout

table(dat$w7, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Or explicitly relabeling the vector
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

dat$w8 <- dat$w2
\end_layout

\begin_layout Plain Layout

levels(dat$w8) <- c("f", "g", "h", NA, NA)
\end_layout

\begin_layout Plain Layout

table(dat$w8)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

table(dat$w8, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Tip: When factor values have long, hard-to-type names, 
\end_layout

\begin_deeper
\begin_layout Itemize
copy the levels vector
\end_layout

\begin_layout Itemize
use that with indices, as in
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

(xl <- levels(dat$w2))
\end_layout

\begin_layout Plain Layout

xl[4:5]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<xf60,eval=F>>=
\end_layout

\begin_layout Plain Layout

dat$w10 <- dat$w2
\end_layout

\begin_layout Plain Layout

dat$w10[dat$w10 %in% xl[4:5]] <- NA
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{The Unused Levels problem}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Suppose there are possible levels (
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, ..., 
\begin_inset Quotes eld
\end_inset

g
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Itemize
However, for some reason, in a sample, we only collect data on (
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

c
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Itemize
If the factor is created on the range of possible scores, then there will
 be many 
\begin_inset Quotes eld
\end_inset

unused levels
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- c(1, 2, 3, 3, 2, 1)
\end_layout

\begin_layout Plain Layout

xf <- factor(x, levels = 1:7, labels = letters[1:7])
\end_layout

\begin_layout Plain Layout

str(xf)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The table function displays the empty 
\begin_inset Quotes eld
\end_inset

unused levels
\begin_inset Quotes erd
\end_inset

 (by default):
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>= 
\end_layout

\begin_layout Plain Layout

table(xf)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
This creates ugly reports, we might want to get rid of those 
\begin_inset Quotes eld
\end_inset

unused levels
\begin_inset Quotes erd
\end_inset

 entirely.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{2 workable ways to purge unused levels}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
factor() removes unused levels
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<xf130,eval=F>>=
\end_layout

\begin_layout Plain Layout

y <- factor(y)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
R Documentation suggests this is more meaningful (?)
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<xf140,eval=F>>=
\end_layout

\begin_layout Plain Layout

y <- y[ , drop = FALSE]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Create your 
\begin_inset Quotes eld
\end_inset

workingdata
\begin_inset Quotes erd
\end_inset

 rds files
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{After Recoding, safe a reloadable set}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Suppose there is a data frame named 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
myOldDat
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

wdir <- "workingdata" 
\end_layout

\begin_layout Plain Layout

# That's our preferred name for created data
\end_layout

\begin_layout Plain Layout

saveRDS(myOldDat, file = file.path(wdir, "myWonderful.rds"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
To bring that back into a session
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

wdir <- "workingdata"
\end_layout

\begin_layout Plain Layout

awesomeDat <- readRDS(file = file.path(wdir, "myWonderful.rds"))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Allows us to rename the data frame object when it is retrieved
\end_layout

\begin_layout Itemize
RDS files are portable.
 Can email to your friend who has a Mac
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
NES
\end_layout

\begin_layout Subsection*
Got Data?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Get my subset from Nat.
 Election Study 2004}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The data is in the 
\begin_inset Quotes eld
\end_inset

data
\begin_inset Quotes erd
\end_inset

 folder, 
\begin_inset Quotes eld
\end_inset

04245-0001-Data.dta
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Otherwise, download:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://pj.freefaculty.org/guides/Rcourse/DataSets/04245-0001-Data.dta
\end_layout

\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Itemize
Assuming the file 
\begin_inset Quotes eld
\end_inset

04245-0001-Data.dta
\begin_inset Quotes erd
\end_inset

 ended up in data, then import.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(foreign)
\end_layout

\begin_layout Plain Layout

ddir <- "data"
\end_layout

\begin_layout Plain Layout

fp <- file.path(ddir, "04245-0001-Data.dta")
\end_layout

\begin_layout Plain Layout

anes1 <- read.dta(fp)
\end_layout

\begin_layout Plain Layout

anes1.orig <- anes1
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Save copies of the wide and long variable keys, just for comparison
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key10a, eval=T>>=
\end_layout

\begin_layout Plain Layout

library(kutils)
\end_layout

\begin_layout Plain Layout

keywide <- kutils::keyTemplate(anes1, file = "anes-widetemp.csv")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
That creates 
\begin_inset Quotes eld
\end_inset

keywide
\begin_inset Quotes erd
\end_inset

 object and immediate file snapshot
\end_layout

\begin_layout Itemize
Can create & inspect first, use string functions to recode, then keySave
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key10b, eval=T>>=
\end_layout

\begin_layout Plain Layout

keylong <- kutils::keyTemplate(anes1, long = TRUE)
\end_layout

\begin_layout Plain Layout

keySave(keylong, file = "anes-longtemp.csv")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyTemplateStata
\end_layout

\end_inset

 (and 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyTamplateSPSS
\end_layout

\end_inset

) functions are recently introduced.
 These have 
\begin_inset Quotes eld
\end_inset

value_old
\begin_inset Quotes erd
\end_inset

 as the integers that were used in original data and 
\begin_inset Quotes eld
\end_inset

value_new
\begin_inset Quotes erd
\end_inset

 as the labels.
 This is very close to a 
\begin_inset Quotes eld
\end_inset

programmable codebook
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Interactively, you can run 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
View(keystata)
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key10c, eval=T>>=
\end_layout

\begin_layout Plain Layout

keystata <- kutils::keyTemplateStata(fp, long = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key11,eval=F>>=
\end_layout

\begin_layout Plain Layout

View(keystata)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The value labels are verbose, one of the regex chores would be cleaning
 them up.
\end_layout

\begin_layout Itemize
We'd go edit the key files, perhaps rename them, then run 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
keyImport
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
My edited key is 
\begin_inset Quotes eld
\end_inset

anes-wide.csv
\begin_inset Quotes erd
\end_inset

 in the current working directory.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{A Codebook Lists the Variables}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Some things we can treat as numeric
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize}"
inline false
status open

\begin_layout Plain Layout

## V043038     B1a.
 Feeling Thermometer: GW Bush
\end_layout

\begin_layout Plain Layout

## V043039     B1b.
 Feeling Thermometer: John Kerry
\end_layout

\begin_layout Plain Layout

## V043250     Y1x.
 Summary: Respondent age
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Some are clearly categorical
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize}"
inline false
status open

\begin_layout Plain Layout

## V043210     R1.
 R position on gay marriage
\end_layout

\begin_layout Plain Layout

## V043213     S3.
 National economy better/worse since GW Bush took ofc
\end_layout

\begin_layout Plain Layout

## V045145X    H5x.
 Summary: Pre-Post US flag makes R feel
\end_layout

\begin_layout Plain Layout

## V043116     J1x.
 Summary: R party ID
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Some are treated as numeric by some people
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize}"
inline false
status open

\begin_layout Plain Layout

## V045117     G4a.
 Liberal/conservative 7-point scale: self-placement
\end_layout

\begin_layout Plain Layout

## V043116     J1x.
 Summary: R party ID
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Use the Variable Key
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{This is the new way CRMDA has developed}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In the section after this one, we show the line-by-line recode commands
 needed
\end_layout

\begin_layout Itemize
This section uses the Variable Key
\end_layout

\begin_layout Itemize
This is a development enterprise in the CRMDA package 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Key}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
I edited 
\begin_inset Quotes eld
\end_inset

anes-wide.csv
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Re-import that key file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key20>>=
\end_layout

\begin_layout Plain Layout

key <- keyImport("anes-wide.csv")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If you are interactive, run View
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

View(key)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Screenshots
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includegraphics[width=10cm]{importfigs/View-anes_wide-1.png}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Apply that wide key
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key30,echo=T>>=
\end_layout

\begin_layout Plain Layout

anes2 <- keyApply(anes1, key, drop = "vars", diagnostic = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If interactive, use 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
kutils::peek
\end_layout

\end_inset

 to scan through the variables
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

peek(anes2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
summarize
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=60)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key60>>=
\end_layout

\begin_layout Plain Layout

rockchalk::summarize(anes2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options(options.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Create a new variable, manually}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The Variable Key can't do everything.
 It works one-variable-at-a-time (so far).
\end_layout

\begin_layout Itemize
Manually calculate the difference in feeling between Bush and Kerry
\end_layout

\begin_layout Itemize
Review the thermometer scales
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key50,fig=T,height=5,width=7,include=F>>=
\end_layout

\begin_layout Plain Layout

hist(anes2$V043038, breaks = 50, xlim = c(-1, 101), main = "Bush Thermometer
 Scale")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{tmpout/t-key50.tex}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=8cm]{tmpout/t-key50}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Create a new variable for the difference between Bush and Kerry feeling
 thermometers:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<key70>>=
\end_layout

\begin_layout Plain Layout

anes2$th.bk <- anes2$V043038 - anes2$V043039
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{"numeric" thermometer scores}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=60)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

table(anes1$V043038)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options(options.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Where do we stand?}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The work's done.
 We have a recoded data frame 
\begin_inset Quotes eld
\end_inset

anes2
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Manager & GRAs have common understanding of variable names and new values
\end_layout

\begin_layout Itemize
In the next section, we proceed through the recoding process, variable-by-variab
le, in the old-fashioned, time-honored tradition
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Manual Recode: Numeric Variables
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Recode age into a dichotomy}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Inspect the age variable
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<num30, fig=T, include=F>>=
\end_layout

\begin_layout Plain Layout

hist(anes1$V043250, breaks = 40, main = "", xlab = "Age")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{tmpout/t-num30.tex}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=7cm]{tmpout/t-num30}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Use cut to create a 
\begin_inset Quotes eld
\end_inset

dummy variable
\begin_inset Quotes erd
\end_inset

 for old people
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

anes1$aged <- cut(anes1$V043250, breaks = c(-1, 57, 200), labels = c("young",
 "old"))
\end_layout

\begin_layout Plain Layout

table(anes1$aged)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
57 is this year's definition of old, in case you wondered.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{plot is a generic function, notices aged is not numeric}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<num40, fig=T, include=F>>=
\end_layout

\begin_layout Plain Layout

plot(anes1$aged, xlab = "Age dichotomized")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{tmpout/t-num40.tex}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=7cm]{tmpout/t-num40}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Recall that the plot function notices the input type and it tries to make
 the plot you want.
 If we were being more systematic, we'd create the frequency table, then
 plot it.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<num41, fig=T, include=F>>=
\end_layout

\begin_layout Plain Layout

t1 <- table(anes1$aged)
\end_layout

\begin_layout Plain Layout

barplot(t1, beside = TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{tmpout/t-num41.tex}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=7cm]{tmpout/t-num41}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Create a dependent variable: Bush vs Kerry}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Create New Variable: The difference in thermometer between Bush and Kerry
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<num10>>=
\end_layout

\begin_layout Plain Layout

anes1$th.bk <- anes1$V043038 - anes1$V043039
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{tmpout/t-num20.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<num20,fig=T, include=F>>=
\end_layout

\begin_layout Plain Layout

hist(anes1$th.bk, breaks = 40, main = "Bush - Kerry", xlab = "Thermometer
 Difference")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includegraphics[width=7cm]{tmpout/t-num20}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Manual Recode: Factor Variables
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Clean up a bunch of variables and value labels}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Party Identification.
 The impossibly long level names create havoc!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30a0,include=T,echo=T>>=
\end_layout

\begin_layout Plain Layout

##Party
\end_layout

\begin_layout Plain Layout

table(anes1$V043116, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This is America.
 Hardly anybody in the Other party (8).
 Lets make them MISSING.
 While we are at it, we will shorten the level names to SD, WD, etc.
 Here's my strategy to keep the records straight.
\end_layout

\begin_deeper
\begin_layout Itemize
Get the old levels
\end_layout

\begin_layout Itemize
Revise that as a character variable
\end_layout

\begin_layout Itemize
Use the new labels as names on the old levels, so we can inspect the conversion
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30a2>>=
\end_layout

\begin_layout Plain Layout

party_value_old <- levels(anes1$V043116)
\end_layout

\begin_layout Plain Layout

party_value_new <- c("SD","WD","ID","I","IR","WR","SR", NA, NA, NA)
\end_layout

\begin_layout Plain Layout

names(party_value_old) <- party_value_new
\end_layout

\begin_layout Plain Layout

party_value_old
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30a3>>= 
\end_layout

\begin_layout Plain Layout

levels(anes1$V043116) <- names(party_value_old)
\end_layout

\begin_layout Plain Layout

## Could instead rely on plyr
\end_layout

\begin_layout Plain Layout

## anes1$V043116 <- plyr::mapvalues(anes1$V043116, 
\end_layout

\begin_layout Plain Layout

##            from = party_value_old, 
\end_layout

\begin_layout Plain Layout

##            to = names(party_value_old))
\end_layout

\begin_layout Plain Layout

table(anes1.orig$V043116, anes1$V043116)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Drop unused levels, check final result:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

anes1$V043116 <- anes1$V043116[, drop = TRUE]
\end_layout

\begin_layout Plain Layout

table(anes1$V043116, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Itemize
Ideology: We run into same problem that labels are verbose.
\end_layout

\begin_layout Itemize
I'll try a slightly different method here
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=60)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30b1,include=T,echo=T>>=
\end_layout

\begin_layout Plain Layout

##IDEO
\end_layout

\begin_layout Plain Layout

table(anes1$V045117, exclude = NULL)
\end_layout

\begin_layout Plain Layout

levels_old <- levels(anes1$V045117)
\end_layout

\begin_layout Plain Layout

levels_old
\end_layout

\begin_layout Plain Layout

levels_new <- c("EL", "L", "SL", "M", "SC", "C", "EC", NA, NA, NA)
\end_layout

\begin_layout Plain Layout

ideolevels <- data.frame(levels_old = levels_old,
\end_layout

\begin_layout Plain Layout

               levels_new = levels_new,
\end_layout

\begin_layout Plain Layout

               stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

ideolevels
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30b2,include=T,echo=T>>=
\end_layout

\begin_layout Plain Layout

anes1$V045117 <- mapvalues(anes1$V045117, 
\end_layout

\begin_layout Plain Layout

                    from = ideolevels$levels_old, 
\end_layout

\begin_layout Plain Layout

                    to = ideolevels$levels_new)
\end_layout

\begin_layout Plain Layout

anes1$V043116 <- anes1$V045117[, drop = TRUE]
\end_layout

\begin_layout Plain Layout

rm(ideolevels) # remove unneeded object
\end_layout

\begin_layout Plain Layout

table(anes1.orig$V045117, anes1$V045117) # check
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options(options.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Itemize
Gender
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30c1,include=T,echo=T>>=
\end_layout

\begin_layout Plain Layout

##Gender
\end_layout

\begin_layout Plain Layout

table(anes1$V041109A, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Re-label the levels
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30c2,include=T,echo=T>>=
\end_layout

\begin_layout Plain Layout

levels(anes1$V041109A) <- c("M","F")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Itemize
Gay Marriage: Note the interesting mismatch between the 
\begin_inset Quotes eld
\end_inset

value labels
\begin_inset Quotes erd
\end_inset

 from the original data format and the levels as we see them in R
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30d,include=T,echo=T>>=
\end_layout

\begin_layout Plain Layout

## Gay Marriage
\end_layout

\begin_layout Plain Layout

levels(anes1$V043210) 
\end_layout

\begin_layout Plain Layout

## Shorter names
\end_layout

\begin_layout Plain Layout

levels(anes1$V043210) <- c("Allow","No","Some", NA, NA, NA) 
\end_layout

\begin_layout Plain Layout

anes1$V043210 <- anes1$V043210[ , drop = TRUE]
\end_layout

\begin_layout Plain Layout

table(anes1$V043210, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Subjectively, those levels seem out of order.
 Best way to put them right is to run factor
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

anes1$V043210 <- factor(anes1$V043210, levels = c("No", "Some", "Allow"))
\end_layout

\begin_layout Plain Layout

table(anes1.orig$V043210, anes1$V043210)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Itemize
Expect the economy to get better?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30e1,include=T,echo=T>>=
\end_layout

\begin_layout Plain Layout

## Economy
\end_layout

\begin_layout Plain Layout

anes1$V043213 <- anes1$V043213[ , drop = TRUE]
\end_layout

\begin_layout Plain Layout

table(anes1$V043213, exclude = NULL)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the levels are subjectively 
\begin_inset Quotes eld
\end_inset

out of order
\begin_inset Quotes erd
\end_inset

.
 User factor to re-order them
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30e2,include=T,echo=T>>=
\end_layout

\begin_layout Plain Layout

lvl <- levels(anes1$V043213)
\end_layout

\begin_layout Plain Layout

econnew <- factor(anes1$V043213, levels = lvl[c(2, 3, 1)], labels = c("Worse",
 "Same", "Better"))
\end_layout

\begin_layout Plain Layout

table(anes1$V043213, econnew)
\end_layout

\begin_layout Plain Layout

anes1$V043213 <- econnew
\end_layout

\begin_layout Plain Layout

rm(econnew)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Itemize
How does it make you feel to see the flag? 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options.orig <- options()
\end_layout

\begin_layout Plain Layout

options(width=60)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
scriptsize} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes30f,include=T,echo=T>>=
\end_layout

\begin_layout Plain Layout

##Flag
\end_layout

\begin_layout Plain Layout

(lvl <- levels(anes1$V045145X))
\end_layout

\begin_layout Plain Layout

anes1$V045145X[anes1$V045145X %in% lvl[6:7]] <- NA
\end_layout

\begin_layout Plain Layout

anes1$V045145X <- anes1$V045145X[, drop = TRUE] 
\end_layout

\begin_layout Plain Layout

table(anes1$V045145X)
\end_layout

\begin_layout Plain Layout

levels(anes1$V045145X) <- c("EG", "VG", "SG", "NVG", "DFA")
\end_layout

\begin_layout Plain Layout

table(anes1$V045145X)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<include=F,echo=F>>=
\end_layout

\begin_layout Plain Layout

options(options.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What to do about 
\begin_inset Quotes eld
\end_inset

Don't Feel Anything?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Should we convert to an ordinal variable?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{End result}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Bit by bit, we have brought the data.frame 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
anes1
\end_layout

\end_inset

 into the same coding scheme as 
\begin_inset Flex Code
status open

\begin_layout Plain Layout
anes2
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If you want the variable by variable comparison, this is a diagnostic output
 adapted from some internal functions in kutils.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval=F>>=
\end_layout

\begin_layout Plain Layout

kutils:::keyDiagnostic(anes1, anes2, kutils:::makeKeylist(key))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The manual recodes will show as the 
\begin_inset Quotes eld
\end_inset

oldvar
\begin_inset Quotes erd
\end_inset

 columns, while the key displays as the row tables
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Lets stash a copy of this working data frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<save1>>=
\end_layout

\begin_layout Plain Layout

today <- format(Sys.time(), "%Y%m%d")
\end_layout

\begin_layout Plain Layout

wdir <- "workingdata"
\end_layout

\begin_layout Plain Layout

if(!file.exists(wdir)) dir.create(wdir)
\end_layout

\begin_layout Plain Layout

saveRDS(anes1, file = file.path(wdir, paste0("nes2004-", today, ".rds")))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To re-open that, we'd use readRDS().
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Object Oriented R: Why Factors?
\end_layout

\begin_layout Subsection*
Functions Respond Differently to Factors
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Plot one numeric and one factor variable}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes20,fig=T,height=5,width=7,include=F>>=
\end_layout

\begin_layout Plain Layout

plot(V043038 ~ V043213, ylab="Bush Thermometer", xlab="Economic Expectations",
 data = anes1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{tmpout/t-anes20.tex}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=8cm]{tmpout/t-anes20}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
plot sent the work to the boxplot function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{How about the Age effect?}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes15,fig=T,height=5,width=7,include=F>>=
\end_layout

\begin_layout Plain Layout

plot(jitter(V043038) ~ V043250, ylab = "Bush Thermometer", xlab = "Age",
 data = anes1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includegraphics[width=8cm]{tmpout/t-anes15}
\end_layout

\begin_layout Plain Layout


\backslash
input{tmpout/t-anes15.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The jitter() function 
\begin_inset Quotes eld
\end_inset

scatters
\begin_inset Quotes erd
\end_inset

 points, avoids pile ups
\end_layout

\begin_layout Itemize
If you get interested in better plots for large numeric data sets, there
 are alternatives in addon packages.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Regression Responds differently
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Numeric Predictor}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Predict the Bush-Kerry Difference from respondent Age
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes40, include=F, echo=T>>=
\end_layout

\begin_layout Plain Layout

mod1 <- lm(th.bk ~ V043250, data = anes1)
\end_layout

\begin_layout Plain Layout

summary(mod1)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
tiny}
\end_layout

\begin_layout Plain Layout


\backslash
input{tmpout/t-anes40.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Add A Factor as a Predictor}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes45, include=F, echo=T>>=
\end_layout

\begin_layout Plain Layout

mod2 <- lm(th.bk ~ V043250 + V041109A, data = anes1)
\end_layout

\begin_layout Plain Layout

summary(mod2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
tiny}
\end_layout

\begin_layout Plain Layout


\backslash
input{tmpout/t-anes45.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Now Look Back at What R did with the Gender Predictor}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
R creates the 
\begin_inset Quotes eld
\end_inset

design matrix
\begin_inset Quotes erd
\end_inset

, the purely numerical representation of the variables.
 Notice it creates the dummy variable for Gender.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes60b>>=
\end_layout

\begin_layout Plain Layout

mod2mm <- model.matrix(mod2)
\end_layout

\begin_layout Plain Layout

head(mod2mm)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Add Party ID as a Predictor}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes70, include=F, echo=T>>=
\end_layout

\begin_layout Plain Layout

mod3 <- lm(th.bk ~ V043250 + V041109A + V043116, data = anes1)
\end_layout

\begin_layout Plain Layout

summary(mod3)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
tiny}
\end_layout

\begin_layout Plain Layout


\backslash
input{tmpout/t-anes70.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Check the model matrix now}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<anes70b, include=F>>=
\end_layout

\begin_layout Plain Layout

mod3mm <- model.matrix(mod3)
\end_layout

\begin_layout Plain Layout

head(mod3mm, 10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
Routsize{
\backslash
tiny}
\end_layout

\begin_layout Plain Layout


\backslash
input{tmpout/t-anes70b.tex}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In the olden days (or now if you use some software), the user has to create
 all those 
\begin_inset Quotes eld
\end_inset

dummy
\begin_inset Quotes erd
\end_inset

 columns to represent the levels.
 In R, we avoid it.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Save the regression objects in an RData file}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For my lecture about regression tables, I'll need those fitted models, so
 I might as well save them as well.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<save2>>=
\end_layout

\begin_layout Plain Layout

save(mod1, mod2, mod3, file = file.path(wdir, paste0("nes2004-objects-",
 today,  ".RData")))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{What is the focus?}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
R uses variable classes which guide plotting and analysis
\end_layout

\begin_layout Itemize
The classes we focus onâ€“integer, floating point, character, and factorâ€“are
 workhorses in statistical analysis
\end_layout

\begin_layout Itemize
Re-organizing data requires care, it is easy to get it wrong.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{The Variable Key is a new thing from CRMDA}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The Key is our strategy to put research projects on a commonly understood
 footing, avoid the danger that errors are hidden in details understood
 only to the research assistants
\end_layout

\begin_layout Itemize
Even if you decide you don't want to use it now, please check back on the
 kutils package from time-to-time because we introduce new features.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{References}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align left
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../../R"
options "apalike2"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Session}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sess10>>=
\end_layout

\begin_layout Plain Layout

sessionInfo()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<opts20, include=F>>=
\end_layout

\begin_layout Plain Layout

## Don't delete this.
 It puts the interactive session options
\end_layout

\begin_layout Plain Layout

## back the way they were.
 If this is compiled within a session
\end_layout

\begin_layout Plain Layout

## it is vital to do this.
\end_layout

\begin_layout Plain Layout

options(opts.orig)
\end_layout

\begin_layout Plain Layout

options(par.orig)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
