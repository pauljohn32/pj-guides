#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass beamer
\begin_preamble

\usepackage{dcolumn}
\usepackage{booktabs}

% use 'handout' to produce handouts
%\documentclass[handout]{beamer}
\usepackage{wasysym}
\usepackage{pgfpages}
\newcommand{\vn}[1]{\mbox{{\it #1}}}\newcommand{\vb}{\vspace{\baselineskip}}\newcommand{\vh}{\vspace{.5\baselineskip}}\newcommand{\vf}{\vspace{\fill}}\newcommand{\splus}{\textsf{S-PLUS}}\newcommand{\R}{\textsf{R}}


\usepackage{graphicx}
\usepackage{listings}

\mode<presentation>
{
  \usetheme{Antibes}
}

\usepackage{fancyvrb}
% In document Latex options:
\fvset{listparameters={\setlength{\topsep}{0em}}}
\def\Sweavesize{\normalsize} 
\def\Rcolor{\color{black}} 
\def\Rbackground{\color[gray]{0.95}}



\providecommand{\Rcolor}{\color[rgb]{0, 0.5, 0.5}}
\providecommand{\Routcolor}{\color[rgb]{0.461, 0.039, 0.102}}
\providecommand{\Rcommentcolor}{\color[rgb]{0.101, 0.043, 0.432}}

\providecommand{\Rbackground}{\color[gray]{0.95}}
\providecommand{\Routbackground}{\color[gray]{0.80}}
% Can specify \color[gray]{1} for white background or just \color{white}


\lstdefinestyle{Rstyle}{fancyvrb=false,escapechar=`,language=R,%
                        basicstyle={\Rcolor\footnotesize},%
                        backgroundcolor=\Rbackground,%
           tabsize=2,%
                        showstringspaces=false,%
                        keywordstyle=\Rcolor,%
                        commentstyle={\Rcommentcolor\ttfamily\itshape},%
                        literate={<-}{{$\leftarrow$}}2{<<-}{{$\twoheadleftarrow$}}2{~}{{$\sim$}}1{<=}{{$\leq$}}2{>=}{{$\geq$}}2{^}{{$^{\scriptstyle\wedge}$}}1,%
                        alsoother={$},%
                        alsoletter={.<-},%
                        otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
                        escapeinside={(*}{*)}}%
% Other options of interest:
% frame=single,framerule=0.1pt,framesep=1pt,rulecolor=\color{blue},
% numbers=left,numberstyle=\tiny,stepnumber=1,numbersep=7pt,
% keywordstyle={\bf\Rcolor}

\lstdefinestyle{Routstyle}{fancyvrb=false,literate={~}{{$\sim$}}1{R^2}{{$R^{2}$}}2{^}{{$^{\scriptstyle\wedge}$}}1{R-squared}{{$R^{2}$}}2,%
 frame=single,framerule=0.2pt,framesep=1pt,basicstyle=\Routcolor\Sweavesize,%
 backgroundcolor=\Routbackground}


\lstnewenvironment{Sinput}{\lstset{style=Rstyle}}{}
\lstnewenvironment{Scode}{\lstset{style=Rstyle}}{}
\lstnewenvironment{Soutput}{\lstset{style=Routstyle}}{}

\lstset{tabsize=2,basicstyle=\footnotesize, breaklines=true,style=Rstyle}
%\usetheme{Warsaw}
% or ...

%\setbeamercovered{transparent}
% or whatever (possibly just delete it)


%%not for article, but for presentation
\mode<presentation>
%\newcommand\makebeamertitle{\frame{\maketitle}}

\setbeamertemplate{frametitle continuation}[from second]
\renewcommand\insertcontinuationtext{...}


\expandafter\def\expandafter\insertshorttitle\expandafter{%
 \insertshorttitle\hfill\insertframenumber\,/\,\inserttotalframenumber}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Parallel Computing with R
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Parallel
\end_layout

\end_inset


\end_layout

\begin_layout Author
Paul E.
 Johnson
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\begin_layout Institute
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
1
\end_layout

\end_inset

Department of Political Science
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset

Center for Research Methods and Data Analysis, University of Kansas
\begin_inset Argument 1
status open

\begin_layout Plain Layout
K.U.
\end_layout

\end_inset


\end_layout

\begin_layout Date
2015
\begin_inset Argument 1
status open

\begin_layout Plain Layout
2015
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following causes the table of contents to be shown at the beginning
 of every subsection.
 Delete this, if you do not want it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSection[]{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
frame<beamer>{ 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
frametitle{Outline}   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection,currentsubsection] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frametitle{Outline}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Bookmark: crmda.ku.edu/computing
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
crmda.ku.edu/computing
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
That's the official reference for HOW TO use the cluster and its systems.
\end_layout

\begin_layout Itemize
If that material is unclear or unhelpful, notify me.
 We will fix it.
\end_layout

\begin_layout Itemize
If you want to know how to do something, please refer to that material first
 before asking Google how its done at the University of Alabama
\end_layout

\begin_layout Itemize
When uncertain, please review examples in hpcexamples.
\end_layout

\end_deeper
\begin_layout Section
ACF
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What is a 
\begin_inset Quotes eld
\end_inset

cluster
\begin_inset Quotes erd
\end_inset

?
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Cluster: lots of separate workstations (
\begin_inset Quotes eld
\end_inset

nodes
\begin_inset Quotes erd
\end_inset

) that are networked together.
\end_layout

\begin_layout Standard
Racks and racks of compute nodes
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rack 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rack 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rack 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-0-0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-1-0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-2-0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-0-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-1-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-2-1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-0-2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-1-2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-2-2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-0-19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-1-19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-2-19
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

compute nodes
\begin_inset Quotes erd
\end_inset

 are separate Linux systems where the computations take place.
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
login2 is the login node
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
login2.acf.ku.edu: where you log in, in order to gain access.
 
\end_layout

\begin_layout Description
RULE
\begin_inset space ~
\end_inset

1.
 Do not do 
\begin_inset Quotes eld
\end_inset

computing
\begin_inset Quotes erd
\end_inset

 on login2.acf.ku.edu.
 Why?
\end_layout

\begin_deeper
\begin_layout Itemize
Keep that node 
\begin_inset Quotes eld
\end_inset

open
\begin_inset Quotes erd
\end_inset

 for many users to monitor jobs running in the cluster
\end_layout

\begin_layout Itemize
login2 lacks many programs you want
\end_layout

\begin_layout Itemize
programs are installed in the compute nodes
\end_layout

\end_deeper
\begin_layout Standard
Login nodes on ACF: is a place to
\end_layout

\begin_layout Itemize
begin 
\begin_inset Quotes eld
\end_inset

interactive
\begin_inset Quotes erd
\end_inset

 sessions (the 
\begin_inset Quotes eld
\end_inset

interactive
\begin_inset Quotes erd
\end_inset

 que).
\end_layout

\begin_layout Itemize
submit and monitor longer running jobs (the 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 que).
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
node and processor
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Users ask for resources from the cluster, referring to nodes and processor
 per node
\end_layout

\begin_layout Description
node: one of those separate computer systems
\end_layout

\begin_layout Description
ppn: processor per node (2015: our systems have 20 CPUs per node)
\end_layout

\begin_layout Standard
RAM 2GB per processor.
\end_layout

\begin_layout Standard
If you ask for nodes=8:ppn=1 the scheduler may assign your 8 jobs to ONE
 compute node.
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Interactive que}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This is just like 
\begin_inset Quotes eld
\end_inset

logging into
\begin_inset Quotes erd
\end_inset

 a remote workstation, such as compute-1-1.
 It is used for 
\end_layout

\begin_deeper
\begin_layout Itemize
developing code
\end_layout

\begin_layout Itemize
testing programs
\end_layout

\end_deeper
\begin_layout Itemize
HOWTO? From login2.acf.ku.edu, run this command:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ qsub -I -q interactive -l nodes=1:ppn=1
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

shortcut
\begin_inset Quotes erd
\end_inset

 we created for that is 
\series bold
qlogin
\end_layout

\begin_layout Itemize
That asks for permission to have a 
\begin_inset Quotes eld
\end_inset

login
\begin_inset Quotes erd
\end_inset

 session with one compute node with 1 processor in that node.
\end_layout

\end_deeper
\begin_layout Itemize
To request an interactive session with more nodes, adjust the values accordingly.
\end_layout

\begin_layout Itemize
This does NOT ask for X11 
\begin_inset Quotes eld
\end_inset

graphic forwarding
\begin_inset Quotes erd
\end_inset

, will be a strictly TEXT session (CLI)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{X-server Allowed}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If you have an X-server running, or are in NoMachine, add a -X in the command:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ qsub -I -X -q interactive -l nodes=1:ppn=1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Compare to output from
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ cat /usr/local/bin/qxlogin
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If your PC has an X11 server running, graphics display as sent out from
 compute node, through the login node, into your PC
\end_layout

\begin_layout Itemize
If you have NoMachine running, graphics display from compute node to login2,
 and then NoMachine shows the graphics for that.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Shortcuts to Interactive Sessions}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Repeat: Shortcut programs to launch interactive sessions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ qlogin
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or, for X11 enabled sessions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ qxlogin
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If more nodes or PPN are required, options are allowed:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ qlogin 2 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ qxlogin 2 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Would request 2 nodes with 3 ppn.
\end_layout

\begin_layout Itemize
While testing some cluster programs, I DO run interactive multi-node sessions.
 But I usually just run 
\begin_inset Quotes eld
\end_inset

qsub ...
\begin_inset Quotes erd
\end_inset

 with the details written out.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The default Que
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 queue is where most of our jobs are submitted
\end_layout

\begin_layout Itemize
User must prepare 2 things.
\end_layout

\begin_deeper
\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

submission script
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
A program that is capable of using the compute node(s) requested
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Submission Script}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Most submission scripts have 
\begin_inset Quotes eld
\end_inset

boiler plate
\begin_inset Quotes erd
\end_inset

 at the top (lines 1-8)
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},numbers=left"
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#PBS -N Rsimple
\end_layout

\begin_layout Plain Layout

#PBS -l nodes=1:ppn=1
\end_layout

\begin_layout Plain Layout

#PBS -l walltime=00:10:00
\end_layout

\begin_layout Plain Layout

#PBS -M your-email-address-here@ku.edu
\end_layout

\begin_layout Plain Layout

#PBS -m bea
\end_layout

\begin_layout Plain Layout

#PBS -q default
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Now the commands that "run something"
\end_layout

\begin_layout Plain Layout

cd $PBS_O_WORKDIR
\end_layout

\begin_layout Plain Layout

R --vanilla --no-save -f r-serial.R
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Boiler Plate Submission Script}
\end_layout

\end_inset


\end_layout

\begin_layout Description
-N the name of the job--you choose that as a reminder for yourself
\end_layout

\begin_layout Description
-l
\begin_inset space ~
\end_inset

nodes= resource request.
 CAN be more elaborate, specifying memory and other restrictions
\end_layout

\begin_layout Description
-l
\begin_inset space ~
\end_inset

walltime maximum time job can run before it is killed by OS
\end_layout

\begin_layout Description
-M YOUR email address.
 If you see 
\begin_inset Quotes eld
\end_inset

pauljohn@ku.edu
\begin_inset Quotes erd
\end_inset

, please change it
\end_layout

\begin_layout Description
-m bea send email to YOUR email address when job begins, ends, or crashes.
\end_layout

\begin_layout Description
-q default.
 it is the proper name of our cluster's standard batch queue.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{qstat}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
On login2, to review the jobs that are running
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$ qstat
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
sift through for your jobs
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$ qstat | grep your-name-here
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
kill job that is running by its NUMBER
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$ qdel nnn
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
ACF also has a Web accessible program 
\begin_inset Quotes eld
\end_inset

ganglia
\begin_inset Quotes erd
\end_inset

 that can be used to survey running programs.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ganglia.acf.ku.edu
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Network File System
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We CAN write on /tmp inside each node's hard disk
\end_layout

\begin_layout Itemize
/home/username and /crmda/user/username are Network File System shares,
 they are links that point to a network storage device.
\end_layout

\begin_layout Itemize
Warning: reading and writing lots of small files in the NFS is SLOW, and
 if your project requires lots and lots of writing, it is worthwhile to
 learn how to read & write in /tmp and copy results into /home when needed.
\end_layout

\begin_layout Itemize
Our nodes have small hard disks, so be cautious with this.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Complication: Infiniband vs Ethernet}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Due to a purchasing mistake, we have 
\end_layout

\begin_deeper
\begin_layout Itemize
1 rack of systems that use a super-fast communication system called Infiniband
 
\end_layout

\begin_layout Itemize
2 racks of systems that use fast (1GB) ethernet cables
\end_layout

\end_deeper
\begin_layout Itemize
Communication between the infiniband and the ethernet systems is not good
 and will crash some kinds of cluster compute projects.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Infiniband Workaround}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

noib
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ib
\begin_inset Quotes erd
\end_inset

 options in submission scripts.
 
\end_layout

\begin_layout Itemize
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#PBS -l nodes=11:ppn=1:noib
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will confine the nodes to be selected from the non-infiniband systems.
\end_layout

\begin_layout Itemize
ib restricts job to infiniband nodes.
\end_layout

\begin_layout Itemize
This is only necessary with programs that use the MPI, the Message Passing
 Interface.
\end_layout

\begin_layout Itemize
It is not necessary for running jobs that simply launch one instance or
 Mplus, SAS, or R.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Run One Program
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Please Walk Before You Run (lots of jobs)}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Before you get fancy and try to run a job on 20 nodes at once
\end_layout

\begin_layout Itemize
Make sure it runs well on one node!
\end_layout

\begin_layout Itemize
This is necessary! 
\end_layout

\begin_deeper
\begin_layout Itemize
check your memory usage.
 
\end_layout

\begin_layout Itemize
make sure your program is efficient
\end_layout

\begin_layout Itemize
possible to profile 1 program on 1 node (not possible to profile a parallel
 run)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{hpcexample Ex50: R example}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Some Windows or Mac users have never 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 a program, so try that now.
\end_layout

\begin_layout Itemize
Get your R program that works, say myCoolProgram.R.
 Be sure it writes output, such as a pdf, and saves some data output or
 a fitted model in a file.
\end_layout

\begin_deeper
\begin_layout Enumerate
Copy it to login2.quant.ku.edu.
 
\end_layout

\begin_layout Enumerate
Put it in a subdirectory.
 
\end_layout

\begin_layout Enumerate
Log into an interactive session.
 
\end_layout

\begin_layout Enumerate
Change into the subdirectory where you wrote the R program.
 
\end_layout

\begin_layout Enumerate
Run the program.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{How to run R from the command line?}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
There are many ways to run an R program, such as the traditional method:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

R < myCoolProgram.R &
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
but generally I like this style better (does same):
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

R -f myCoolProgram.R &
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
At one time, I was very eager to use Rscript instead, but I don't see much
 difference now.
 Warning: some people are emphatic about Rscript or littler.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Monitor a long running job}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Start a few xterms from the same compute node.
\end_layout

\begin_layout Itemize
On one terminal, monitor CPU and memory
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ top
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
In another terminal, run the R program.
\end_layout

\begin_layout Itemize
On another terminal, run something like this to get a different view
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ ps -aux | grep R 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Prepare for Parallel: Be Cautious about R's environment}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Ever notice R reads your 
\begin_inset Quotes eld
\end_inset

saved session
\begin_inset Quotes erd
\end_inset

 and always wants to save a workspace when you close?
\end_layout

\begin_layout Itemize
Some people like that, but in the cluster YOU MUST NOT DEPEND on saved session
 files (.RData) to make your program work.
\end_layout

\begin_layout Itemize
So add command line options like 
\begin_inset Quotes eld
\end_inset

--no-restore-data
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

--no-save
\begin_inset Quotes erd
\end_inset

, or get all of the options with --vanilla.
 So test your program again like this:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ R --vanilla  -f myCoolProgram.R &
\end_layout

\end_inset


\end_layout

\begin_layout Standard
--vanilla combines --no-save, --no-restore, --no-site-file, --no-init-file
 and --no-environ
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{How to schedule same R program on the default que}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Running interactively is FINE, it is just same as submitting a job on the
 que so that it can be sent to a compute node
\end_layout

\begin_layout Itemize
But, if it is a long-running job, it is necessary for you to 
\begin_inset Quotes eld
\end_inset

keep the terminal open
\begin_inset Quotes erd
\end_inset

 for a long time.
\end_layout

\begin_layout Itemize
Instead, schedule the job in the cluster, let the job go into the batch
 que.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Submission Script in Ex50 from hpcexamples}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The submission script was shown above.
 See the file 
\begin_inset Quotes eld
\end_inset

sub-serial.sh
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small},numbers=left"
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#PBS -N Rsimple
\end_layout

\begin_layout Plain Layout

#PBS -l nodes=1:ppn=1
\end_layout

\begin_layout Plain Layout

#PBS -l walltime=00:10:00
\end_layout

\begin_layout Plain Layout

#PBS -M your-email-address-here@ku.edu
\end_layout

\begin_layout Plain Layout

#PBS -m bea
\end_layout

\begin_layout Plain Layout

#PBS -q default
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cd $PBS_O_WORKDIR
\end_layout

\begin_layout Plain Layout

R --vanilla -f r-serial.R
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Run Ex50.
 r-serial.R is a very small example program}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Go to login2.acf.ku.edu
\end_layout

\begin_layout Itemize
Go to compute node (interctive login)
\end_layout

\begin_layout Itemize
Make sure your GIT copy of hpcexample is up to date
\end_layout

\begin_layout Itemize
cd to Ex50, revise sub-serial.sh to fit your needs
\end_layout

\begin_layout Itemize
exit back to login2.acf.ku.edu
\end_layout

\begin_layout Itemize
Submit the job
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ qsub sub-serial.sh
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Your result files}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The R program generates several output files.
\end_layout

\begin_deeper
\begin_layout Itemize
This job creates a PDF image of a graph
\end_layout

\end_deeper
\begin_layout Itemize
The cluster also creates 2 files, an 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 file and an 
\begin_inset Quotes eld
\end_inset

o
\begin_inset Quotes erd
\end_inset

 file
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

o
\begin_inset Quotes erd
\end_inset

 standard output, the messages that would have gone to terminal if you ran
 R from CLI
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 standard error, which also would have gone to terminal.
\end_layout

\end_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

o
\begin_inset Quotes erd
\end_inset

 files will have the name you declared in your submission script (-N) and
 the job number in the cluster.
\end_layout

\begin_layout Itemize
For testing, I ran that job 2012-10-22.
\end_layout

\begin_layout Itemize
Rsimple.o517451 looks just like an ordinary R output in the terminal:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

R version 2.15.0 (2012-03-30)
\end_layout

\begin_layout Plain Layout

Copyright (C) 2012 The R Foundation for Statistical Computing
\end_layout

\begin_layout Plain Layout

ISBN 3-900051-07-0
\end_layout

\begin_layout Plain Layout

Platform: x86_64-redhat-linux-gnu (64-bit)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R is free software and comes with ABSOLUTELY NO WARRANTY.
\end_layout

\begin_layout Plain Layout

You are welcome to redistribute it under certain conditions.
\end_layout

\begin_layout Plain Layout

Type 'license()' or 'licence()' for distribution details.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  Natural language support but running in an English locale
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R is a collaborative project with many contributors.
\end_layout

\begin_layout Plain Layout

Type 'contributors()' for more information and
\end_layout

\begin_layout Plain Layout

'citation()' on how to cite R or R packages in publications.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Type 'demo()' for some demos, 'help()' for on-line help, or
\end_layout

\begin_layout Plain Layout

'help.start()' for an HTML browser interface to help.
\end_layout

\begin_layout Plain Layout

Type 'q()' to quit R.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> ## Paul Johnson
\end_layout

\begin_layout Plain Layout

> ## The second stupidest R program ever.
\end_layout

\begin_layout Plain Layout

>
\end_layout

\begin_layout Plain Layout

> x <- rnorm(1000, mean=17, sd=43)
\end_layout

\begin_layout Plain Layout

>
\end_layout

\begin_layout Plain Layout

> mean(x)
\end_layout

\begin_layout Plain Layout

> pdf("testGraph.pdf", height=6, width=6, onefile=F, family="Times") 
\end_layout

\begin_layout Plain Layout

> hist(x, main="One Stupid Histogram") 
\end_layout

\begin_layout Plain Layout

> dev.off() 
\end_layout

\begin_layout Plain Layout

null device           1
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
And the 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 file Rsimple.e517451 is a big empty NOTHING, meaning no problem at all!
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.
    
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Remember, the 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 file is reporting the standard error output from the SHELL, not R error
 messages.
 R errors still show up in Rsimple.o517451.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{View System Usage in a Longer-Running Program}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
ACF will email you when the job starts.
\end_layout

\begin_deeper
\begin_layout Itemize
it will tell you which node is running your job (ex, compute-0-0).
\end_layout

\end_deeper
\begin_layout Itemize
If the job is running for a while, you can go track its memory usage
\end_layout

\begin_deeper
\begin_layout Itemize
ACF DOES NOT allow a command like 
\begin_inset Quotes eld
\end_inset

ssh compute-0-0
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Itemize
But ACF will allow you to get to compute-0-0 via the interactive que:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ qsub -I -l nodes=compute-0-0
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If you forget the format, just run 
\begin_inset Quotes eld
\end_inset

qxlogin
\begin_inset Quotes erd
\end_inset

 to get to any node, and from there 
\begin_inset Quotes eld
\end_inset

ssh compute-0-0
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
In the shell, run programs like 
\begin_inset Quotes eld
\end_inset

top
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ps
\begin_inset Quotes erd
\end_inset

 to view memory usage of your program.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Many Serial R Programs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{"Poor Person's" Parallel Computing}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Need to run a program 1000 times, with different 
\end_layout

\begin_deeper
\begin_layout Itemize
random number seeds, or
\end_layout

\begin_layout Itemize
parameters
\end_layout

\end_deeper
\begin_layout Itemize
Strategy.
 Write one program that accepts command-line arguments
\end_layout

\begin_layout Itemize
Write 1000 submission scripts, 
\end_layout

\begin_deeper
\begin_layout Itemize
adjust the submision scripts to provide slightly different arguments for
 each run
\end_layout

\end_deeper
\begin_layout Itemize
hpcexamples Ex51-ManySerialJobs demonstrate this.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Command Line Arguments}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
All programs worth using allow command line arguments.
 (no need to recompile or edit program, just run with different arguments!)
\end_layout

\begin_layout Itemize
Suppose, for example, we want to re-set the run number and the random seed.
 
\end_layout

\begin_layout Itemize
Re-write the R code to scan the command line arguments and do the right
 thing, so we can run:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

R --vanilla -f r-commandline.R --args run="010" seed="12345"
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The R function commandArgs() can be used to receive command line arguments.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Ex51: command line arguments}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
User has responsibility to 
\begin_inset Quotes eld
\end_inset

parse
\begin_inset Quotes erd
\end_inset

 those arguments and put them to use.
\end_layout

\begin_layout Itemize
The example program r-commandline.R demonstrates.
 Please read r-commandline.R.
 
\end_layout

\begin_layout Itemize
Examples:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ R -f r-commandline.R --args myMeanN=88.1231 runI=11 whateverC="hell" nofcasesI=2
323
\end_layout

\begin_layout Plain Layout

$ R -f r-commandline.R --args myMeanN=77.1231 runI=12 whateverC="hell" nofcasesI=1
121
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
That will generate pdf and R data files in the current working directory
 (because outdirC was not specified).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Ex51 README}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here's the README file:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},breaklines=true,language=R,tabsize=1"
inline false
status open

\begin_layout Plain Layout

## Paul Johnson 
\end_layout

\begin_layout Plain Layout

## 2012-10-22
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Ex51-R-ManySerialJobs
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In the previous exercise, we saw how to send one R program through the queue.
 This example shows how to create submission scripts for 100s or 1000s of
 similar jobs and run them.
 But it does not re-write 100s or 1000s of R programs, it just re-runs one
 with subtle variations.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Instead of a lot of explanation, perhaps you need a demonstration.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

After downloading this code, you see this README and 3 files
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

generate.sh
\end_layout

\begin_layout Plain Layout

submit.sh
\end_layout

\begin_layout Plain Layout

r-commandline.R
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

"generate.sh" creates files in a new directory SubScripts and it creates
 an empty directory Output.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

See for yourself.
  Run this command:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ sh ./generate.sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

That should create a directory SubScripts and in it you see lots of submission
 scripts:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ ls SubScripts/
\end_layout

\begin_layout Plain Layout

subjob001.sh  subjob006.sh  subjob011.sh  subjob016.sh
\end_layout

\begin_layout Plain Layout

subjob002.sh  subjob007.sh  subjob012.sh  subjob017.sh
\end_layout

\begin_layout Plain Layout

subjob003.sh  subjob008.sh  subjob013.sh  subjob018.sh
\end_layout

\begin_layout Plain Layout

subjob004.sh  subjob009.sh  subjob014.sh  subjob019.sh
\end_layout

\begin_layout Plain Layout

subjob005.sh  subjob010.sh  subjob015.sh  subjob020.sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

If you look at each of those files, you should see it is a completely self
 contained submission script that sends the file I  called 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

r-commandline.R
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

to R along with some arguments (some 'command line' arguments!).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Now tell the system to run all of those submission scripts.
  Yes, I literally mean, run each one separately.
 The script "submit.sh" goes into SubScripts and it fires
\end_layout

\begin_layout Plain Layout

each one into the queue.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Here's what I see.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ sh ./submit.sh
\end_layout

\begin_layout Plain Layout

21776.rocky.local
\end_layout

\begin_layout Plain Layout

21777.rocky.local
\end_layout

\begin_layout Plain Layout

21778.rocky.local
\end_layout

\begin_layout Plain Layout

21779.rocky.local
\end_layout

\begin_layout Plain Layout

21780.rocky.local
\end_layout

\begin_layout Plain Layout

21781.rocky.local
\end_layout

\begin_layout Plain Layout

21782.rocky.local
\end_layout

\begin_layout Plain Layout

21783.rocky.local
\end_layout

\begin_layout Plain Layout

21784.rocky.local
\end_layout

\begin_layout Plain Layout

21785.rocky.local
\end_layout

\begin_layout Plain Layout

21786.rocky.local
\end_layout

\begin_layout Plain Layout

21787.rocky.local
\end_layout

\begin_layout Plain Layout

21788.rocky.local
\end_layout

\begin_layout Plain Layout

21789.rocky.local
\end_layout

\begin_layout Plain Layout

21790.rocky.local
\end_layout

\begin_layout Plain Layout

21791.rocky.local
\end_layout

\begin_layout Plain Layout

21792.rocky.local
\end_layout

\begin_layout Plain Layout

21793.rocky.local
\end_layout

\begin_layout Plain Layout

21794.rocky.local
\end_layout

\begin_layout Plain Layout

21795.rocky.local
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The usual text output and error files get dropped into SubScripts because
 that is set as the "working directory".
 See here:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ ls SubScripts/
\end_layout

\begin_layout Plain Layout

kjob001.e21776  kjob011.e21786  subjob001.sh
\end_layout

\begin_layout Plain Layout

kjob001.o21776  kjob011.o21786  subjob002.sh
\end_layout

\begin_layout Plain Layout

kjob002.e21777  kjob012.e21787  subjob003.sh
\end_layout

\begin_layout Plain Layout

kjob002.o21777  kjob012.o21787  subjob004.sh
\end_layout

\begin_layout Plain Layout

kjob003.e21778  kjob013.e21788  subjob005.sh
\end_layout

\begin_layout Plain Layout

kjob003.o21778  kjob013.o21788  subjob006.sh
\end_layout

\begin_layout Plain Layout

kjob004.e21779  kjob014.e21789  subjob007.sh
\end_layout

\begin_layout Plain Layout

kjob004.o21779  kjob014.o21789  subjob008.sh
\end_layout

\begin_layout Plain Layout

kjob005.e21780  kjob015.e21790  subjob009.sh
\end_layout

\begin_layout Plain Layout

kjob005.o21780  kjob015.o21790  subjob010.sh
\end_layout

\begin_layout Plain Layout

kjob006.e21781  kjob016.e21791  subjob011.sh
\end_layout

\begin_layout Plain Layout

kjob006.o21781  kjob016.o21791  subjob012.sh
\end_layout

\begin_layout Plain Layout

kjob007.e21782  kjob017.e21792  subjob013.sh
\end_layout

\begin_layout Plain Layout

kjob007.o21782  kjob017.o21792  subjob014.sh
\end_layout

\begin_layout Plain Layout

kjob008.e21783  kjob018.e21793  subjob015.sh
\end_layout

\begin_layout Plain Layout

kjob008.o21783  kjob018.o21793  subjob016.sh
\end_layout

\begin_layout Plain Layout

kjob009.e21784  kjob019.e21794  subjob017.sh
\end_layout

\begin_layout Plain Layout

kjob009.o21784  kjob019.o21794  subjob018.sh
\end_layout

\begin_layout Plain Layout

kjob010.e21785  kjob020.e21795  subjob019.sh
\end_layout

\begin_layout Plain Layout

kjob010.o21785  kjob020.o21795  subjob020.sh
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

If I find a way to force the individual job report files into a separate
 directory, I will do that.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The R program creates one pdf image and one R save file as results, and
 each one is put into the Output directory.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ ls Output/
\end_layout

\begin_layout Plain Layout

testGraph001.pdf  testGraph015.pdf  testsave009.Rda
\end_layout

\begin_layout Plain Layout

testGraph002.pdf  testGraph016.pdf  testsave010.Rda
\end_layout

\begin_layout Plain Layout

testGraph003.pdf  testGraph017.pdf  testsave011.Rda
\end_layout

\begin_layout Plain Layout

testGraph004.pdf  testGraph018.pdf  testsave012.Rda
\end_layout

\begin_layout Plain Layout

testGraph005.pdf  testGraph019.pdf  testsave013.Rda
\end_layout

\begin_layout Plain Layout

testGraph006.pdf  testGraph020.pdf  testsave014.Rda
\end_layout

\begin_layout Plain Layout

testGraph007.pdf  testsave001.Rda   testsave015.Rda
\end_layout

\begin_layout Plain Layout

testGraph008.pdf  testsave002.Rda   testsave016.Rda
\end_layout

\begin_layout Plain Layout

testGraph009.pdf  testsave003.Rda   testsave017.Rda
\end_layout

\begin_layout Plain Layout

testGraph010.pdf  testsave004.Rda   testsave018.Rda
\end_layout

\begin_layout Plain Layout

testGraph011.pdf  testsave005.Rda   testsave019.Rda
\end_layout

\begin_layout Plain Layout

testGraph012.pdf  testsave006.Rda   testsave020.Rda
\end_layout

\begin_layout Plain Layout

testGraph013.pdf  testsave007.Rda
\end_layout

\begin_layout Plain Layout

testGraph014.pdf  testsave008.Rda
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Why does all this work?  I'm not sure how much detail you need.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

I've used this approach with simulations in Swarm, so it is familiar to
 me, but I understand it may be totally unfamiliar to you.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Here's the important preliminary fact: 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    A program can accept command line arguments.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Recall, for example, you can run either
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ ls
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

or
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ ls -la
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The "-la" changes what ls does.
 The "-la" is a command line argument.
 The ls command has many arguments, each one has to be configured for a
 specific purpose.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In Unix programming, it would be customary to start jobs with options that
 use one dash or two dashes, like so
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

$ aProgram --run=001 --mean=7.3 -k4 -p
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(two dashes for arguments that use an equal sign and a value, one dash for
 values that don't require an equal sign).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Now we adapt that idea to work with our R project.
  R can be started with user customized "command line arguments" that tell
 R what to do and where to do it.
 R is very informal about this, there is no requirement that arguments begin
 with dashes or such.
  Frankly, I wish it were more structured.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

On the University of Iowa stat website, I found an example of an R function
 that can scan the command line arguments and 'clean them up' a bit, so
 that a number "7" can be turned into an R integer, and similarly, 3.32323
 can be seen as a numeric real-valued variable.
 They do that with a "boilerplate" function at the start of every R script,
 and you see my version of that function here in the top of
\end_layout

\begin_layout Plain Layout

"r-commandline.R".
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In this case, I elect to name the arguments with last letters N, I, and
 C.
  For example, "mymeanN" or "nofcasesI" means mymeanN is a numeric "floating
 point" value and nofcasesI is an integer (it can make a difference).
  Argument names that end in capital I are seen as integers, and all variables
 that end in capital N are numeric.
 And C is for character variables.
  If we pass through arguments without I or N on the end, then the processor
 will accept them as they are.
  I believe that makes them characters.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Then, to pass R an option to let it use the value of 7.3 for a variable "mymeanN"
, use the command line option --mymeanN=7.3.
  In r-commndline.R, I have also told R the number of cases for the run and
 given an option "run" so that it will be able to number output files.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R -f r-command-line.R --args mymeanN=7.3 nofcasesI=222 run=001
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Inside the program r-command-line.R, I put in some "ifelse" to make this
 thing run even when I forget to put in the command line argument.
 Otherwise it is a complete bore to test this out.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

So we would like to run jobs with a lot of random samples, for example,
 or to change the mean or other parameters.
  We imagine we are running these things one after the other
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R -f r-command-line.R --args mymeanN=7.3 nofcasesI=222 runI=001
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R -f r-command-line.R --args  mymeanN=7.3 nofcasesI=222 runI=002
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R -f r-command-line.R --args mymeanN=7.3 nofcasesI=222 runI=003
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The queue system in the cluster will not accept a big bunch of commands
 all at once.
 Instead, we script these up to run one at a time, so they can fly around
 the cluster to find unused CPUs.
  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The jobs are all submitted by the submit.sh script.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

If you want to customize this to your project, the only difficult part is
 figuring out which arguments you want to pass through and how they are
 specified in the generate.sh script.
 This one fits my needs, but you may need to put on your thinking cap.
  In case you need to know what language is legal, search for documents
 on BASH scripting.
  BASH is the "Bourne Again" shell, the most popular shell since about 1995.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Please Note:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

This is not using MPI or Rmpi, it is just sending the separate jobs to the
 separate systems.
 It is sufficient for many purposes, but it leaves some important issues
 un-managed.
  Most importantly, it does not do anything about the problem of co-ordinating
 the generation of random numbers across the systems in the cluster.
 
\end_layout

\begin_layout Plain Layout

There is nothing to make sure the streams upon which the systems draw are
 unique.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Suppose you do something like re-seed each job like this:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

set.seed(43 * runI)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

That, or something like it, is very widely used.
 We would feel pretty sure that the streams are not overlapping, but we
 could never be completely sure.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

I'm working out a solution for that problem, in a separate project on portable
 parallel seeds.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The other major limitation here is that it generates the separate results
 for separate projects, but does not make it too convenient to integrate
 the results.
 If that's a concern, then one should turn to one of the more integrated
 parallel computing approaches, like Rmpi, or derivatives like SNOW or SNOWFT
 or such.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{This assumes program accepts command line arguments}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Some programs are stupid, do not have way to receive command line options
 inside a program.
\end_layout

\begin_layout Itemize
In these cases, such as with Mplus, it is necessary to revise our plan.
 The script that creates the submission scripts must also write 1000 mplus
 programs.
\end_layout

\begin_layout Itemize
For an example of that, see hpcexamples Ex08-MplusRunall-1, Ex09-MplusRunall-2
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Shortcomings}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Does not guarantee that random number streams do not 
\begin_inset Quotes eld
\end_inset

overlap
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Makes integration of results across all simulations more difficult
\end_layout

\begin_layout Standard
But the benefit of this approach is plain.
 If you can write one R program, you can easily script it to run over and
 over again.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Multi-Core
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Multicore
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Shared memory
\begin_inset Quotes erd
\end_inset

 computing: the RAM in a machine is shared among several cores
\end_layout

\begin_layout Itemize
Special math and computation algorithms may be able to divide work among
 cores to speed things up.
\end_layout

\begin_layout Itemize
R parallel package (introduced with R-2.14 formalized the plan for multi-core
 support in the 
\begin_inset Quotes eld
\end_inset

parallel
\begin_inset Quotes erd
\end_inset

 package).
\end_layout

\begin_deeper
\begin_layout Itemize
See the function 
\begin_inset Quotes eld
\end_inset

mclapply
\begin_inset Quotes erd
\end_inset

 to automatically divide work on list elements among cores
\end_layout

\end_deeper
\begin_layout Itemize
I used recently in speeding up report generation in one project
\end_layout

\end_deeper
\begin_layout Separator

\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Be Cautious
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Not available on Windows
\end_layout

\begin_layout Itemize
It CONFLICTS with the MPI framework that I have used more often.
\end_layout

\begin_layout Itemize
Will go BERSERK if you run it with browser() in your R code, will not allow
 debug.
\end_layout

\begin_layout Itemize
If you use this, try to learn about the ways that we can tell R how many
 cores to use.
\end_layout

\begin_layout Itemize
multicore work does not always go faster, because work of dividing up a
 job causes 
\begin_inset Quotes eld
\end_inset

overhead
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Section
Rmpi
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Rmpi: R on top of OpenMPI}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
C library 
\begin_inset Quotes eld
\end_inset

OpenMPI
\begin_inset Quotes erd
\end_inset

 implements the 
\begin_inset Quotes eld
\end_inset

message passing interface
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
R package Rmpi is a layer between OpenMPI and R
\end_layout

\begin_layout Itemize
Use Rmpi to 
\begin_inset Quotes eld
\end_inset

spawn a cluster
\begin_inset Quotes erd
\end_inset

 of worker nodes, send work to them, collect it up
\end_layout

\begin_layout Itemize
Other parallel packages sit on top of Rmpi
\end_layout

\begin_deeper
\begin_layout Itemize
SNOW (Ex60-HelloWorldSnow), SNOWFT (Ex61-HelloWorldSnowFT)
\end_layout

\begin_layout Itemize
doMPI, foreach, (and many other packages)
\end_layout

\begin_layout Itemize
R's own 
\begin_inset Quotes eld
\end_inset

parallel
\begin_inset Quotes erd
\end_inset

 sits 
\begin_inset Quotes eld
\end_inset

on top
\begin_inset Quotes erd
\end_inset

 of SNOW and other cluster-level packages.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Write programs with the Rmpi package, or with SNOW?}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why use Rmpi?
\end_layout

\begin_layout Itemize
Plenty of features (was very 
\begin_inset Quotes eld
\end_inset

bare boned
\begin_inset Quotes erd
\end_inset

 in early days)
\end_layout

\begin_layout Itemize
When errors occur, source may be more obvious (not obscured by addon-components)
\end_layout

\begin_layout Standard
Why use SNOW or others that sit 
\begin_inset Quotes eld
\end_inset

on top
\begin_inset Quotes erd
\end_inset

 of Rmpi?
\end_layout

\begin_layout Itemize
SNOW may handle details more correctly than you can!
\end_layout

\begin_layout Itemize
R parallel attempts to standardize terminology, handling details for us
 (not perfect yet, but nothing is).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Submission script changes: orterun.}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
See: Ex53-HelloWorldRmpi
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#PBS -N RmpiHelloWorld 
\end_layout

\begin_layout Plain Layout

#PBS -l nodes=21:ppn=1:noib
\end_layout

\begin_layout Plain Layout

#PBS -l walltime=00:60:00
\end_layout

\begin_layout Plain Layout

#PBS -M pauljohn@ku.edu
\end_layout

\begin_layout Plain Layout

#PBS -m bea
\end_layout

\begin_layout Plain Layout

#PBS -q default
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cd $PBS_O_WORKDIR
\end_layout

\begin_layout Plain Layout

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib
\end_layout

\begin_layout Plain Layout

## Works in "spawn mode" we only ask for 1 process initially.
\end_layout

\begin_layout Plain Layout

orterun -np 1 -hostfile $PBS_NODEFILE R --vanilla -f mpi-hello.R
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Look at the last line}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
orterun is a program from OpenMPI, it cooperates with cluster framework.
\end_layout

\begin_layout Itemize
-np 1 
\end_layout

\begin_deeper
\begin_layout Itemize
cluster 
\begin_inset Quotes eld
\end_inset

spawn
\begin_inset Quotes erd
\end_inset

 mode means 
\begin_inset Quotes eld
\end_inset

claim one node for the master node
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Since script asks for more nodes above, code inside R program can spawn
 the worker nodes.
\end_layout

\end_deeper
\begin_layout Itemize
-hostfile $PBS_NODEFILE means 
\begin_inset Quotes eld
\end_inset

select nodes from available list
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Itemize
After that, the R command follows, just as it was with the single serial
 R job.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{How Do I Know it is using "a cluster?"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This job does almost nothing, except it spawns a set of nodes as a cluster
\end_layout

\begin_layout Standard
and asks each one for a little bit of information
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (!is.loaded("mpi_intitialize")){
\end_layout

\begin_layout Plain Layout

  library(Rmpi)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## see http://math.acadiau.ca/ACMMaC/Rmpi/sample.html
\end_layout

\begin_layout Plain Layout

# Spawn as many slaves as possible 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##mpi.spawn.Rslaves() 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

### Try to spawn worker processes
\end_layout

\begin_layout Plain Layout

mpi.spawn.Rslaves(nslaves=20)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# In case R exits unexpectedly, have it automatically clean up 
\end_layout

\begin_layout Plain Layout

# resources taken up by Rmpi (slaves, memory, etc...) 
\end_layout

\begin_layout Plain Layout

.Last <- function(){ 
\end_layout

\begin_layout Plain Layout

  if (is.loaded("mpi_initialize")){ 
\end_layout

\begin_layout Plain Layout

    if (mpi.comm.size(1) > 0){ 
\end_layout

\begin_layout Plain Layout

      print("Please use mpi.close.Rslaves() to close slaves.") 
\end_layout

\begin_layout Plain Layout

      mpi.close.Rslaves() 
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      print("Please use mpi.quit() to quit R") 
\end_layout

\begin_layout Plain Layout

      .Call("mpi_finalize") 
\end_layout

\begin_layout Plain Layout

    } 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.remote.exec(paste("I am process ",mpi.comm.rank()," / ",mpi.comm.size()))
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To find out more about functions available in Rmpi, read the documentation
 provided with the package or find a more detailed example in hpcexamples
 Ex57-MISimulation-RMPI or Ex80 (which, at least now, uses RMPI directly).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Rmpi function list}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

## output from library(help=Rmpi)
\end_layout

\begin_layout Plain Layout

    Information on package 'Rmpi'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Description:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Package:            Rmpi
\end_layout

\begin_layout Plain Layout

Version:            0.5-9
\end_layout

\begin_layout Plain Layout

Date:               20010-11-30
\end_layout

\begin_layout Plain Layout

Title:              Interface (Wrapper) to MPI (Message-Passing
\end_layout

\begin_layout Plain Layout

                    Interface)
\end_layout

\begin_layout Plain Layout

Author:             Hao Yu
\end_layout

\begin_layout Plain Layout

Maintainer:         Hao Yu <hyu@stats.uwo.ca>
\end_layout

\begin_layout Plain Layout

Depends:            R (>= 2.2.0)
\end_layout

\begin_layout Plain Layout

Suggests:           rsprng, rlecuyer
\end_layout

\begin_layout Plain Layout

Description:        Rmpi provides an interface (wrapper) to MPI APIs.
\end_layout

\begin_layout Plain Layout

                    It also provides interactive R slave environment.
\end_layout

\begin_layout Plain Layout

License:            GPL (>= 2)
\end_layout

\begin_layout Plain Layout

URL:                http://www.stats.uwo.ca/faculty/yu/Rmpi
\end_layout

\begin_layout Plain Layout

Packaged:           2010-11-30 19:38:01 UTC; hyu
\end_layout

\begin_layout Plain Layout

Repository:         CRAN
\end_layout

\begin_layout Plain Layout

Date/Publication:   2010-11-30 19:55:14
\end_layout

\begin_layout Plain Layout

Built:              R 2.15.0; x86_64-redhat-linux-gnu; 2012-05-22
\end_layout

\begin_layout Plain Layout

                    20:35:48 UTC; unix
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Index:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

MPI APIs:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.abort               Abort (quit) all tasks associated with a comm
\end_layout

\begin_layout Plain Layout

mpi.allgather           Gather data from each process to all process
\end_layout

\begin_layout Plain Layout

mpi.allgatherv          Gather diff size data from each process to all process
\end_layout

\begin_layout Plain Layout

mpi.allreduce           Reduce all process's vectors into one vector
\end_layout

\begin_layout Plain Layout

mpi.barrier             Block the caller until all group have called it
\end_layout

\begin_layout Plain Layout

mpi.bcast               Broadcast a vector (int,double,char) to every process
\end_layout

\begin_layout Plain Layout

mpi.cancel              Cancel a nonblocking send or recv
\end_layout

\begin_layout Plain Layout

mpi.cart.coords         Translate a rank to the Cartesian topology coordinate
\end_layout

\begin_layout Plain Layout

mpi.cart.create         Create a Cartesian structure of arbitrary dimension
\end_layout

\begin_layout Plain Layout

mpi.cartdim.get         Get dim information about a Cartesian topology
\end_layout

\begin_layout Plain Layout

mpi.cart.get            Provide the Cartesian topology associated with a comm
\end_layout

\begin_layout Plain Layout

mpi.cart.rank           Translate a Cartesian topology coordinate to the rank
\end_layout

\begin_layout Plain Layout

mpi.cart.shift          Shift Cartesian topology in displacement and direction
\end_layout

\begin_layout Plain Layout

mpi.comm.disconnect     Disconeect and free a comm
\end_layout

\begin_layout Plain Layout

mpi.comm.dup            Duplicate a comm to a new comm
\end_layout

\begin_layout Plain Layout

mpi.comm.free           Free a comm
\end_layout

\begin_layout Plain Layout

mpi.comm.get.parent     Get the parent intercomm
\end_layout

\begin_layout Plain Layout

mpi.comm.rank           Find the rank (process id) of master and slaves
\end_layout

\begin_layout Plain Layout

mpi.comm.remote.size    Find the size of a remote group from an intercomm
\end_layout

\begin_layout Plain Layout

mpi.comm.size           Find the size (total # of master and slaves)
\end_layout

\begin_layout Plain Layout

mpi.comm.set.errhandler Set comm to error return (no crash)
\end_layout

\begin_layout Plain Layout

mpi.comm.spawn          Spawn slaves
\end_layout

\begin_layout Plain Layout

mpi.comm.test.inter     Test if a comm is an intercomm
\end_layout

\begin_layout Plain Layout

mpi.dims.create         Create a Cartesian dim used by mpi.cart.create
\end_layout

\begin_layout Plain Layout

mpi.finalize            Exit MPI environment (call MPI_Finalize())
\end_layout

\begin_layout Plain Layout

mpi.gather              Gather data from each process to a root process
\end_layout

\begin_layout Plain Layout

mpi.gatherv             Gather diff data from each process to a root process
\end_layout

\begin_layout Plain Layout

mpi.get.count           Get the length of a message for given status and type
\end_layout

\begin_layout Plain Layout

mpi.get.processor.name  Get the process (host) name
\end_layout

\begin_layout Plain Layout

mpi.info.create         Create an info object
\end_layout

\begin_layout Plain Layout

mpi.info.free           Free an info object
\end_layout

\begin_layout Plain Layout

mpi.info.get            Get the value from an info object and a key
\end_layout

\begin_layout Plain Layout

mpi.info.set            Set a key/value pair of an info object
\end_layout

\begin_layout Plain Layout

mpi.intercomm.merge     Merge a intercomm to a comm
\end_layout

\begin_layout Plain Layout

mpi.iprobe              Nonblocking use a source and a tag to set status
\end_layout

\begin_layout Plain Layout

mpi.irecv               Nonblocking receive a vector from a specific process
\end_layout

\begin_layout Plain Layout

mpi.isend               Nonblocking send a vector to a specific process
\end_layout

\begin_layout Plain Layout

mpi.probe               Use a source and a tag to set status
\end_layout

\begin_layout Plain Layout

mpi.recv                Receive a vector from a specific process
\end_layout

\begin_layout Plain Layout

mpi.reduce              Reduce all processes's vectors into one (one process)
\end_layout

\begin_layout Plain Layout

mpi.scatter             Opposite of mpi.gather
\end_layout

\begin_layout Plain Layout

mpi.scatterv            Opposite of mpi.gatherv (diff size data)
\end_layout

\begin_layout Plain Layout

mpi.send                Send a vector to a specific process
\end_layout

\begin_layout Plain Layout

mpi.sendrecv            Send & receive different vectors in one call
\end_layout

\begin_layout Plain Layout

mpi.sendrecv.replace    Send & replace a vector in one call
\end_layout

\begin_layout Plain Layout

mpi.test                Test if a nonblocking send/recv request is complete
\end_layout

\begin_layout Plain Layout

mpi.testall             Test if all nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

mpi.testany             Test if any nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

mpi.testsome            Test if some nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

mpi.test.cancelled      Test if a communication is cancelled by mpi.cancel
\end_layout

\begin_layout Plain Layout

mpi.universe.size       Total number of CPUs available
\end_layout

\begin_layout Plain Layout

mpi.wait                Wait if a nonblocking send/recv request is complete
\end_layout

\begin_layout Plain Layout

mpi.waitall             Wait if all nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

mpi.waitany             Wait if any nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

mpi.waitsome            Wait if some nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

******************************************************************************
\end_layout

\begin_layout Plain Layout

MPI Extensions in R Environment:
\end_layout

\begin_layout Plain Layout

lamhosts                Hosts id and machine host name mapping
\end_layout

\begin_layout Plain Layout

mpi.allgather.Robj      Gather any type of objects to every number
\end_layout

\begin_layout Plain Layout

mpi.any.source          A constant for receiving a message from any source
\end_layout

\begin_layout Plain Layout

mpi.any.tag             A constant for receiving a message from any tag
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj          Broadcast an R object to every process
\end_layout

\begin_layout Plain Layout

mpi.comm.maxsize        Find the length of comm array
\end_layout

\begin_layout Plain Layout

mpi.exit                Call MPI_Finalize and detach Rmpi library
\end_layout

\begin_layout Plain Layout

mpi.gather.Robj         Gather any type of object to  a root process
\end_layout

\begin_layout Plain Layout

mpi.get.sourcetag       Get the source and tag for a given status
\end_layout

\begin_layout Plain Layout

mpi.hostinfo            Get the host information that the process is running
\end_layout

\begin_layout Plain Layout

mpi.init.sprng          MPI wrapper to initialize SPRNG in rsprng library
\end_layout

\begin_layout Plain Layout

mpi.is.master           TRUE if it is a master otherwise FALSE (slave)
\end_layout

\begin_layout Plain Layout

mpi.isend.Robj          Nonblocking send an R object to a specific process
\end_layout

\begin_layout Plain Layout

mpi.proc.null           Dummy source and destination
\end_layout

\begin_layout Plain Layout

mpi.quit                Call MPI_Finalize and quit R
\end_layout

\begin_layout Plain Layout

mpi.recv.Robj           Receive an R object from a process (by mpi.send.Robj)
\end_layout

\begin_layout Plain Layout

mpi.realloc.comm        Increase comm array to a new size
\end_layout

\begin_layout Plain Layout

mpi.realloc.request     Increase request array to a new size
\end_layout

\begin_layout Plain Layout

mpi.realloc.status      Increase status array to a new size
\end_layout

\begin_layout Plain Layout

mpi.request.maxsize     Find the length of request array
\end_layout

\begin_layout Plain Layout

mpi.scatter.Robj        Scatter an list to every number
\end_layout

\begin_layout Plain Layout

mpi.send.Robj           Send an R object to a specific process
\end_layout

\begin_layout Plain Layout

mpi.spawn.Rslaves       Spawn R slaves.
 The default R script is slavedaemon.R
\end_layout

\begin_layout Plain Layout

mpi.status.maxsize      Find the length of status array
\end_layout

\begin_layout Plain Layout

mpichosts               finds host names from master Windows registery database
\end_layout

\begin_layout Plain Layout

*****************************************************************************
\end_layout

\begin_layout Plain Layout

MPI Extensions specifically to slavedaemon.R Script (interactive R slaves).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.apply               Scatter an array to slaves and then apply a fun
\end_layout

\begin_layout Plain Layout

mpi.applyLB             Load balancing version of mpi.apply
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave    Master sends an Robj to all slaves
\end_layout

\begin_layout Plain Layout

mpi.bcast.cmd           Broadcast a commond to every process
\end_layout

\begin_layout Plain Layout

mpi.close.Rslaves       Close all slaves launched by mpi.spawn.Rslaves()
\end_layout

\begin_layout Plain Layout

mpi.parApply            (Load balancing) parallel apply
\end_layout

\begin_layout Plain Layout

mpi.parCapply           (Load balancing) parallel column apply
\end_layout

\begin_layout Plain Layout

mpi.parLapply           (Load balancing) parallel lapply
\end_layout

\begin_layout Plain Layout

mpi.parRapply           (Load balancing) parallel row apply
\end_layout

\begin_layout Plain Layout

mpi.parReplicate        A wrapper to mpi.parSapply for repeated eval of an
 expr
\end_layout

\begin_layout Plain Layout

mpi.parSapply           (Load balancing) parallel sapply
\end_layout

\begin_layout Plain Layout

mpi.parSim              (Load balancing) parallel Monte Carlo simulation
\end_layout

\begin_layout Plain Layout

mpi.remote.exec         Run a command remotely on slaves and return
\end_layout

\begin_layout Plain Layout

                        results back to the master
\end_layout

\begin_layout Plain Layout

mpi.setup.rngstream     Setup RNDstream (package rlecuyer) on all slaves
\end_layout

\begin_layout Plain Layout

mpi.setup.sprng         Setup SPRNG (package rsprng) on all slaves
\end_layout

\begin_layout Plain Layout

slave.hostinfo          Show all slave rank, comm, host information
\end_layout

\begin_layout Plain Layout

tailslave.log           Tail (view) last lines of slave log files
\end_layout

\begin_layout Plain Layout

*****************************************************************************
\end_layout

\begin_layout Plain Layout

Some Internal Functions used by Other MPI Functions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bin.nchar               Find the length of a binary string
\end_layout

\begin_layout Plain Layout

mpi.comm.is.null        Test if a comm is NULL (no members)
\end_layout

\begin_layout Plain Layout

string                  Create a string (empty space character) buffer
\end_layout

\begin_layout Plain Layout

****************************************************************************
\end_layout

\begin_layout Plain Layout

Deprecated functions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.parallel.sim        It is renamed to mpi.parSim.
 Still available.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{The Basic Parallel R Problem}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Each node needs to have EVERYTHING it needs to do its job.
\end_layout

\begin_layout Itemize
It is NOT sufficient to simply tell a node to run a function
\end_layout

\begin_layout Itemize
Before that, node must be 
\end_layout

\begin_deeper
\begin_layout Itemize
given required functions and data objects
\end_layout

\begin_layout Itemize
told to do preparatory calculations
\end_layout

\end_deeper
\begin_layout Itemize
If you forget to export a function to the worker nodes, a parallel R program
 will hang indefinitely, without generating an error or output.
 (Hence: be careful)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Rmpi Programming: sending everything out}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Excerpt from Ex80-PrevSci2007], version-3.R
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

## OMIT code to create functions
\end_layout

\begin_layout Plain Layout

## calculateRegressions, createOneTable, createTSPlot, drawSample
\end_layout

\begin_layout Plain Layout

## imposeMissings plotRows, seedlist, conductSimulation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Create a cluster
\end_layout

\begin_layout Plain Layout

library(Rmpi)
\end_layout

\begin_layout Plain Layout

mpi.spawn.Rslaves(nslaves=6)
\end_layout

\begin_layout Plain Layout

## Send functions to each worker node:
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(calculateRegressions)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(createOneTable)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(createTSPlot)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(drawSample)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(imposeMissings)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(imputeDF)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(missingMask)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(plotRows)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(seedlist)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(tablelist)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(conductSimulation)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(dirname)
\end_layout

\begin_layout Plain Layout

mpi.remote.exec(setwd(dirname))
\end_layout

\begin_layout Plain Layout

##forces a random draw that initializes the random generators
\end_layout

\begin_layout Plain Layout

mpi.remote.exec(rnorm(1))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##results <- mpi.parLapply(1:nruns, conductSimulation, ssizes=ssizes,  b0=b0,
 b1=b1, pm=pm, m=m, setseed=NULL)
\end_layout

\begin_layout Plain Layout

results <- mpi.applyLB(1:nruns, conductSimulation, ssizes=ssizes,  b0=b0,
 b1=b1, pm=pm, m=m, setseed=NULL)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

save(results, file=paste("results", jobname,".Rda", sep=""))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## lets just check again, see if they are listening.
\end_layout

\begin_layout Plain Layout

mpi.remote.exec(rnorm(1))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.close.Rslaves()
\end_layout

\begin_layout Plain Layout

mpi.quit()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{SNOW: Simple Network of Workstations}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Pioneered by Luke Tierney, famous statistician U.
 Iowa (my Alma Mater!)
\end_layout

\begin_layout Itemize
SNOW package interface emphasizes CLARITY, attempting to handle fine-grained
 details behind the scenes
\end_layout

\begin_layout Itemize
Highlights: 
\end_layout

\begin_deeper
\begin_layout Itemize
Can spawn clusters of different types, including RMPI (which we use on ACF)
\end_layout

\begin_layout Itemize
Parallel versions of apply and lapply
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Remember R basics: apply, lapply}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
R allows for loops, but discourages their usage for style & efficiency
\end_layout

\begin_layout Itemize
Instead, we use 
\end_layout

\begin_deeper
\begin_layout Description
apply to apply a function to 
\begin_inset Quotes eld
\end_inset

rows
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

columns
\begin_inset Quotes erd
\end_inset

 from a matrix
\end_layout

\begin_layout Description
lapply to apply a function to each separate object in a list
\end_layout

\begin_layout Itemize
practice with those functions! Read my lecture functions-1.
\end_layout

\end_deeper
\begin_layout Itemize
SNOW offers several cluster-capable functions to do the same kind of work.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Snow Documents: ?parLapply}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

snow-parallel               package:snow               R Documentation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Higher Level SNOW Functions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Description:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     Parallel versions of 'apply' and related functions.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Usage:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     parLapply(cl, x, fun, ...)
\end_layout

\begin_layout Plain Layout

     parSapply(cl, X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) 
\end_layout

\begin_layout Plain Layout

     parApply(cl, X, MARGIN, FUN, ...)
\end_layout

\begin_layout Plain Layout

     parRapply(cl, x, fun, ...)
\end_layout

\begin_layout Plain Layout

     parCapply(cl, x, fun, ...)
\end_layout

\begin_layout Plain Layout

     parMM(cl, A, B)
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

Arguments:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      cl: cluster object
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     fun: function or character string naming a function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       X: array to be used
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       x: matrix to be used
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     FUN: function or character string naming a function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  MARGIN: vector specifying the dimensions to use.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

simplify: logical; see 'sapply'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

USE.NAMES: logical; see 'sapply'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     ...: additional arguments to pass to standard function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       A: matrix
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       B: matrix
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Details:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     'parLapply', 'parSapply', and 'parApply' are parallel versions of
\end_layout

\begin_layout Plain Layout

     'lapply', 'sapply', and 'apply'.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     'parRapply' and 'parCapply' are parallel row and column 'apply'
\end_layout

\begin_layout Plain Layout

     functions for a matrix 'x'; they may be slightly more efficient
\end_layout

\begin_layout Plain Layout

     than 'parApply'.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     'parMM' is a very simple(minded) parallel matrix multiply; it is
\end_layout

\begin_layout Plain Layout

     intended as an illustration.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     For more details see <URL:
\end_layout

\begin_layout Plain Layout

     http://www.stat.uiowa.edu/~luke/R/cluster/cluster.html>.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Examples:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     ## Not run:
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

     cl <- makeSOCKcluster(c("localhost","localhost"))
\end_layout

\begin_layout Plain Layout

     parSapply(cl, 1:20, get("+"), 3)
\end_layout

\begin_layout Plain Layout

     ## End(Not run)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Ex60-HelloWorldSnow}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

## snow-hello.R
\end_layout

\begin_layout Plain Layout

### Paul Johnson
\end_layout

\begin_layout Plain Layout

### 2010-03-25
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

### Demonstration of SNOW "Simple Network of Workstations" using MPI
\end_layout

\begin_layout Plain Layout

### "Message Passing Interface" (OpenMPI implementation)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(snow)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

p <- rnorm(123, m=33)
\end_layout

\begin_layout Plain Layout

cl <- makeCluster(18, type="MPI") 
\end_layout

\begin_layout Plain Layout

### sends function to each system
\end_layout

\begin_layout Plain Layout

clusterCall( cl, function() Sys.info()[c("nodename","machine")])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clusterCall( cl, function() rnorm(1, 33,1 ) )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myNorms <- matrix( rnorm(1000), ncol=10 )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## goes column by column
\end_layout

\begin_layout Plain Layout

mypapply <- parApply(cl, myNorms, 2,  print )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

attributes(mypapply)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mypapply <- parApply(cl, myNorms, 2, mean )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mypapply
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myNorms <- matrix( rnorm(1000), ncol=10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mySum <- function( v ){
\end_layout

\begin_layout Plain Layout

    s <-Sys.info()[c("nodename")]
\end_layout

\begin_layout Plain Layout

    ms <- sum(v)
\end_layout

\begin_layout Plain Layout

    list(s, ms)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mypcapply <- parApply(cl, myNorms, 2,  mySum)
\end_layout

\begin_layout Plain Layout

mypcapply
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myNorms <- matrix(rnorm(2500), ncol=25)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myMeans <- function(v){
\end_layout

\begin_layout Plain Layout

  s <- Sys.info()[c("nodename")]
\end_layout

\begin_layout Plain Layout

  ms <- mean(v)
\end_layout

\begin_layout Plain Layout

  list(s, ms)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mypcapply <- parApply(cl, myNorms, 2, myMeans )
\end_layout

\begin_layout Plain Layout

mypcapply
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stopCluster(cl)
\end_layout

\begin_layout Plain Layout

mpi.quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Ex60-HelloWorldSnow Output}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

##
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R version 2.14.1 (2011-12-22)
\end_layout

\begin_layout Plain Layout

Copyright (C) 2011 The R Foundation for Statistical Computing
\end_layout

\begin_layout Plain Layout

ISBN 3-900051-07-0
\end_layout

\begin_layout Plain Layout

Platform: x86_64-redhat-linux-gnu (64-bit)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R is free software and comes with ABSOLUTELY NO WARRANTY.
\end_layout

\begin_layout Plain Layout

You are welcome to redistribute it under certain conditions.
\end_layout

\begin_layout Plain Layout

Type 'license()' or 'licence()' for distribution details.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  Natural language support but running in an English locale
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R is a collaborative project with many contributors.
\end_layout

\begin_layout Plain Layout

Type 'contributors()' for more information and
\end_layout

\begin_layout Plain Layout

'citation()' on how to cite R or R packages in publications.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Type 'demo()' for some demos, 'help()' for on-line help, or
\end_layout

\begin_layout Plain Layout

'help.start()' for an HTML browser interface to help.
\end_layout

\begin_layout Plain Layout

Type 'q()' to quit R.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> ### Paul Johnson
\end_layout

\begin_layout Plain Layout

> ### 2010-03-25
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> ### Demonstration of SNOW "Simple Network of Workstations" using MPI
\end_layout

\begin_layout Plain Layout

> ### "Message Passing Interface" (OpenMPI implementation)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> library(snow)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> p <- rnorm(123, m=33)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> cl <- makeCluster(18, type="MPI") 
\end_layout

\begin_layout Plain Layout

	18 slaves are spawned successfully.
 0 failed.
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> ### sends function to each system
\end_layout

\begin_layout Plain Layout

> clusterCall( cl, function() Sys.info()[c("nodename","machine")])
\end_layout

\begin_layout Plain Layout

[[1]]
\end_layout

\begin_layout Plain Layout

            nodename              machine 
\end_layout

\begin_layout Plain Layout

"compute-2-11.local"             "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]]
\end_layout

\begin_layout Plain Layout

            nodename              machine 
\end_layout

\begin_layout Plain Layout

"compute-2-10.local"             "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-9.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-8.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-7.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-6.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-5.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-4.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-3.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-2.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[11]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-1.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[12]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-0.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[13]]
\end_layout

\begin_layout Plain Layout

            nodename              machine 
\end_layout

\begin_layout Plain Layout

"compute-1-14.local"             "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[14]]
\end_layout

\begin_layout Plain Layout

            nodename              machine 
\end_layout

\begin_layout Plain Layout

"compute-1-13.local"             "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[15]]
\end_layout

\begin_layout Plain Layout

            nodename              machine 
\end_layout

\begin_layout Plain Layout

"compute-1-11.local"             "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[16]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-1-9.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[17]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-1-8.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[18]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-1-7.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> clusterCall( cl, function() rnorm(1, 33,1 ) )
\end_layout

\begin_layout Plain Layout

[[1]]
\end_layout

\begin_layout Plain Layout

[1] 31.80348
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]]
\end_layout

\begin_layout Plain Layout

[1] 31.3416
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]]
\end_layout

\begin_layout Plain Layout

[1] 34.51375
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]]
\end_layout

\begin_layout Plain Layout

[1] 32.44499
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]]
\end_layout

\begin_layout Plain Layout

[1] 34.40459
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]]
\end_layout

\begin_layout Plain Layout

[1] 34.40721
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]]
\end_layout

\begin_layout Plain Layout

[1] 32.79563
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]]
\end_layout

\begin_layout Plain Layout

[1] 32.58481
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]]
\end_layout

\begin_layout Plain Layout

[1] 34.21046
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]]
\end_layout

\begin_layout Plain Layout

[1] 33.47829
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[11]]
\end_layout

\begin_layout Plain Layout

[1] 31.11419
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[12]]
\end_layout

\begin_layout Plain Layout

[1] 33.2634
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[13]]
\end_layout

\begin_layout Plain Layout

[1] 32.41902
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[14]]
\end_layout

\begin_layout Plain Layout

[1] 34.09947
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[15]]
\end_layout

\begin_layout Plain Layout

[1] 31.72768
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[16]]
\end_layout

\begin_layout Plain Layout

[1] 33.12429
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[17]]
\end_layout

\begin_layout Plain Layout

[1] 31.78337
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[18]]
\end_layout

\begin_layout Plain Layout

[1] 33.91641
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> myNorms <- matrix( rnorm(1000), ncol=10 )
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> ## goes column by column
\end_layout

\begin_layout Plain Layout

> mypapply <- parApply(cl, myNorms, 2,  print )
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> attributes(mypapply)
\end_layout

\begin_layout Plain Layout

$dim
\end_layout

\begin_layout Plain Layout

[1] 100  10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypapply <- parApply(cl, myNorms, 2, mean )
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypapply
\end_layout

\begin_layout Plain Layout

 [1] -0.13995753 -0.14750300  0.13525781  0.05435524 -0.03935838 -0.07484654
\end_layout

\begin_layout Plain Layout

 [7] -0.05063702 -0.01128428  0.01850835  0.10469531
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> myNorms <- matrix( rnorm(1000), ncol=10)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mySum <- function( v ){
\end_layout

\begin_layout Plain Layout

+     s <-Sys.info()[c("nodename")]
\end_layout

\begin_layout Plain Layout

+     ms <- sum(v)
\end_layout

\begin_layout Plain Layout

+     list(s, ms)
\end_layout

\begin_layout Plain Layout

+ }
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypcapply <- parApply(cl, myNorms, 2,  mySum)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypcapply
\end_layout

\begin_layout Plain Layout

[[1]]
\end_layout

\begin_layout Plain Layout

[[1]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-11.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[1]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -13.98086
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]]
\end_layout

\begin_layout Plain Layout

[[2]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-9.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 4.479569
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]]
\end_layout

\begin_layout Plain Layout

[[3]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-7.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 4.559974
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]]
\end_layout

\begin_layout Plain Layout

[[4]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-5.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 1.676203
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]]
\end_layout

\begin_layout Plain Layout

[[5]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-3.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -13.94175
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]]
\end_layout

\begin_layout Plain Layout

[[6]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-2.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -9.71347
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]]
\end_layout

\begin_layout Plain Layout

[[7]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-0.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -12.83219
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]]
\end_layout

\begin_layout Plain Layout

[[8]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-13.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -10.63648
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]]
\end_layout

\begin_layout Plain Layout

[[9]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-9.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -12.83259
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]]
\end_layout

\begin_layout Plain Layout

[[10]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-7.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -14.8644
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> myNorms <- matrix(rnorm(2500), ncol=25)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> myMeans <- function(v){
\end_layout

\begin_layout Plain Layout

+   s <- Sys.info()[c("nodename")]
\end_layout

\begin_layout Plain Layout

+   ms <- mean(v)
\end_layout

\begin_layout Plain Layout

+   list(s, ms)
\end_layout

\begin_layout Plain Layout

+ }
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypcapply <- parApply(cl, myNorms, 2, myMeans )
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypcapply
\end_layout

\begin_layout Plain Layout

[[1]]
\end_layout

\begin_layout Plain Layout

[[1]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-11.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[1]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.05501698
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]]
\end_layout

\begin_layout Plain Layout

[[2]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-11.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.0557545
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]]
\end_layout

\begin_layout Plain Layout

[[3]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-10.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.1918846
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]]
\end_layout

\begin_layout Plain Layout

[[4]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-9.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.06132683
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]]
\end_layout

\begin_layout Plain Layout

[[5]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-8.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.1230541
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]]
\end_layout

\begin_layout Plain Layout

[[6]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-8.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.05540265
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]]
\end_layout

\begin_layout Plain Layout

[[7]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-7.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.09544129
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]]
\end_layout

\begin_layout Plain Layout

[[8]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-6.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.02780365
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]]
\end_layout

\begin_layout Plain Layout

[[9]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-5.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.1017519
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]]
\end_layout

\begin_layout Plain Layout

[[10]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-5.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.137849
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[11]]
\end_layout

\begin_layout Plain Layout

[[11]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-4.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[11]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.05403865
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[12]]
\end_layout

\begin_layout Plain Layout

[[12]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-3.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[12]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.02347465
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[13]]
\end_layout

\begin_layout Plain Layout

[[13]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-3.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[13]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.2821554
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[14]]
\end_layout

\begin_layout Plain Layout

[[14]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-2.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[14]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.04790076
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[15]]
\end_layout

\begin_layout Plain Layout

[[15]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-1.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[15]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.02619804
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[16]]
\end_layout

\begin_layout Plain Layout

[[16]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-0.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[16]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.006781886
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[17]]
\end_layout

\begin_layout Plain Layout

[[17]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-0.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[17]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.2478439
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[18]]
\end_layout

\begin_layout Plain Layout

[[18]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-14.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[18]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.08368503
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[19]]
\end_layout

\begin_layout Plain Layout

[[19]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-13.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[19]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.005240985
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[20]]
\end_layout

\begin_layout Plain Layout

[[20]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-11.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[20]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.06549931
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[21]]
\end_layout

\begin_layout Plain Layout

[[21]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-11.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[21]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.01406486
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[22]]
\end_layout

\begin_layout Plain Layout

[[22]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-9.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[22]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.02487288
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[23]]
\end_layout

\begin_layout Plain Layout

[[23]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-8.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[23]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.001714545
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[24]]
\end_layout

\begin_layout Plain Layout

[[24]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-7.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[24]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.002100271
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[25]]
\end_layout

\begin_layout Plain Layout

[[25]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-7.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[25]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.001404288
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> stopCluster(cl)
\end_layout

\begin_layout Plain Layout

[1] 1
\end_layout

\begin_layout Plain Layout

> mpi.quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{R parallel package}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
R parallel incorporates SNOW concepts and functions
\end_layout

\begin_layout Standard
Because parallel is in the R distribution, it should be considered a top-priorit
y learning objective
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Will Worry about Replication of Random Streams In Next Lecture}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each of the parallel packages has its own idioms to set the random number
 seed on the separate nodes.
\end_layout

\begin_layout Standard
So far, these packages aim at replication of a complete batch of simulations
 across a lot of compute nodes.
\end_layout

\begin_layout Standard
I will need to explain L'Ecuyer 
\begin_inset Quotes eld
\end_inset

many separate streams
\begin_inset Quotes erd
\end_inset

 and the SPRNG approaches, along with ways to replicate them.
\end_layout

\begin_layout Standard
My suggestion is 
\begin_inset Quotes eld
\end_inset

Portable Parallel Seeds
\begin_inset Quotes erd
\end_inset

 in Ex81.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
