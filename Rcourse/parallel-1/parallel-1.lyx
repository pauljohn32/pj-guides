#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass beamer
\begin_preamble

\usepackage{dcolumn}
\usepackage{booktabs}

% use 'handout' to produce handouts
%\documentclass[handout]{beamer}
\usepackage{wasysym}
\usepackage{pgfpages}
\newcommand{\vn}[1]{\mbox{{\it #1}}}\newcommand{\vb}{\vspace{\baselineskip}}\newcommand{\vh}{\vspace{.5\baselineskip}}\newcommand{\vf}{\vspace{\fill}}\newcommand{\splus}{\textsf{S-PLUS}}\newcommand{\R}{\textsf{R}}


\usepackage{graphicx}
\usepackage{listings}

\mode<presentation>
{
  \usetheme{Antibes}
}

\usepackage{fancyvrb}
% In document Latex options:
\fvset{listparameters={\setlength{\topsep}{0em}}}
\def\Sweavesize{\normalsize} 
\def\Rcolor{\color{black}} 
\def\Rbackground{\color[gray]{0.95}}



\providecommand{\Rcolor}{\color[rgb]{0, 0.5, 0.5}}
\providecommand{\Routcolor}{\color[rgb]{0.461, 0.039, 0.102}}
\providecommand{\Rcommentcolor}{\color[rgb]{0.101, 0.043, 0.432}}

\providecommand{\Rbackground}{\color[gray]{0.95}}
\providecommand{\Routbackground}{\color[gray]{0.80}}
% Can specify \color[gray]{1} for white background or just \color{white}


\lstdefinestyle{Rstyle}{fancyvrb=false,escapechar=`,language=R,%
                        basicstyle={\Rcolor\footnotesize},%
                        backgroundcolor=\Rbackground,%
           tabsize=2,%
                        showstringspaces=false,%
                        keywordstyle=\Rcolor,%
                        commentstyle={\Rcommentcolor\ttfamily\itshape},%
                        literate={<-}{{$\leftarrow$}}2{<<-}{{$\twoheadleftarrow$}}2{~}{{$\sim$}}1{<=}{{$\leq$}}2{>=}{{$\geq$}}2{^}{{$^{\scriptstyle\wedge}$}}1,%
                        alsoother={$},%
                        alsoletter={.<-},%
                        otherkeywords={!,!=,~,$,*,\&,\%/\%,\%*\%,\%\%,<-,<<-,/},%
                        escapeinside={(*}{*)}}%
% Other options of interest:
% frame=single,framerule=0.1pt,framesep=1pt,rulecolor=\color{blue},
% numbers=left,numberstyle=\tiny,stepnumber=1,numbersep=7pt,
% keywordstyle={\bf\Rcolor}

\lstdefinestyle{Routstyle}{fancyvrb=false,literate={~}{{$\sim$}}1{R^2}{{$R^{2}$}}2{^}{{$^{\scriptstyle\wedge}$}}1{R-squared}{{$R^{2}$}}2,%
 frame=single,framerule=0.2pt,framesep=1pt,basicstyle=\Routcolor\Sweavesize,%
 backgroundcolor=\Routbackground}


\lstnewenvironment{Sinput}{\lstset{style=Rstyle}}{}
\lstnewenvironment{Scode}{\lstset{style=Rstyle}}{}
\lstnewenvironment{Soutput}{\lstset{style=Routstyle}}{}

\lstset{tabsize=2,basicstyle=\footnotesize, breaklines=true,style=Rstyle}
%\usetheme{Warsaw}
% or ...

%\setbeamercovered{transparent}
% or whatever (possibly just delete it)


%%not for article, but for presentation
\mode<presentation>
%\newcommand\makebeamertitle{\frame{\maketitle}}

\setbeamertemplate{frametitle continuation}[from second]
\renewcommand\insertcontinuationtext{...}


\expandafter\def\expandafter\insertshorttitle\expandafter{%
 \insertshorttitle\hfill\insertframenumber\,/\,\inserttotalframenumber}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Parallel Computing with R
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Parallel
\end_layout

\end_inset


\end_layout

\begin_layout Author
Paul E.
 Johnson
\begin_inset Flex InstituteMark
status open

\begin_layout Plain Layout
1
\end_layout

\end_inset

 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\begin_layout Institute
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
1
\end_layout

\end_inset

Department of Political Science
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 
\begin_inset Flex InstituteMark
status collapsed

\begin_layout Plain Layout
2
\end_layout

\end_inset

Center for Research Methods and Data Analysis, University of Kansas
\begin_inset Argument 1
status open

\begin_layout Plain Layout
K.U.
\end_layout

\end_inset


\end_layout

\begin_layout Date
2017
\begin_inset Argument 1
status open

\begin_layout Plain Layout
2017
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The following causes the table of contents to be shown at the beginning
 of every subsection.
 Delete this, if you do not want it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
AtBeginSection[]{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
frame<beamer>{ 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
frametitle{Outline}   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
tableofcontents[currentsection,currentsubsection] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frametitle{Outline}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Bookmark: crmda.ku.edu/computing
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
crmda.ku.edu/computing
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
That's the official reference for HOW TO use the cluster and its systems.
\end_layout

\begin_layout Itemize
If you want to know how to do something, please refer to that material first
 before asking Google how its done at the University of Alabama
\end_layout

\begin_layout Itemize
When uncertain, please review examples in hpcexamples.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Cluster management now in CRC}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Center for Research Computing
\end_layout

\begin_layout Itemize
Jargon changes.
 Login name changes.
 Procedural changes
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://crc.ku.edu/hpc/how-to
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
I don't understand everything there, our blog has updates:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.crmda.dept.ku.edu/timeline
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
ACF
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
What is a 
\begin_inset Quotes eld
\end_inset

cluster
\begin_inset Quotes erd
\end_inset

?
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Cluster: lots of separate workstations (
\begin_inset Quotes eld
\end_inset

nodes
\begin_inset Quotes erd
\end_inset

) that are networked together.
\end_layout

\begin_layout Standard
Racks and racks of compute nodes
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rack 0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rack 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rack 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-0-0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-1-0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-2-0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-0-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-1-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-2-1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-0-2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-1-2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-2-2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\vdots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-0-19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-1-19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
compute-2-19
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

compute nodes
\begin_inset Quotes erd
\end_inset

 are separate Linux systems where the computations take place.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The login node
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
hpc.crc.ku.edu
\end_layout

\end_inset

: where you log in, in order to gain access.
 
\end_layout

\begin_layout Standard
Will redirect you to either
\end_layout

\begin_layout Enumerate
submit1.hpc.crc.ku.edu
\end_layout

\begin_layout Enumerate
submit2.hpc.crc.ku.edu
\end_layout

\begin_deeper
\begin_layout Standard
Can login directly to either one.
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The login node
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Description
RULE
\begin_inset space ~
\end_inset

1.
 Do not do 
\begin_inset Quotes eld
\end_inset

computing
\begin_inset Quotes erd
\end_inset

 on login nodes
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Itemize
Software is missing there
\end_layout

\begin_deeper
\begin_layout Itemize
admins will kill intensive jobs
\end_layout

\begin_layout Itemize
programs are installed in the compute nodes
\end_layout

\end_deeper
\begin_layout Standard
Login nodes on ACF: is a place to
\end_layout

\begin_layout Itemize
begin 
\begin_inset Quotes eld
\end_inset

interactive
\begin_inset Quotes erd
\end_inset

 sessions (the 
\begin_inset Quotes eld
\end_inset

interactive
\begin_inset Quotes erd
\end_inset

 que).
\end_layout

\begin_layout Itemize
submit and monitor longer running jobs (the 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 que).
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
node and processor
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Users ask for resources from the cluster, referring to nodes and processor
 per node
\end_layout

\begin_layout Description
node: one of those separate computer systems
\end_layout

\begin_layout Description
ppn: processor per node (2017: most systems have 20 CPUs per node, some
 have more
\end_layout

\begin_layout Standard
Expect RAM 2GB per processor.
\end_layout

\begin_layout Standard
If you ask for nodes=8:ppn=1 the scheduler may assign your 8 jobs to ONE
 compute node.
\end_layout

\begin_layout Standard
If you ask for nodes=1:ppn=8, you are safer
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Interactive que}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This is just like 
\begin_inset Quotes eld
\end_inset

logging into
\begin_inset Quotes erd
\end_inset

 a remote workstation, such as compute-1-1.
 It is used for 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
developing code
\end_layout

\begin_layout Itemize
testing programs
\end_layout

\end_deeper
\begin_layout Itemize
HOWTO? From submit2.hpc.crc.ku.edu, run this command:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ msub -I -q interactive -l nodes=1:ppn=1
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

shortcut
\begin_inset Quotes erd
\end_inset

 we created for that is 
\series bold
qlogin
\end_layout

\begin_layout Itemize
That asks for permission to have a 
\begin_inset Quotes eld
\end_inset

login
\begin_inset Quotes erd
\end_inset

 session with one compute node with 1 processor in that node.
\end_layout

\end_deeper
\begin_layout Itemize
To request an interactive session with more nodes, adjust the values accordingly.
\end_layout

\begin_layout Itemize
This does NOT ask for X11 
\begin_inset Quotes eld
\end_inset

graphic forwarding
\begin_inset Quotes erd
\end_inset

, will be a strictly TEXT session (CLI)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{X-server Allowed}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If you have an X-server running, or are in NoMachine, add a -X in the command:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ msub -I -X -q interactive -l nodes=1:ppn=1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
qxlogin does similar
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ cat /usr/local/bin/qxlogin
\end_layout

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

ARGS=$@
\end_layout

\begin_layout Plain Layout

/opt/moab/bin/msub -X -I -lnodes=1:ppn=1 $ARGS
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
If your PC has an X11 server running, graphics display as sent out from
 compute node, through the login node, into your PC
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Shortcuts to Interactive Sessions}
\end_layout

\end_inset


\end_layout

\begin_layout Description
Repeat: Shortcut programs to launch interactive sessions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ qlogin
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or, for X11 enabled sessions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ qxlogin
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If more nodes or PPN are required, options are allowed:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ msub -I -X -q interactive -l nodes=2:ppn=2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Would request 2 nodes with 2 ppn.
\end_layout

\begin_layout Itemize
While testing some cluster programs, I DO run interactive multi-node sessions.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
The Queues
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Two queues to consider
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

crmda
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

sixhour
\begin_inset Quotes erd
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

crmda
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
jobs stay within nodes we own
\end_layout

\begin_layout Itemize
can run indefinitely
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

sixhour
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Itemize
time limit
\end_layout

\begin_layout Itemize
access to all available nodes in community cluster
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{To run a long running job}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
User must prepare 2 things.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
A 
\begin_inset Quotes eld
\end_inset

submission script
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
A program
\end_layout

\end_deeper
\begin_layout Itemize
Run the 
\begin_inset Quotes eld
\end_inset

msub
\begin_inset Quotes erd
\end_inset

 program on the SCRIPT!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Submission Script}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Most submission scripts have 
\begin_inset Quotes eld
\end_inset

boiler plate
\begin_inset Quotes erd
\end_inset

 at the top
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\scriptsize},numbers=left"
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#MSUB -M your-name_here@ku.edu
\end_layout

\begin_layout Plain Layout

#MSUB -N RParallelHelloWorld
\end_layout

\begin_layout Plain Layout

#MSUB -q sixhour
\end_layout

\begin_layout Plain Layout

#MSUB -l nodes=1:ppn=11:ib
\end_layout

\begin_layout Plain Layout

#MSUB -l walltime=00:05:00
\end_layout

\begin_layout Plain Layout

#MSUB -m bea
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cd $PBS_O_WORKDIR
\end_layout

\begin_layout Plain Layout

mpiexec -n 1 R --vanilla -f parallel-hello.R
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Boiler Plate Submission Script}
\end_layout

\end_inset


\end_layout

\begin_layout Description
-N the name of the job–you choose that as a reminder for yourself
\end_layout

\begin_layout Description
-l
\begin_inset space ~
\end_inset

nodes= resource request.
 CAN be more elaborate, specifying memory and other restrictions
\end_layout

\begin_layout Description
-l
\begin_inset space ~
\end_inset

walltime maximum time job can run before it is killed by OS
\end_layout

\begin_layout Description
-M YOUR email address.
 If you see 
\begin_inset Quotes eld
\end_inset

pauljohn@ku.edu
\begin_inset Quotes erd
\end_inset

, please change it
\end_layout

\begin_layout Description
-m bea send email to YOUR email address when job begins, ends, or crashes.
\end_layout

\begin_layout Description
-q The queue in which your job will run.
 There is no 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 queue anymore!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{qstat}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Review the jobs that are running
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$ qstat
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
function from old queue that still works
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ showq
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
grep through output to find your name
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline true
status open

\begin_layout Plain Layout

$ qstat | grep your-name-here
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
ACF also has a Web accessible program 
\begin_inset Quotes eld
\end_inset

ganglia
\begin_inset Quotes erd
\end_inset

 that can be used to survey running programs.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://ganglia.acf.ku.edu
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Network File System
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
We CAN write on /tmp inside each node's hard disk
\end_layout

\begin_layout Itemize
/home/username and $WORK {/panfs/pfs.local/work/crmda/your_name_here} are
 Network File System shares, they are links that point to a network storage
 device.
\end_layout

\begin_layout Itemize
Warning: reading and writing lots of small files in the NFS is SLOW, and
 if your project requires lots and lots of writing, it is worthwhile to
 learn how to read & write in /tmp and copy results into /home when needed.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Complication: Infiniband vs Ethernet}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If the compute cluster has some nodes witht 
\begin_inset Quotes eld
\end_inset

infiniband
\begin_inset Quotes erd
\end_inset

 and some without, we have a problem
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Infiniband: super-fast communication system called Infiniband 
\end_layout

\begin_layout Itemize
Ethernet: boring ordinary 1GB ethernet cables
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Infiniband Workaround}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

ib
\begin_inset Quotes erd
\end_inset

 option in submission scripts.
 
\end_layout

\begin_layout Itemize
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

#PBS -l nodes=11:ppn=1:ib
\end_layout

\end_inset


\end_layout

\begin_layout Standard
will confine the nodes to be selected from the infiniband systems.
\end_layout

\begin_layout Itemize
This is only necessary with programs that use the MPI, the Message Passing
 Interface.
\end_layout

\begin_layout Itemize
It is not necessary for running jobs that simply launch one instance or
 Mplus, SAS, or R.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Run One Program
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Please Walk Before You Run (lots of jobs)}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Before you get fancy and try to run a job on 20 nodes at once
\end_layout

\begin_layout Itemize
Make sure it runs well on one node!
\end_layout

\begin_layout Itemize
This is necessary! 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
check your memory usage.
 
\end_layout

\begin_layout Itemize
make sure your program is efficient
\end_layout

\begin_layout Itemize
possible to profile 1 program on 1 node (not possible to profile a parallel
 run)
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{hpcexample Ex50: R example}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Some Windows or Mac users have never 
\begin_inset Quotes eld
\end_inset

run
\begin_inset Quotes erd
\end_inset

 a program, so try that now.
\end_layout

\begin_layout Itemize
Get your R program that works, say myCoolProgram.R.
 Be sure it writes output, such as a pdf, and saves some data output or
 a fitted model in a file.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Copy it to hpc.crc.ku.edu.
 
\end_layout

\begin_layout Enumerate
Put it in a subdirectory.
 
\end_layout

\begin_layout Enumerate
Log into an interactive session.
 
\end_layout

\begin_layout Enumerate
Change into the subdirectory where you wrote the R program.
 
\end_layout

\begin_layout Enumerate
Run the program.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{How to run R from the command line?}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
There are many ways to run an R program, such as the traditional method:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

R < myCoolProgram.R &
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
but generally I like this style better (does same):
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

R -f myCoolProgram.R &
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
At one time, I was very eager to use Rscript instead, but I don't see much
 difference now.
 Warning: some people are emphatic about Rscript or littler.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Monitor a long running job}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Start a few xterms from the same compute node.
\end_layout

\begin_layout Itemize
On one terminal, monitor CPU and memory
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ top
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
In another terminal, run the R program.
\end_layout

\begin_layout Itemize
On another terminal, run something like this to get a different view
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ ps -aux | grep R 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Prepare for Parallel: Be Cautious about R's environment}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Ever notice R reads your 
\begin_inset Quotes eld
\end_inset

saved session
\begin_inset Quotes erd
\end_inset

 and always wants to save a workspace when you close?
\end_layout

\begin_layout Itemize
Some people like that, but in the cluster YOU MUST NOT DEPEND on saved session
 files (.RData) to make your program work.
\end_layout

\begin_layout Itemize
So add command line options like 
\begin_inset Quotes eld
\end_inset

–no-restore-data
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

–no-save
\begin_inset Quotes erd
\end_inset

, or get all of the options with –vanilla.
 So test your program again like this:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ R --vanilla  -f myCoolProgram.R &
\end_layout

\end_inset


\end_layout

\begin_layout Standard
—vanilla combines –no-save, –no-restore, –no-site-file, –no-init-file and
 –no-environ
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{How to schedule same R program on the default que}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Running interactively is FINE, it is just same as submitting a job on the
 que so that it can be sent to a compute node
\end_layout

\begin_layout Itemize
But, if it is a long-running job, it is necessary for you to 
\begin_inset Quotes eld
\end_inset

keep the terminal open
\begin_inset Quotes erd
\end_inset

 for a long time.
\end_layout

\begin_layout Itemize
Instead, schedule the job in the cluster, let the job go into the batch
 que.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Submission Script in Ex50 from hpcexamples}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The submission script was shown above.
 See the file 
\begin_inset Quotes eld
\end_inset

sub-serial.sh
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small},numbers=left"
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#MSUB -M your-name-here@ku.edu
\end_layout

\begin_layout Plain Layout

#MSUB -N Rsimple 
\end_layout

\begin_layout Plain Layout

#MSUB -l nodes=1:ppn=1:ib
\end_layout

\begin_layout Plain Layout

#MSUB -l walltime=00:10:00
\end_layout

\begin_layout Plain Layout

#MSUB -m bea
\end_layout

\begin_layout Plain Layout

#MSUB -q crmda
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Your queue need not be "crmda".
 Could be
\end_layout

\begin_layout Plain Layout

## "sixhour" instead.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cd $PBS_O_WORKDIR
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Please check your ~/.bash_profile to make sure
\end_layout

\begin_layout Plain Layout

## the correct modules will be loaded with new shells.
\end_layout

\begin_layout Plain Layout

## See discussion:
\end_layout

\begin_layout Plain Layout

## http://www.crmda.dept.ku.edu/timeline/archives/184
\end_layout

\begin_layout Plain Layout

## It is not helpful or necessary to insert module
\end_layout

\begin_layout Plain Layout

## commands here (contrary to previous advice).
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

R --vanilla -f r-serial.R
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Note previous does not use mpiexec, orterun, or mpirun, because
\end_layout

\begin_layout Plain Layout

## it is not using the message passing interface.
 It is one simple
\end_layout

\begin_layout Plain Layout

## R program, in isolation.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Run Ex50.
 r-serial.R is a very small example program}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Go to hpc.crc.ku.edu
\end_layout

\begin_layout Itemize
Go to compute node (interactive login)
\end_layout

\begin_layout Itemize
Make sure your GIT copy of hpcexample is up to date
\end_layout

\begin_layout Itemize
cd to Ex50, revise sub-serial.sh to fit your needs
\end_layout

\begin_layout Itemize
May need to exit back to login node to submit (maybe not!)
\end_layout

\begin_layout Itemize
Submit the job
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ msub sub-serial.sh
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[allowframebreaks, containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Your result files}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The R program generates several output files.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This job creates a PDF image of a graph
\end_layout

\end_deeper
\begin_layout Itemize
The cluster also creates 2 files, an 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 file and an 
\begin_inset Quotes eld
\end_inset

o
\begin_inset Quotes erd
\end_inset

 file
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

o
\begin_inset Quotes erd
\end_inset

 standard output, the messages that would have gone to terminal if you ran
 R from CLI
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 standard error, which also would have gone to terminal.
\end_layout

\end_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

o
\begin_inset Quotes erd
\end_inset

 files will have the name you declared in your submission script (-N) and
 the job number in the cluster.
\end_layout

\begin_layout Itemize
For testing, I ran that job 2012-10-22.
\end_layout

\begin_layout Itemize
Rsimple.o517451 looks just like an ordinary R output in the terminal:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small}"
inline false
status open

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

R version 3.3.2 (2016-10-31) -- "Sincere Pumpkin Patch"
\end_layout

\begin_layout Plain Layout

Copyright (C) 2016 The R Foundation for Statistical Computing
\end_layout

\begin_layout Plain Layout

Platform: x86_64-pc-linux-gnu (64-bit)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R is free software and comes with ABSOLUTELY NO WARRANTY.
\end_layout

\begin_layout Plain Layout

You are welcome to redistribute it under certain conditions.
\end_layout

\begin_layout Plain Layout

Type 'license()' or 'licence()' for distribution details.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R is a collaborative project with many contributors.
\end_layout

\begin_layout Plain Layout

Type 'contributors()' for more information and
\end_layout

\begin_layout Plain Layout

'citation()' on how to cite R or R packages in publications.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Type 'demo()' for some demos, 'help()' for on-line help, or
\end_layout

\begin_layout Plain Layout

'help.start()' for an HTML browser interface to help.
\end_layout

\begin_layout Plain Layout

Type 'q()' to quit R.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> ## Paul Johnson
\end_layout

\begin_layout Plain Layout

> ## The second stupidest R program ever.
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> x <- rnorm(1000, mean = 17, sd = 43)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mean(x)
\end_layout

\begin_layout Plain Layout

[1] 14.26859
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> pdf("testGraph.pdf", height = 6, width = 6, onefile = F, family = "Times")
\end_layout

\begin_layout Plain Layout

> hist(x, main = "One Stupid Histogram")
\end_layout

\begin_layout Plain Layout

> dev.off()
\end_layout

\begin_layout Plain Layout

null device 
\end_layout

\begin_layout Plain Layout

          1 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
And the 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 file Rsimple.e517451 is a big empty NOTHING, meaning no problem at all!
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.
    
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Remember, the 
\begin_inset Quotes eld
\end_inset

e
\begin_inset Quotes erd
\end_inset

 file is reporting the standard error output from the SHELL, not R error
 messages.
 R errors still show up in Rsimple.o517451.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{View System Usage in a Longer-Running Program}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
HPC will email you when the job starts if you had 
\begin_inset Quotes eld
\end_inset

b
\begin_inset Quotes erd
\end_inset

 in 
\begin_inset Quotes eld
\end_inset

bea
\begin_inset Quotes erd
\end_inset

.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
it will tell you which node is running your job (ex, n499).
\end_layout

\end_deeper
\begin_layout Itemize
If the job is running for a while, you can go track its memory usage
\end_layout

\begin_deeper
\begin_layout Itemize
SSH to login node, 
\end_layout

\begin_layout Itemize
request an interactive session in any node
\end_layout

\begin_layout Itemize
Then 
\begin_inset Quotes eld
\end_inset

ssh n499
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
HPC DOES NOT allow ssh direct to n499.
 
\end_layout

\begin_layout Itemize
Also possible to access via the interactive que:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ msub -I -l nodes=compute-0-0
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
In the shell, run programs like 
\begin_inset Quotes eld
\end_inset

top
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ps
\begin_inset Quotes erd
\end_inset

 to view memory usage of your program.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Many Serial R Programs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{"Poor Person's" Parallel Computing}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Need to run a program 1000 times, with different 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
random number seeds, or
\end_layout

\begin_layout Itemize
parameters
\end_layout

\end_deeper
\begin_layout Itemize
Strategy.
 Write one program that accepts command-line arguments
\end_layout

\begin_layout Itemize
Write 1000 submission scripts, 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
adjust the submision scripts to provide slightly different arguments for
 each run
\end_layout

\end_deeper
\begin_layout Itemize
hpcexamples Ex51-ManySerialJobs demonstrate this.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Command Line Arguments}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
All programs worth using allow command line arguments.
 (no need to recompile or edit program, just run with different arguments!)
\end_layout

\begin_layout Itemize
Suppose, for example, we want to re-set the run number and the random seed.
 
\end_layout

\begin_layout Itemize
Re-write the R code to scan the command line arguments and do the right
 thing, so we can run:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

R --vanilla -f r-commandline.R --args run="010" seed="12345"
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
The R function commandArgs() can be used to receive command line arguments.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Ex51: command line arguments}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
User has responsibility to 
\begin_inset Quotes eld
\end_inset

parse
\begin_inset Quotes erd
\end_inset

 those arguments and put them to use.
\end_layout

\begin_layout Itemize
The example program r-commandline.R demonstrates.
 Please read r-commandline.R.
 
\end_layout

\begin_layout Itemize
Examples:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

$ R -f r-commandline.R --args myMeanN=88.1231 runI=11 whateverC="hell" nofcasesI=2
323
\end_layout

\begin_layout Plain Layout

$ R -f r-commandline.R --args myMeanN=77.1231 runI=12 whateverC="hell" nofcasesI=1
121
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
That will generate pdf and R data files in the current working directory
 (because outdirC was not specified).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Ex51 README}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Its a very thorough README file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{This assumes program accepts command line arguments}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Some programs are stupid, do not have way to receive command line options
 inside a program.
\end_layout

\begin_layout Itemize
In these cases, such as with Mplus, it is necessary to revise our plan.
 The script that creates the submission scripts must also write 1000 mplus
 programs.
\end_layout

\begin_layout Itemize
For an example of that, see hpcexamples Ex08-MplusRunall-1, Ex09-MplusRunall-2
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Shortcomings}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Does not guarantee that random number streams do not 
\begin_inset Quotes eld
\end_inset

overlap
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Makes integration of results across all simulations more difficult
\end_layout

\begin_layout Standard
But the benefit of this approach is plain.
 If you can write one R program, you can easily script it to run over and
 over again.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Job Array more Rigorous Version of Same}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
hpcexamples 52
\end_layout

\begin_deeper
\begin_layout Standard
Ex52-R-JobArray
\end_layout

\end_deeper
\begin_layout Itemize
A Job Array is a way to submit a lot of separate R jobs without frustrating
 yourself too much.
\end_layout

\begin_layout Itemize
README and example was thoroughly re-worked in 2017.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Multi-Core
\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Multicore
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Shared memory
\begin_inset Quotes erd
\end_inset

 computing: the RAM in a machine is shared among several cores
\end_layout

\begin_layout Itemize
Special math and computation algorithms may be able to divide work among
 cores to speed things up.
\end_layout

\begin_layout Itemize
R parallel package (introduced with R-2.14 formalized the plan for multi-core
 support in the 
\begin_inset Quotes eld
\end_inset

parallel
\begin_inset Quotes erd
\end_inset

 package).
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
See the function 
\begin_inset Quotes eld
\end_inset

mclapply
\begin_inset Quotes erd
\end_inset

 to automatically divide work on list elements among cores
\end_layout

\end_deeper
\begin_layout Itemize
I used recently in speeding up report generation in one project
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator parbreak
\end_inset


\end_layout

\begin_layout Frame
\begin_inset Argument 4
status open

\begin_layout Plain Layout
Be Cautious
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Not available on Windows
\end_layout

\begin_layout Itemize
It CONFLICTS with the MPI framework that I have used more often.
\end_layout

\begin_layout Itemize
Will go BERSERK if you run it with browser() in your R code, will not allow
 debug.
\end_layout

\begin_layout Itemize
If you use this, try to learn about the ways that we can tell R how many
 cores to use.
\end_layout

\begin_layout Itemize
multicore work does not always go faster, because work of dividing up a
 job causes 
\begin_inset Quotes eld
\end_inset

overhead
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_deeper
\begin_layout Section
snow Fork Cluster as Middle Ground
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Practice on your own computer}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Don't use 
\begin_inset Quotes eld
\end_inset

multicore
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Do use your cores as if they were separate computers
\end_layout

\begin_layout Itemize
R parallel packages allow you to create a 
\begin_inset Quotes eld
\end_inset

sock
\begin_inset Quotes erd
\end_inset

 cluster using parallel idioms that are same as will be used in cluster
\end_layout

\begin_layout Itemize
See hpcexample Ex67-SOCK-Cluster
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Create a Sock Cluster}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This creates a cluster of 4 
\begin_inset Quotes eld
\end_inset

fake nodes
\begin_inset Quotes erd
\end_inset

 on your personal computer
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

library(parallel)
\end_layout

\begin_layout Plain Layout

cl <- makeCluster(4, type = "SOCK")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After that, you practice with the parallel programming ideas, using the
 functions that talk to the cluster
\end_layout

\begin_layout Standard
Which are topic of next section
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Rmpi
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Rmpi: R on top of OpenMPI}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
C library 
\begin_inset Quotes eld
\end_inset

OpenMPI
\begin_inset Quotes erd
\end_inset

 implements the 
\begin_inset Quotes eld
\end_inset

message passing interface
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
R package Rmpi is a layer between OpenMPI and R
\end_layout

\begin_layout Itemize
Use Rmpi to 
\begin_inset Quotes eld
\end_inset

spawn a cluster
\begin_inset Quotes erd
\end_inset

 of worker nodes, send work to them, collect it up
\end_layout

\begin_layout Itemize
Other parallel packages sit on top of Rmpi
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
SNOW (Ex60-HelloWorldSnow), SNOWFT (Ex61-HelloWorldSnowFT)
\end_layout

\begin_layout Itemize
doMPI, foreach, (and many other packages)
\end_layout

\begin_layout Itemize
R's own 
\begin_inset Quotes eld
\end_inset

parallel
\begin_inset Quotes erd
\end_inset

 sits 
\begin_inset Quotes eld
\end_inset

on top
\begin_inset Quotes erd
\end_inset

 of SNOW and other cluster-level packages.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Write programs with the Rmpi package, or with SNOW?}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Why use Rmpi?
\end_layout

\begin_layout Itemize
Plenty of features (was very 
\begin_inset Quotes eld
\end_inset

bare boned
\begin_inset Quotes erd
\end_inset

 in early days)
\end_layout

\begin_layout Itemize
When errors occur, source may be more obvious (not obscured by addon-components)
\end_layout

\begin_layout Standard
Why use SNOW or others that sit 
\begin_inset Quotes eld
\end_inset

on top
\begin_inset Quotes erd
\end_inset

 of Rmpi?
\end_layout

\begin_layout Itemize
SNOW may handle details more correctly than you can!
\end_layout

\begin_layout Itemize
R parallel attempts to standardize terminology, handling details for us
 (not perfect yet, but nothing is).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Submission script changes: orterun.}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
See: Ex53-HelloWorldRmpi
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "numbers=left"
inline false
status open

\begin_layout Plain Layout

#!/bin/sh
\end_layout

\begin_layout Plain Layout

#
\end_layout

\begin_layout Plain Layout

#MSUB -N RmpiHelloWorld-1
\end_layout

\begin_layout Plain Layout

#MSUB -l nodes=2:ppn=19:ib
\end_layout

\begin_layout Plain Layout

#MSUB -l walltime=00:60:00
\end_layout

\begin_layout Plain Layout

#MSUB -M pauljohn@ku.edu
\end_layout

\begin_layout Plain Layout

#MSUB -m bea
\end_layout

\begin_layout Plain Layout

#MSUB -q crmda
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cd $PBS_O_WORKDIR
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Please check your ~/.bash_profile to make sure
\end_layout

\begin_layout Plain Layout

## the correct modules will be loaded with new shells.
\end_layout

\begin_layout Plain Layout

## See discussion:
\end_layout

\begin_layout Plain Layout

## http://www.crmda.dept.ku.edu/timeline/archives/184
\end_layout

\begin_layout Plain Layout

## Don't load modules here, they will not apply to all
\end_layout

\begin_layout Plain Layout

## separate worker sessions.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpiexec -n 1 R --vanilla -f mpi-hello-1.R
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Look at the last line}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
mpiexec is a program from OpenMPI, it cooperates with cluster framework.
 Same effect as 
\begin_inset Quotes eld
\end_inset

orterun
\begin_inset Quotes erd
\end_inset

, which you will see in some of my examples.
\end_layout

\begin_layout Itemize
-n 1 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
cluster 
\begin_inset Quotes eld
\end_inset

spawn
\begin_inset Quotes erd
\end_inset

 mode means 
\begin_inset Quotes eld
\end_inset

claim one node for the master node
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Since script asks for more nodes above, code inside R program can spawn
 the worker nodes.
\end_layout

\end_deeper
\begin_layout Itemize
In old cluster, was necessary to provide a node list:
\end_layout

\begin_deeper
\begin_layout Standard
-hostfile $PBS_NODEFILE 
\end_layout

\begin_layout Standard
means 
\begin_inset Quotes eld
\end_inset

select nodes from available list
\begin_inset Quotes erd
\end_inset

.
 Not necessary now, as of July 2017
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{How Do I Know it is using "a cluster?"}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This job does almost nothing, except it spawns a set of nodes as a cluster
\end_layout

\begin_layout Standard
and asks each one for a little bit of information
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

if (!is.loaded("mpi_intitialize")){
\end_layout

\begin_layout Plain Layout

  library(Rmpi)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## see http://math.acadiau.ca/ACMMaC/Rmpi/sample.html
\end_layout

\begin_layout Plain Layout

# Spawn as many slaves as possible 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##mpi.spawn.Rslaves() 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

### Try to spawn worker processes
\end_layout

\begin_layout Plain Layout

mpi.spawn.Rslaves(nslaves=20)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# In case R exits unexpectedly, have it automatically clean up 
\end_layout

\begin_layout Plain Layout

# resources taken up by Rmpi (slaves, memory, etc...) 
\end_layout

\begin_layout Plain Layout

.Last <- function(){ 
\end_layout

\begin_layout Plain Layout

  if (is.loaded("mpi_initialize")){ 
\end_layout

\begin_layout Plain Layout

    if (mpi.comm.size(1) > 0){ 
\end_layout

\begin_layout Plain Layout

      print("Please use mpi.close.Rslaves() to close slaves.") 
\end_layout

\begin_layout Plain Layout

      mpi.close.Rslaves() 
\end_layout

\begin_layout Plain Layout

      } 
\end_layout

\begin_layout Plain Layout

      print("Please use mpi.quit() to quit R") 
\end_layout

\begin_layout Plain Layout

      .Call("mpi_finalize") 
\end_layout

\begin_layout Plain Layout

    } 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.remote.exec(paste("I am process ",mpi.comm.rank()," / ",mpi.comm.size()))
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To find out more about functions available in Rmpi, read the documentation
 provided with the package or find a more detailed example in hpcexamples
 Ex57-MISimulation-RMPI or Ex80 (which, at least now, uses RMPI directly).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Rmpi function list}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

## output from library(help=Rmpi)
\end_layout

\begin_layout Plain Layout

    Information on package 'Rmpi'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Description:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Package:            Rmpi
\end_layout

\begin_layout Plain Layout

Version:            0.5-9
\end_layout

\begin_layout Plain Layout

Date:               20010-11-30
\end_layout

\begin_layout Plain Layout

Title:              Interface (Wrapper) to MPI (Message-Passing
\end_layout

\begin_layout Plain Layout

                    Interface)
\end_layout

\begin_layout Plain Layout

Author:             Hao Yu
\end_layout

\begin_layout Plain Layout

Maintainer:         Hao Yu <hyu@stats.uwo.ca>
\end_layout

\begin_layout Plain Layout

Depends:            R (>= 2.2.0)
\end_layout

\begin_layout Plain Layout

Suggests:           rsprng, rlecuyer
\end_layout

\begin_layout Plain Layout

Description:        Rmpi provides an interface (wrapper) to MPI APIs.
\end_layout

\begin_layout Plain Layout

                    It also provides interactive R slave environment.
\end_layout

\begin_layout Plain Layout

License:            GPL (>= 2)
\end_layout

\begin_layout Plain Layout

URL:                http://www.stats.uwo.ca/faculty/yu/Rmpi
\end_layout

\begin_layout Plain Layout

Packaged:           2010-11-30 19:38:01 UTC; hyu
\end_layout

\begin_layout Plain Layout

Repository:         CRAN
\end_layout

\begin_layout Plain Layout

Date/Publication:   2010-11-30 19:55:14
\end_layout

\begin_layout Plain Layout

Built:              R 2.15.0; x86_64-redhat-linux-gnu; 2012-05-22
\end_layout

\begin_layout Plain Layout

                    20:35:48 UTC; unix
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Index:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

MPI APIs:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.abort               Abort (quit) all tasks associated with a comm
\end_layout

\begin_layout Plain Layout

mpi.allgather           Gather data from each process to all process
\end_layout

\begin_layout Plain Layout

mpi.allgatherv          Gather diff size data from each process to all process
\end_layout

\begin_layout Plain Layout

mpi.allreduce           Reduce all process's vectors into one vector
\end_layout

\begin_layout Plain Layout

mpi.barrier             Block the caller until all group have called it
\end_layout

\begin_layout Plain Layout

mpi.bcast               Broadcast a vector (int,double,char) to every process
\end_layout

\begin_layout Plain Layout

mpi.cancel              Cancel a nonblocking send or recv
\end_layout

\begin_layout Plain Layout

mpi.cart.coords         Translate a rank to the Cartesian topology coordinate
\end_layout

\begin_layout Plain Layout

mpi.cart.create         Create a Cartesian structure of arbitrary dimension
\end_layout

\begin_layout Plain Layout

mpi.cartdim.get         Get dim information about a Cartesian topology
\end_layout

\begin_layout Plain Layout

mpi.cart.get            Provide the Cartesian topology associated with a comm
\end_layout

\begin_layout Plain Layout

mpi.cart.rank           Translate a Cartesian topology coordinate to the rank
\end_layout

\begin_layout Plain Layout

mpi.cart.shift          Shift Cartesian topology in displacement and direction
\end_layout

\begin_layout Plain Layout

mpi.comm.disconnect     Disconeect and free a comm
\end_layout

\begin_layout Plain Layout

mpi.comm.dup            Duplicate a comm to a new comm
\end_layout

\begin_layout Plain Layout

mpi.comm.free           Free a comm
\end_layout

\begin_layout Plain Layout

mpi.comm.get.parent     Get the parent intercomm
\end_layout

\begin_layout Plain Layout

mpi.comm.rank           Find the rank (process id) of master and slaves
\end_layout

\begin_layout Plain Layout

mpi.comm.remote.size    Find the size of a remote group from an intercomm
\end_layout

\begin_layout Plain Layout

mpi.comm.size           Find the size (total # of master and slaves)
\end_layout

\begin_layout Plain Layout

mpi.comm.set.errhandler Set comm to error return (no crash)
\end_layout

\begin_layout Plain Layout

mpi.comm.spawn          Spawn slaves
\end_layout

\begin_layout Plain Layout

mpi.comm.test.inter     Test if a comm is an intercomm
\end_layout

\begin_layout Plain Layout

mpi.dims.create         Create a Cartesian dim used by mpi.cart.create
\end_layout

\begin_layout Plain Layout

mpi.finalize            Exit MPI environment (call MPI_Finalize())
\end_layout

\begin_layout Plain Layout

mpi.gather              Gather data from each process to a root process
\end_layout

\begin_layout Plain Layout

mpi.gatherv             Gather diff data from each process to a root process
\end_layout

\begin_layout Plain Layout

mpi.get.count           Get the length of a message for given status and type
\end_layout

\begin_layout Plain Layout

mpi.get.processor.name  Get the process (host) name
\end_layout

\begin_layout Plain Layout

mpi.info.create         Create an info object
\end_layout

\begin_layout Plain Layout

mpi.info.free           Free an info object
\end_layout

\begin_layout Plain Layout

mpi.info.get            Get the value from an info object and a key
\end_layout

\begin_layout Plain Layout

mpi.info.set            Set a key/value pair of an info object
\end_layout

\begin_layout Plain Layout

mpi.intercomm.merge     Merge a intercomm to a comm
\end_layout

\begin_layout Plain Layout

mpi.iprobe              Nonblocking use a source and a tag to set status
\end_layout

\begin_layout Plain Layout

mpi.irecv               Nonblocking receive a vector from a specific process
\end_layout

\begin_layout Plain Layout

mpi.isend               Nonblocking send a vector to a specific process
\end_layout

\begin_layout Plain Layout

mpi.probe               Use a source and a tag to set status
\end_layout

\begin_layout Plain Layout

mpi.recv                Receive a vector from a specific process
\end_layout

\begin_layout Plain Layout

mpi.reduce              Reduce all processes's vectors into one (one process)
\end_layout

\begin_layout Plain Layout

mpi.scatter             Opposite of mpi.gather
\end_layout

\begin_layout Plain Layout

mpi.scatterv            Opposite of mpi.gatherv (diff size data)
\end_layout

\begin_layout Plain Layout

mpi.send                Send a vector to a specific process
\end_layout

\begin_layout Plain Layout

mpi.sendrecv            Send & receive different vectors in one call
\end_layout

\begin_layout Plain Layout

mpi.sendrecv.replace    Send & replace a vector in one call
\end_layout

\begin_layout Plain Layout

mpi.test                Test if a nonblocking send/recv request is complete
\end_layout

\begin_layout Plain Layout

mpi.testall             Test if all nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

mpi.testany             Test if any nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

mpi.testsome            Test if some nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

mpi.test.cancelled      Test if a communication is cancelled by mpi.cancel
\end_layout

\begin_layout Plain Layout

mpi.universe.size       Total number of CPUs available
\end_layout

\begin_layout Plain Layout

mpi.wait                Wait if a nonblocking send/recv request is complete
\end_layout

\begin_layout Plain Layout

mpi.waitall             Wait if all nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

mpi.waitany             Wait if any nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

mpi.waitsome            Wait if some nonblocking send/recv requests are complete
\end_layout

\begin_layout Plain Layout

******************************************************************************
\end_layout

\begin_layout Plain Layout

MPI Extensions in R Environment:
\end_layout

\begin_layout Plain Layout

lamhosts                Hosts id and machine host name mapping
\end_layout

\begin_layout Plain Layout

mpi.allgather.Robj      Gather any type of objects to every number
\end_layout

\begin_layout Plain Layout

mpi.any.source          A constant for receiving a message from any source
\end_layout

\begin_layout Plain Layout

mpi.any.tag             A constant for receiving a message from any tag
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj          Broadcast an R object to every process
\end_layout

\begin_layout Plain Layout

mpi.comm.maxsize        Find the length of comm array
\end_layout

\begin_layout Plain Layout

mpi.exit                Call MPI_Finalize and detach Rmpi library
\end_layout

\begin_layout Plain Layout

mpi.gather.Robj         Gather any type of object to  a root process
\end_layout

\begin_layout Plain Layout

mpi.get.sourcetag       Get the source and tag for a given status
\end_layout

\begin_layout Plain Layout

mpi.hostinfo            Get the host information that the process is running
\end_layout

\begin_layout Plain Layout

mpi.init.sprng          MPI wrapper to initialize SPRNG in rsprng library
\end_layout

\begin_layout Plain Layout

mpi.is.master           TRUE if it is a master otherwise FALSE (slave)
\end_layout

\begin_layout Plain Layout

mpi.isend.Robj          Nonblocking send an R object to a specific process
\end_layout

\begin_layout Plain Layout

mpi.proc.null           Dummy source and destination
\end_layout

\begin_layout Plain Layout

mpi.quit                Call MPI_Finalize and quit R
\end_layout

\begin_layout Plain Layout

mpi.recv.Robj           Receive an R object from a process (by mpi.send.Robj)
\end_layout

\begin_layout Plain Layout

mpi.realloc.comm        Increase comm array to a new size
\end_layout

\begin_layout Plain Layout

mpi.realloc.request     Increase request array to a new size
\end_layout

\begin_layout Plain Layout

mpi.realloc.status      Increase status array to a new size
\end_layout

\begin_layout Plain Layout

mpi.request.maxsize     Find the length of request array
\end_layout

\begin_layout Plain Layout

mpi.scatter.Robj        Scatter an list to every number
\end_layout

\begin_layout Plain Layout

mpi.send.Robj           Send an R object to a specific process
\end_layout

\begin_layout Plain Layout

mpi.spawn.Rslaves       Spawn R slaves.
 The default R script is slavedaemon.R
\end_layout

\begin_layout Plain Layout

mpi.status.maxsize      Find the length of status array
\end_layout

\begin_layout Plain Layout

mpichosts               finds host names from master Windows registery database
\end_layout

\begin_layout Plain Layout

*****************************************************************************
\end_layout

\begin_layout Plain Layout

MPI Extensions specifically to slavedaemon.R Script (interactive R slaves).
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.apply               Scatter an array to slaves and then apply a fun
\end_layout

\begin_layout Plain Layout

mpi.applyLB             Load balancing version of mpi.apply
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave    Master sends an Robj to all slaves
\end_layout

\begin_layout Plain Layout

mpi.bcast.cmd           Broadcast a commond to every process
\end_layout

\begin_layout Plain Layout

mpi.close.Rslaves       Close all slaves launched by mpi.spawn.Rslaves()
\end_layout

\begin_layout Plain Layout

mpi.parApply            (Load balancing) parallel apply
\end_layout

\begin_layout Plain Layout

mpi.parCapply           (Load balancing) parallel column apply
\end_layout

\begin_layout Plain Layout

mpi.parLapply           (Load balancing) parallel lapply
\end_layout

\begin_layout Plain Layout

mpi.parRapply           (Load balancing) parallel row apply
\end_layout

\begin_layout Plain Layout

mpi.parReplicate        A wrapper to mpi.parSapply for repeated eval of an
 expr
\end_layout

\begin_layout Plain Layout

mpi.parSapply           (Load balancing) parallel sapply
\end_layout

\begin_layout Plain Layout

mpi.parSim              (Load balancing) parallel Monte Carlo simulation
\end_layout

\begin_layout Plain Layout

mpi.remote.exec         Run a command remotely on slaves and return
\end_layout

\begin_layout Plain Layout

                        results back to the master
\end_layout

\begin_layout Plain Layout

mpi.setup.rngstream     Setup RNDstream (package rlecuyer) on all slaves
\end_layout

\begin_layout Plain Layout

mpi.setup.sprng         Setup SPRNG (package rsprng) on all slaves
\end_layout

\begin_layout Plain Layout

slave.hostinfo          Show all slave rank, comm, host information
\end_layout

\begin_layout Plain Layout

tailslave.log           Tail (view) last lines of slave log files
\end_layout

\begin_layout Plain Layout

*****************************************************************************
\end_layout

\begin_layout Plain Layout

Some Internal Functions used by Other MPI Functions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bin.nchar               Find the length of a binary string
\end_layout

\begin_layout Plain Layout

mpi.comm.is.null        Test if a comm is NULL (no members)
\end_layout

\begin_layout Plain Layout

string                  Create a string (empty space character) buffer
\end_layout

\begin_layout Plain Layout

****************************************************************************
\end_layout

\begin_layout Plain Layout

Deprecated functions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.parallel.sim        It is renamed to mpi.parSim.
 Still available.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{The Basic Parallel R Problem}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Each node needs to have EVERYTHING it needs to do its job.
\end_layout

\begin_layout Itemize
It is NOT sufficient to simply tell a node to run a function
\end_layout

\begin_layout Itemize
Before that, node must be 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
given required functions and data objects
\end_layout

\begin_layout Itemize
told to do preparatory calculations
\end_layout

\end_deeper
\begin_layout Itemize
If you forget to export a function to the worker nodes, a parallel R program
 will hang indefinitely, without generating an error or output.
 (Hence: be careful)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Rmpi Programming: sending everything out}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Excerpt from Ex80-PrevSci2007, version-3.R
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

## OMIT code to create functions
\end_layout

\begin_layout Plain Layout

## calculateRegressions, createOneTable, createTSPlot, drawSample
\end_layout

\begin_layout Plain Layout

## imposeMissings plotRows, seedlist, conductSimulation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Create a cluster
\end_layout

\begin_layout Plain Layout

library(Rmpi)
\end_layout

\begin_layout Plain Layout

mpi.spawn.Rslaves(nslaves=6)
\end_layout

\begin_layout Plain Layout

## Send functions to each worker node:
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(calculateRegressions)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(createOneTable)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(createTSPlot)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(drawSample)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(imposeMissings)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(imputeDF)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(missingMask)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(plotRows)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(seedlist)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(tablelist)
\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(conductSimulation)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.bcast.Robj2slave(dirname)
\end_layout

\begin_layout Plain Layout

mpi.remote.exec(setwd(dirname))
\end_layout

\begin_layout Plain Layout

##forces a random draw that initializes the random generators
\end_layout

\begin_layout Plain Layout

mpi.remote.exec(rnorm(1))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##results <- mpi.parLapply(1:nruns, conductSimulation, ssizes=ssizes,  b0=b0,
 b1=b1, pm=pm, m=m, setseed=NULL)
\end_layout

\begin_layout Plain Layout

results <- mpi.applyLB(1:nruns, conductSimulation, ssizes=ssizes,  b0=b0,
 b1=b1, pm=pm, m=m, setseed=NULL)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

save(results, file=paste("results", jobname,".Rda", sep=""))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## lets just check again, see if they are listening.
\end_layout

\begin_layout Plain Layout

mpi.remote.exec(rnorm(1))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mpi.close.Rslaves()
\end_layout

\begin_layout Plain Layout

mpi.quit()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{SNOW: Simple Network of Workstations}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Pioneered by Luke Tierney, famous statistician U.
 Iowa (my Alma Mater!)
\end_layout

\begin_layout Itemize
SNOW package interface emphasizes CLARITY, attempting to handle fine-grained
 details behind the scenes
\end_layout

\begin_layout Itemize
Highlights: 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Can spawn clusters of different types, including RMPI (which we use on ACF)
\end_layout

\begin_layout Itemize
Parallel versions of apply and lapply
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Remember R basics: apply, lapply}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
R allows for loops, but discourages their usage for style & efficiency
\end_layout

\begin_layout Itemize
Instead, we use 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Description
apply to apply a function to 
\begin_inset Quotes eld
\end_inset

rows
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

columns
\begin_inset Quotes erd
\end_inset

 from a matrix
\end_layout

\begin_layout Description
lapply to apply a function to each separate object in a list
\end_layout

\begin_layout Itemize
practice with those functions! Read my lecture functions-1.
\end_layout

\end_deeper
\begin_layout Itemize
SNOW offers several cluster-capable functions to do the same kind of work.
\end_layout

\begin_layout Itemize
R parallel package incorporates many SNOW functions and idioms
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Snow Documents: ?parLapply}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

snow-parallel               package:snow               R Documentation
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Higher Level SNOW Functions
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Description:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     Parallel versions of 'apply' and related functions.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Usage:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     parLapply(cl, x, fun, ...)
\end_layout

\begin_layout Plain Layout

     parSapply(cl, X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) 
\end_layout

\begin_layout Plain Layout

     parApply(cl, X, MARGIN, FUN, ...)
\end_layout

\begin_layout Plain Layout

     parRapply(cl, x, fun, ...)
\end_layout

\begin_layout Plain Layout

     parCapply(cl, x, fun, ...)
\end_layout

\begin_layout Plain Layout

     parMM(cl, A, B)
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

Arguments:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      cl: cluster object
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     fun: function or character string naming a function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       X: array to be used
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       x: matrix to be used
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     FUN: function or character string naming a function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  MARGIN: vector specifying the dimensions to use.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

simplify: logical; see 'sapply'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

USE.NAMES: logical; see 'sapply'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     ...: additional arguments to pass to standard function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       A: matrix
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

       B: matrix
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Details:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     'parLapply', 'parSapply', and 'parApply' are parallel versions of
\end_layout

\begin_layout Plain Layout

     'lapply', 'sapply', and 'apply'.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     'parRapply' and 'parCapply' are parallel row and column 'apply'
\end_layout

\begin_layout Plain Layout

     functions for a matrix 'x'; they may be slightly more efficient
\end_layout

\begin_layout Plain Layout

     than 'parApply'.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     'parMM' is a very simple(minded) parallel matrix multiply; it is
\end_layout

\begin_layout Plain Layout

     intended as an illustration.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     For more details see <URL:
\end_layout

\begin_layout Plain Layout

     http://www.stat.uiowa.edu/~luke/R/cluster/cluster.html>.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Examples:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     ## Not run:
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

     cl <- makeSOCKcluster(c("localhost","localhost"))
\end_layout

\begin_layout Plain Layout

     parSapply(cl, 1:20, get("+"), 3)
\end_layout

\begin_layout Plain Layout

     ## End(Not run)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Ex65-R parallel}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
This is the 
\begin_inset Quotes eld
\end_inset

test case
\begin_inset Quotes erd
\end_inset

 we use, the template for many projects
\end_layout

\begin_layout Itemize
Shows how to create MPI cluster,.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

## Paul Johnson
\end_layout

\begin_layout Plain Layout

## 2012-01-05
\end_layout

\begin_layout Plain Layout

## 2015-11-16
\end_layout

\begin_layout Plain Layout

## 2016-10-24
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Use Rmpi via SNOW via R's parallel
\end_layout

\begin_layout Plain Layout

## "Message Passing Interface" (OpenMPI implementation)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(parallel)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This is a nice boilerplate that is not necessary, but
\end_layout

\begin_layout Plain Layout

## may help for graceful shutdown.
  When R tries to quit,
\end_layout

\begin_layout Plain Layout

## it tries to run the function .Last.
 If user forgets
\end_layout

\begin_layout Plain Layout

## to closer cluster, this may relinquish resources more gracefully.
\end_layout

\begin_layout Plain Layout

.Last <- function(){
\end_layout

\begin_layout Plain Layout

    if (is.loaded("mpi_initialize")){
\end_layout

\begin_layout Plain Layout

        if (Rmpi::mpi.comm.size(1) > 0){
\end_layout

\begin_layout Plain Layout

            print("Close nodes.")
\end_layout

\begin_layout Plain Layout

            snow::stopCluster(cl)
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        print("Please use mpi.quit() to quit R")
\end_layout

\begin_layout Plain Layout

        Rmpi::mpi.quit()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The main functions we need to demonstrate are
\end_layout

\begin_layout Plain Layout

## makeCluster: creates worker nodes
\end_layout

\begin_layout Plain Layout

## clusterCall: calls function with same arg on each node
\end_layout

\begin_layout Plain Layout

## clusterEvalQ: Sends a string to each node in cluster.
 
\end_layout

\begin_layout Plain Layout

## clusterExport: sends object to each node
\end_layout

\begin_layout Plain Layout

## 
\end_layout

\begin_layout Plain Layout

## and then a family of "apply-like" functions
\end_layout

\begin_layout Plain Layout

## parLapply, parApply.
\end_layout

\begin_layout Plain Layout

##
\end_layout

\begin_layout Plain Layout

## clusterApply is unfamiliar to me, it appears to be
\end_layout

\begin_layout Plain Layout

## the same as parLapply 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Causes an MPI cluster to exist.
 Same as snow package,
\end_layout

\begin_layout Plain Layout

## uses Rmpi functionality
\end_layout

\begin_layout Plain Layout

NCORES <- 10 ## Number of processors -1
\end_layout

\begin_layout Plain Layout

cl <- makeCluster(NCORES, type = "MPI") 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## clusterCall runs a given command on each node.
  Can be an
\end_layout

\begin_layout Plain Layout

## individual command, such as loading a package
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## clusterEvalq runs a command on each node.
  Output is written on the
\end_layout

\begin_layout Plain Layout

## session unless we prevent that by assigning the result.
  Note the
\end_layout

\begin_layout Plain Layout

## return, node by node, is verbose
\end_layout

\begin_layout Plain Layout

clusterEvalQ(cl, library(mvtnorm))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Ask each system for information
\end_layout

\begin_layout Plain Layout

clusterEvalQ(cl, Sys.info())
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## If we wanted to, we could put each node to use
\end_layout

\begin_layout Plain Layout

## the same random number stream.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## first, lets set the seed on the manager node
\end_layout

\begin_layout Plain Layout

set.seed(123123)
\end_layout

\begin_layout Plain Layout

(p <- rnorm(1, m = 33))
\end_layout

\begin_layout Plain Layout

##See, nodes same as p!
\end_layout

\begin_layout Plain Layout

clusterEvalQ(cl, {
\end_layout

\begin_layout Plain Layout

    set.seed(123123)
\end_layout

\begin_layout Plain Layout

    rnorm(1, m = 33)
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## cluster Call is similar, but it is for running a function with the
\end_layout

\begin_layout Plain Layout

## same arguments on each node.
  Note how the syntax separates the
\end_layout

\begin_layout Plain Layout

## name of the function from the arguments
\end_layout

\begin_layout Plain Layout

clusterCall(cl, set.seed, 123123)
\end_layout

\begin_layout Plain Layout

clusterCall(cl, rnorm, 1, m = 33)
\end_layout

\begin_layout Plain Layout

## Note they stay in sync if you do it again
\end_layout

\begin_layout Plain Layout

clusterCall(cl, rnorm, 1, m = 33)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

### sends request to each node in system
\end_layout

\begin_layout Plain Layout

clusterCall( cl, function() rnorm(1, 33,1 ) )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## It is not necessary to have arguments.
  Here is a function with no
\end_layout

\begin_layout Plain Layout

## arguments.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

getNodeInfo <- function()  Sys.info()[c("nodename","machine")]
\end_layout

\begin_layout Plain Layout

clusterCall(cl, getNodeInfo)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This does same, but improvises the function
\end_layout

\begin_layout Plain Layout

## in the middle of the syntax.
  Sometimes, this keeps a script
\end_layout

\begin_layout Plain Layout

## cleaner because there are not so many functions floating about.
 
\end_layout

\begin_layout Plain Layout

clusterCall( cl, function() Sys.info()[c("nodename","machine")])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Make the return invisible.
  Catch the
\end_layout

\begin_layout Plain Layout

## return value, which is a list
\end_layout

\begin_layout Plain Layout

res1 <- clusterCall(cl, function() {
\end_layout

\begin_layout Plain Layout

    a <- Sys.info()
\end_layout

\begin_layout Plain Layout

    b <- date()
\end_layout

\begin_layout Plain Layout

    invisible(list(a, b))
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

res1[[1]]
\end_layout

\begin_layout Plain Layout

res1[[2]]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Why do I keep asking the nodes who they are?
\end_layout

\begin_layout Plain Layout

## Sometimes we have errors or slowness that is due to
\end_layout

\begin_layout Plain Layout

## a flaw in MPI or the cluster, and it really helps to know
\end_layout

\begin_layout Plain Layout

## which nodes are being contacted, and when.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The key quality of clusterCall is that a function, and
\end_layout

\begin_layout Plain Layout

## maybe the Arguments, 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## parApply example.
  Lets get the mean, and sum of each column.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myNorms <- matrix(rnorm(10000), ncol = 100)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myFn <- function(v){
\end_layout

\begin_layout Plain Layout

    s <-Sys.info()[c("nodename")]
\end_layout

\begin_layout Plain Layout

    ms <- sum(v)
\end_layout

\begin_layout Plain Layout

    list(s, mysum = sum(v), mymean = mean(v))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

system.time(
\end_layout

\begin_layout Plain Layout

mypapply <- parApply(cl, myNorms, 2,  myFn)
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## A chore like that might be faster if we run on
\end_layout

\begin_layout Plain Layout

## just one node
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

system.time(
\end_layout

\begin_layout Plain Layout

myonenode <- list(Sys.info(),
\end_layout

\begin_layout Plain Layout

                  ms = colSums(myNorms),
\end_layout

\begin_layout Plain Layout

                  mymean = apply(myNorms, 2, mean)
\end_layout

\begin_layout Plain Layout

                  )
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mypapply[[55]]
\end_layout

\begin_layout Plain Layout

## Output is organized differently
\end_layout

\begin_layout Plain Layout

myonenode$mymean[55]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The output from parSapply is simplified in an understandable
\end_layout

\begin_layout Plain Layout

## way
\end_layout

\begin_layout Plain Layout

system.time(
\end_layout

\begin_layout Plain Layout

    mysapply <- parSapply(cl, myNorms, myFn)
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Here is another example of parSapply copied from the vignette that
\end_layout

\begin_layout Plain Layout

## was distributed with the original parallel package in R.
  I do not
\end_layout

\begin_layout Plain Layout

## understand what this is doing, maybe one of you can explain it to
\end_layout

\begin_layout Plain Layout

## me.
\end_layout

\begin_layout Plain Layout

library(spatial)
\end_layout

\begin_layout Plain Layout

R <- 1000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

tget <- function(z, r = 3.5) sum(dist(cbind(z$x, z$y)) < r)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x <- seq(0, 1, 0.1)
\end_layout

\begin_layout Plain Layout

## pj: Don't know why following is able to find "towns.dat"
\end_layout

\begin_layout Plain Layout

towns <- ppinit("towns.dat")
\end_layout

\begin_layout Plain Layout

## The Strauss function can be executed for various values of x
\end_layout

\begin_layout Plain Layout

tget(Strauss(69, c = x[1], r = 3.5))
\end_layout

\begin_layout Plain Layout

tget(Strauss(69, c = x[4], r = 3.5))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Will repeat that calculation 100 times,
\end_layout

\begin_layout Plain Layout

## for a given value of the parameter c in tget.
\end_layout

\begin_layout Plain Layout

run3 <- function(x) {
\end_layout

\begin_layout Plain Layout

    library(spatial)
\end_layout

\begin_layout Plain Layout

    towns <- ppinit("towns.dat") # has side effects
\end_layout

\begin_layout Plain Layout

    mean(replicate(R, tget(Strauss(69, c = x, r = 3.5))))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clusterExport(cl, c("R", "towns", "tget"))
\end_layout

\begin_layout Plain Layout

res <- c(0, parSapply(cl, x[-1], run3)) # 10 tasks
\end_layout

\begin_layout Plain Layout

res
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Don't need to do this because I had the .last function
\end_layout

\begin_layout Plain Layout

## above
\end_layout

\begin_layout Plain Layout

## stopCluster(cl)
\end_layout

\begin_layout Plain Layout

## Rmpi::mpi.quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Sometimes, we want to stop the cluster and continue
\end_layout

\begin_layout Plain Layout

## with calculations on one noode.
 We'd get rid of the
\end_layout

\begin_layout Plain Layout

## .last function above, then we'd do this.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stopCluster(cl)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print(paste("I'm not dead yet, says your R session"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print(sum(rnorm(1000)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## the next does kill the session entirely, however.
\end_layout

\begin_layout Plain Layout

Rmpi::mpi.quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Ex60-HelloWorldSnow}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

## snow-hello.R
\end_layout

\begin_layout Plain Layout

### Paul Johnson
\end_layout

\begin_layout Plain Layout

### 2010-03-25
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

### Demonstration of SNOW "Simple Network of Workstations" using MPI
\end_layout

\begin_layout Plain Layout

### "Message Passing Interface" (OpenMPI implementation)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(snow)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

p <- rnorm(123, m=33)
\end_layout

\begin_layout Plain Layout

cl <- makeCluster(18, type="MPI") 
\end_layout

\begin_layout Plain Layout

### sends function to each system
\end_layout

\begin_layout Plain Layout

clusterCall( cl, function() Sys.info()[c("nodename","machine")])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clusterCall( cl, function() rnorm(1, 33,1 ) )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myNorms <- matrix( rnorm(1000), ncol=10 )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## goes column by column
\end_layout

\begin_layout Plain Layout

mypapply <- parApply(cl, myNorms, 2,  print )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

attributes(mypapply)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mypapply <- parApply(cl, myNorms, 2, mean )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mypapply
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myNorms <- matrix( rnorm(1000), ncol=10)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mySum <- function( v ){
\end_layout

\begin_layout Plain Layout

    s <-Sys.info()[c("nodename")]
\end_layout

\begin_layout Plain Layout

    ms <- sum(v)
\end_layout

\begin_layout Plain Layout

    list(s, ms)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mypcapply <- parApply(cl, myNorms, 2,  mySum)
\end_layout

\begin_layout Plain Layout

mypcapply
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myNorms <- matrix(rnorm(2500), ncol=25)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

myMeans <- function(v){
\end_layout

\begin_layout Plain Layout

  s <- Sys.info()[c("nodename")]
\end_layout

\begin_layout Plain Layout

  ms <- mean(v)
\end_layout

\begin_layout Plain Layout

  list(s, ms)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mypcapply <- parApply(cl, myNorms, 2, myMeans )
\end_layout

\begin_layout Plain Layout

mypcapply
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

stopCluster(cl)
\end_layout

\begin_layout Plain Layout

mpi.quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Ex60-HelloWorldSnow Output}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

##
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R version 2.14.1 (2011-12-22)
\end_layout

\begin_layout Plain Layout

Copyright (C) 2011 The R Foundation for Statistical Computing
\end_layout

\begin_layout Plain Layout

ISBN 3-900051-07-0
\end_layout

\begin_layout Plain Layout

Platform: x86_64-redhat-linux-gnu (64-bit)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R is free software and comes with ABSOLUTELY NO WARRANTY.
\end_layout

\begin_layout Plain Layout

You are welcome to redistribute it under certain conditions.
\end_layout

\begin_layout Plain Layout

Type 'license()' or 'licence()' for distribution details.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  Natural language support but running in an English locale
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

R is a collaborative project with many contributors.
\end_layout

\begin_layout Plain Layout

Type 'contributors()' for more information and
\end_layout

\begin_layout Plain Layout

'citation()' on how to cite R or R packages in publications.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Type 'demo()' for some demos, 'help()' for on-line help, or
\end_layout

\begin_layout Plain Layout

'help.start()' for an HTML browser interface to help.
\end_layout

\begin_layout Plain Layout

Type 'q()' to quit R.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> ### Paul Johnson
\end_layout

\begin_layout Plain Layout

> ### 2010-03-25
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> ### Demonstration of SNOW "Simple Network of Workstations" using MPI
\end_layout

\begin_layout Plain Layout

> ### "Message Passing Interface" (OpenMPI implementation)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> library(snow)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> p <- rnorm(123, m=33)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> cl <- makeCluster(18, type="MPI") 
\end_layout

\begin_layout Plain Layout

	18 slaves are spawned successfully.
 0 failed.
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> ### sends function to each system
\end_layout

\begin_layout Plain Layout

> clusterCall( cl, function() Sys.info()[c("nodename","machine")])
\end_layout

\begin_layout Plain Layout

[[1]]
\end_layout

\begin_layout Plain Layout

            nodename              machine 
\end_layout

\begin_layout Plain Layout

"compute-2-11.local"             "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]]
\end_layout

\begin_layout Plain Layout

            nodename              machine 
\end_layout

\begin_layout Plain Layout

"compute-2-10.local"             "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-9.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-8.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-7.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-6.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-5.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-4.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-3.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-2.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[11]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-1.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[12]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-2-0.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[13]]
\end_layout

\begin_layout Plain Layout

            nodename              machine 
\end_layout

\begin_layout Plain Layout

"compute-1-14.local"             "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[14]]
\end_layout

\begin_layout Plain Layout

            nodename              machine 
\end_layout

\begin_layout Plain Layout

"compute-1-13.local"             "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[15]]
\end_layout

\begin_layout Plain Layout

            nodename              machine 
\end_layout

\begin_layout Plain Layout

"compute-1-11.local"             "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[16]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-1-9.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[17]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-1-8.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[18]]
\end_layout

\begin_layout Plain Layout

           nodename             machine 
\end_layout

\begin_layout Plain Layout

"compute-1-7.local"            "x86_64" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> clusterCall( cl, function() rnorm(1, 33,1 ) )
\end_layout

\begin_layout Plain Layout

[[1]]
\end_layout

\begin_layout Plain Layout

[1] 31.80348
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]]
\end_layout

\begin_layout Plain Layout

[1] 31.3416
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]]
\end_layout

\begin_layout Plain Layout

[1] 34.51375
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]]
\end_layout

\begin_layout Plain Layout

[1] 32.44499
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]]
\end_layout

\begin_layout Plain Layout

[1] 34.40459
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]]
\end_layout

\begin_layout Plain Layout

[1] 34.40721
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]]
\end_layout

\begin_layout Plain Layout

[1] 32.79563
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]]
\end_layout

\begin_layout Plain Layout

[1] 32.58481
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]]
\end_layout

\begin_layout Plain Layout

[1] 34.21046
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]]
\end_layout

\begin_layout Plain Layout

[1] 33.47829
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[11]]
\end_layout

\begin_layout Plain Layout

[1] 31.11419
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[12]]
\end_layout

\begin_layout Plain Layout

[1] 33.2634
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[13]]
\end_layout

\begin_layout Plain Layout

[1] 32.41902
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[14]]
\end_layout

\begin_layout Plain Layout

[1] 34.09947
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[15]]
\end_layout

\begin_layout Plain Layout

[1] 31.72768
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[16]]
\end_layout

\begin_layout Plain Layout

[1] 33.12429
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[17]]
\end_layout

\begin_layout Plain Layout

[1] 31.78337
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[18]]
\end_layout

\begin_layout Plain Layout

[1] 33.91641
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> myNorms <- matrix( rnorm(1000), ncol=10 )
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> ## goes column by column
\end_layout

\begin_layout Plain Layout

> mypapply <- parApply(cl, myNorms, 2,  print )
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> attributes(mypapply)
\end_layout

\begin_layout Plain Layout

$dim
\end_layout

\begin_layout Plain Layout

[1] 100  10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypapply <- parApply(cl, myNorms, 2, mean )
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypapply
\end_layout

\begin_layout Plain Layout

 [1] -0.13995753 -0.14750300  0.13525781  0.05435524 -0.03935838 -0.07484654
\end_layout

\begin_layout Plain Layout

 [7] -0.05063702 -0.01128428  0.01850835  0.10469531
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> myNorms <- matrix( rnorm(1000), ncol=10)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mySum <- function( v ){
\end_layout

\begin_layout Plain Layout

+     s <-Sys.info()[c("nodename")]
\end_layout

\begin_layout Plain Layout

+     ms <- sum(v)
\end_layout

\begin_layout Plain Layout

+     list(s, ms)
\end_layout

\begin_layout Plain Layout

+ }
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypcapply <- parApply(cl, myNorms, 2,  mySum)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypcapply
\end_layout

\begin_layout Plain Layout

[[1]]
\end_layout

\begin_layout Plain Layout

[[1]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-11.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[1]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -13.98086
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]]
\end_layout

\begin_layout Plain Layout

[[2]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-9.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 4.479569
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]]
\end_layout

\begin_layout Plain Layout

[[3]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-7.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 4.559974
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]]
\end_layout

\begin_layout Plain Layout

[[4]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-5.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 1.676203
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]]
\end_layout

\begin_layout Plain Layout

[[5]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-3.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -13.94175
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]]
\end_layout

\begin_layout Plain Layout

[[6]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-2.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -9.71347
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]]
\end_layout

\begin_layout Plain Layout

[[7]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-0.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -12.83219
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]]
\end_layout

\begin_layout Plain Layout

[[8]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-13.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -10.63648
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]]
\end_layout

\begin_layout Plain Layout

[[9]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-9.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -12.83259
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]]
\end_layout

\begin_layout Plain Layout

[[10]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-7.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -14.8644
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> myNorms <- matrix(rnorm(2500), ncol=25)
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> myMeans <- function(v){
\end_layout

\begin_layout Plain Layout

+   s <- Sys.info()[c("nodename")]
\end_layout

\begin_layout Plain Layout

+   ms <- mean(v)
\end_layout

\begin_layout Plain Layout

+   list(s, ms)
\end_layout

\begin_layout Plain Layout

+ }
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypcapply <- parApply(cl, myNorms, 2, myMeans )
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> mypcapply
\end_layout

\begin_layout Plain Layout

[[1]]
\end_layout

\begin_layout Plain Layout

[[1]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-11.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[1]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.05501698
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]]
\end_layout

\begin_layout Plain Layout

[[2]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-11.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[2]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.0557545
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]]
\end_layout

\begin_layout Plain Layout

[[3]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-10.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[3]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.1918846
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]]
\end_layout

\begin_layout Plain Layout

[[4]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-9.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[4]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.06132683
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]]
\end_layout

\begin_layout Plain Layout

[[5]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-8.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[5]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.1230541
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]]
\end_layout

\begin_layout Plain Layout

[[6]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-8.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[6]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.05540265
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]]
\end_layout

\begin_layout Plain Layout

[[7]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-7.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[7]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.09544129
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]]
\end_layout

\begin_layout Plain Layout

[[8]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-6.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[8]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.02780365
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]]
\end_layout

\begin_layout Plain Layout

[[9]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-5.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[9]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.1017519
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]]
\end_layout

\begin_layout Plain Layout

[[10]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-5.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[10]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.137849
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[11]]
\end_layout

\begin_layout Plain Layout

[[11]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-4.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[11]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.05403865
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[12]]
\end_layout

\begin_layout Plain Layout

[[12]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-3.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[12]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.02347465
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[13]]
\end_layout

\begin_layout Plain Layout

[[13]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-3.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[13]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.2821554
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[14]]
\end_layout

\begin_layout Plain Layout

[[14]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-2.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[14]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.04790076
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[15]]
\end_layout

\begin_layout Plain Layout

[[15]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-1.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[15]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.02619804
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[16]]
\end_layout

\begin_layout Plain Layout

[[16]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-0.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[16]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.006781886
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[17]]
\end_layout

\begin_layout Plain Layout

[[17]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-2-0.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[17]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.2478439
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[18]]
\end_layout

\begin_layout Plain Layout

[[18]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-14.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[18]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.08368503
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[19]]
\end_layout

\begin_layout Plain Layout

[[19]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-13.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[19]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.005240985
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[20]]
\end_layout

\begin_layout Plain Layout

[[20]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-11.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[20]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.06549931
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[21]]
\end_layout

\begin_layout Plain Layout

[[21]][[1]]
\end_layout

\begin_layout Plain Layout

            nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-11.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[21]][[2]]
\end_layout

\begin_layout Plain Layout

[1] -0.01406486
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[22]]
\end_layout

\begin_layout Plain Layout

[[22]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-9.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[22]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.02487288
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[23]]
\end_layout

\begin_layout Plain Layout

[[23]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-8.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[23]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.001714545
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[24]]
\end_layout

\begin_layout Plain Layout

[[24]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-7.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[24]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.002100271
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[25]]
\end_layout

\begin_layout Plain Layout

[[25]][[1]]
\end_layout

\begin_layout Plain Layout

           nodename 
\end_layout

\begin_layout Plain Layout

"compute-1-7.local" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[[25]][[2]]
\end_layout

\begin_layout Plain Layout

[1] 0.001404288
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> stopCluster(cl)
\end_layout

\begin_layout Plain Layout

[1] 1
\end_layout

\begin_layout Plain Layout

> mpi.quit()
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim, allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{R parallel package}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
R parallel incorporates SNOW concepts and functions
\end_layout

\begin_layout Standard
Because parallel is in the R distribution, it should be considered a top-priorit
y learning objective
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{frame}[containsverbatim,allowframebreaks]
\end_layout

\begin_layout Plain Layout


\backslash
frametitle{Will Worry about Replication of Random Streams In Next Lecture}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each of the parallel packages has its own idioms to set the random number
 seed on the separate nodes.
\end_layout

\begin_layout Standard
So far, these packages aim at replication of a complete batch of simulations
 across a lot of compute nodes.
\end_layout

\begin_layout Standard
I will need to explain L'Ecuyer 
\begin_inset Quotes eld
\end_inset

many separate streams
\begin_inset Quotes erd
\end_inset

 and the SPRNG approaches, along with ways to replicate them.
\end_layout

\begin_layout Standard
My suggestion is 
\begin_inset Quotes eld
\end_inset

Portable Parallel Seeds
\begin_inset Quotes erd
\end_inset

 in Ex81.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{frame}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
